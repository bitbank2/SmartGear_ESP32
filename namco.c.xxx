/********************************************/
/* Code to emulate Gaplus arcade hardware   */
/* Targ contains 3 1Mhz 6809s for game play */
/* The display is 224x288x8  colors         */
/*                                          */
/* Written by Larry Bank                    */
/* Copyright 1999 BitBank Software, Inc.    */
/* Driver started 1/31/99                   */
/********************************************/
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
//#include <gtk/gtk.h>
//#include <odroid_go.h>
//#include <esp_spi_flash.h>
//#include <esp_partition.h>
#ifdef _WIN32_WCE
#include <windows.h>
#include <tchar.h>
#else
#include "my_windows.h"
#endif

#include "smartgear.h"
#include "emu.h"
#include "emuio.h"
#include  "miniz.h"
#include "unzip.h"

#define NUM_STARS 128
static STARS *pStars;
static EMUHANDLERS *emuh1, *emuh2, *emuh3; /* 6809 memory handlers */
unsigned char *mem_map, *mem_map1, *mem_map2, *mem_map3, *mem_sprites, *pADPCM;
//static unsigned char cPSGReg;
static int iStop;
static int iPacGame;
//YM2151 *pYM2151;
//static unsigned long ulCPUOffsets[16];
//static unsigned long ulCPUOffsets2[16];
static int iSuperPacGame;
int iOldTicks;
extern BOOL bHiLoaded;
//static BOOL bTrace = FALSE;
static BOOL bUserAbort = FALSE;
static unsigned char *pCharPROM, *pSpritePROM; /* Pointers to color PROMs */
//static BOOL bAutoLoad = FALSE;
void PacPrepSounds(int);
void SPSoundWrite(unsigned char *);
void PacSoundUpdate(signed short *, int);
signed char *pWaveforms; /* NAMCO sound pattern buffer */
extern int iAudioShift;
static int iPosition[16];
uint32_t pWave[16];
unsigned char cVolume[16];
int iFreq[16];
static int coin1, coin2, credits, start1, start2;
static int crednum[] = { 1, 2, 3, 6, 7, 1, 3, 1 };
static int credden[] = { 1, 1, 1, 1, 1, 2, 2, 3 };
//extern char *szGalagaSample[];
static REGS6809 regs1, regs2, regs3;
static REGS6800 regs2a;
static REGSZ80 regs;
static char cIRQEnable1, cIRQEnable2, cIRQEnable3;
static unsigned char *pBanked;
static int iScroll1, iScroll2, iScroll3;
static PALETTEENTRY *pPalettes;
static unsigned char cBlank, cROMBank, cPaletteBank, cIOMode;
static uint32_t ulTransparent;
static int iROMBank;
static unsigned char *pPLColors; /* Color lookup tables */
static unsigned char *pForeground, *pBackground;
//static unsigned char ucAddrDecode[32];
static uint32_t ulOldKeys;
unsigned char cTransparent, cTransparent2;
extern unsigned char *pCharmap;
unsigned char *cDirtyChar;
extern unsigned long *lCharAddr;
unsigned long *lCharAddr2;
unsigned char pSoundPROM[512];
static unsigned char cSPColorConvert[8] = {0,0x21,0x47,0x68,0x97,0xb8,0xde,0xff};

typedef struct tagsuperpac_struct
{
unsigned char cIRQEnable1;
unsigned char cIRQEnable2;
unsigned char cMappyScroll;
unsigned char cCPU2Enable;
} SUPERPAC_STRUCT;

typedef struct skykid_struct
{
int iScroll0;
unsigned char cROMBank;
unsigned char cCPUEnable;
unsigned char cIRQEnable1;
unsigned char cIRQEnable2;
} SKYKID_STRUCT;


typedef struct tagpac_struct
{
unsigned char cPacIRQVal;
unsigned char cPacIRQEnable;
unsigned char cPacSoundEnable;
unsigned char ucIRQ;
int iGfxBank;
int iPosition[8]; // current waveform positions
} PAC_STRUCT;

SKYKID_STRUCT skykidstruct;
PAC_STRUCT pacstruct;
SUPERPAC_STRUCT superpacstruct;

unsigned char cPacColorConvert[8] = {0,0x21,0x47,0x68,0x97,0xb8,0xde,0xff};
/* The 16 palette colors */
unsigned char cPacPal[16] = {0x00,0x07,0x66,0xEF,0x00,0xF8,0xEA,0x6F,0x00,0x3F,0x00,0xC9,0x38,0xAA,0xAF,0xF6};
/* The 32 palette colors */
unsigned char cPengoPal[32] = {0,0xF6,7,0x38,0xC9,0xF8,0x3F,0xEF,0x6F,0x16,0x2F,
0x7F,0xF0,0x36,0xDB,0xC6,0,0xF6,0xD8,0xF0,0xF8,0x16,7,0x2F,0x36,0x3F,0x7F,
0x28,0x32,0x38,0xEF,0xC6};
unsigned char cPengoCharPROM[512] = {
0x00,0x00,0x00,0x00,0x00,0x05,0x03,0x01,0x00,0x05,0x02,0x01,0x00,0x05,0x06,0x01,
0x00,0x05,0x07,0x01,0x00,0x05,0x0A,0x01,0x00,0x05,0x0B,0x01,0x00,0x05,0x0C,0x01,
0x00,0x05,0x0D,0x01,0x00,0x05,0x04,0x01,0x00,0x03,0x06,0x01,0x00,0x03,0x02,0x01,
0x00,0x03,0x07,0x01,0x00,0x03,0x05,0x01,0x00,0x02,0x03,0x01,0x00,0x00,0x00,0x00,
0x00,0x08,0x03,0x01,0x00,0x09,0x02,0x05,0x00,0x08,0x05,0x0D,0x04,0x04,0x04,0x04,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x00,0x03,0x03,0x03,
0x00,0x06,0x06,0x06,0x00,0x07,0x07,0x07,0x00,0x0A,0x0A,0x0A,0x00,0x0B,0x0B,0x0B,
0x00,0x01,0x01,0x01,0x00,0x05,0x05,0x05,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x0D,0x00,0x0C,0x0F,0x0B,0x00,0x0C,0x0E,0x0B,
0x00,0x0C,0x06,0x0B,0x00,0x0C,0x07,0x0B,0x00,0x0C,0x03,0x0B,0x00,0x0C,0x08,0x0B,
0x00,0x0C,0x0D,0x0B,0x00,0x0C,0x04,0x0B,0x00,0x0C,0x09,0x0B,0x00,0x0C,0x05,0x0B,
0x00,0x0C,0x02,0x0B,0x00,0x0C,0x0B,0x02,0x00,0x08,0x0C,0x02,0x00,0x08,0x0F,0x02,
0x00,0x03,0x02,0x01,0x00,0x02,0x0F,0x03,0x00,0x0F,0x0E,0x02,0x00,0x0E,0x07,0x0F,
0x00,0x07,0x06,0x0E,0x00,0x06,0x05,0x07,0x00,0x05,0x00,0x06,0x00,0x00,0x0B,0x05,
0x00,0x0B,0x0C,0x00,0x00,0x0C,0x0D,0x0B,0x00,0x0D,0x08,0x0C,0x00,0x08,0x09,0x0D,
0x00,0x09,0x0A,0x08,0x00,0x0A,0x01,0x09,0x00,0x01,0x04,0x0A,0x00,0x04,0x03,0x01,
0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x0D,0x00,0x0C,0x0F,0x0B,0x00,0x0C,0x0E,0x0B,
0x00,0x0C,0x06,0x0B,0x00,0x0C,0x07,0x0B,0x00,0x0C,0x03,0x0B,0x00,0x0C,0x08,0x0B,
0x00,0x0C,0x0D,0x0B,0x00,0x0C,0x04,0x0B,0x00,0x0C,0x09,0x0B,0x00,0x0C,0x05,0x0B,
0x00,0x0C,0x02,0x0B,0x00,0x0C,0x0B,0x02,0x00,0x08,0x0C,0x02,0x00,0x08,0x0F,0x02,
0x00,0x03,0x02,0x01,0x00,0x02,0x0F,0x03,0x00,0x0F,0x0E,0x02,0x00,0x0E,0x07,0x0F,
0x00,0x07,0x06,0x0E,0x00,0x06,0x05,0x07,0x00,0x05,0x00,0x06,0x00,0x00,0x0B,0x05,
0x00,0x0B,0x0C,0x00,0x00,0x0C,0x0D,0x0B,0x00,0x0D,0x08,0x0C,0x00,0x08,0x09,0x0D,
0x00,0x09,0x0A,0x08,0x00,0x0A,0x01,0x09,0x00,0x01,0x04,0x0A,0x00,0x04,0x03,0x01,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,
0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00};
/* The color prom (128 for chars & sprites */
unsigned char cPacCharPROM[] = {
	0x00,0x00,0x00,0x00,0x00,0x0F,0x0B,0x01,0x00,0x00,0x00,0x00,0x00,0x0F,0x0B,0x03,
	0x00,0x00,0x00,0x00,0x00,0x0F,0x0B,0x05,0x00,0x00,0x00,0x00,0x00,0x0F,0x0B,0x07,
	0x00,0x00,0x00,0x00,0x00,0x0B,0x01,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x0E,0x00,0x01,0x0C,0x0F,
	0x00,0x0E,0x00,0x0B,0x00,0x0C,0x0B,0x0E,0x00,0x0C,0x0F,0x01,0x00,0x00,0x00,0x00,
	0x00,0x01,0x02,0x0F,0x00,0x07,0x0C,0x02,0x00,0x09,0x06,0x0F,0x00,0x0D,0x0C,0x0F,
	0x00,0x05,0x03,0x09,0x00,0x0F,0x0B,0x00,0x00,0x0E,0x00,0x0B,0x00,0x0E,0x00,0x0B,
	0x00,0x00,0x00,0x00,0x00,0x0F,0x0E,0x01,0x00,0x0F,0x0B,0x0E,0x00,0x0E,0x00,0x0F};
unsigned char cDigDug2Pal[32] = {0x00,0x07,0x58,0x3f,0xf6,0xaf,0xe7,0xeb,0xd1,0x6e,0x1c,0x22,0x28,0x8c,0x2f,0x00,
                                 0x00,0xf6,0xeb,0x06,0x3f,0x39,0xa6,0xe7,0x43,0xaf,0x6e,0x1c,0x22,0x28,0xc0,0x00};
unsigned char cMappyPal[32] = {0x00,0xd9,0xa4,0x5d,0x36,0x80,0xa7,0x26,0x68,0x06,0x1d,0x66,0xa8,0xde,0xf6,0x00,
                               0x00,0x38,0x36,0x06,0x66,0x00,0x5d,0xf0,0xb7,0x26,0x00,0x00,0xe7,0xd9,0xf6,0x00};
/* The 32 palette colors */
static unsigned char cSPPal[32] = {0xf6,0xc9,0x3f,0x07,0xef,0xf8,0x2f,0xaf,0x3c,0x5d,0x38,0xe7,0x29,0x66,0x54,0x00,
                            0x00,0xd8,0x66,0x29,0xe7,0x38,0x5d,0xd5,0xaf,0x2f,0xb8,0xef,0x07,0x3f,0xf6,0x00};
extern int iCoinOpPitch;
extern unsigned char *pCoinOpBitmap;
extern int iROMSet;

/* Custom memory function prototypes */
void GaplusWriteMirror(int, unsigned char);
unsigned char mappy_customio_r_1(int usAddr);
unsigned char mappy_customio_r_2(int usAddr);
unsigned char digdug2_customio_r_1(int usAddr);
unsigned char digdug2_customio_r_2(int usAddr);
void PNPIRQ2Write(int usAddr, unsigned char ucByte);
void GaplusExpWrite(int, unsigned char);
void GaplusResetWrite(int, unsigned char);
void GaplusVideoWrite(int, unsigned char);
void GaplusStuffWrite(int, unsigned char);
void MetroSharedWrite(int, unsigned char);
void GaplusSharedWrite2(int, unsigned char);
void GaplusIRQ1Write(int, unsigned char);
void GaplusIRQ2Write(int, unsigned char);
void GaplusIRQ3Write(int, unsigned char);
void GaplusStarsWrite(int, unsigned char);
void SkyVideoWrite(int, unsigned char);
void PacLandVideoWrite(int, unsigned char);
void MetroVideoWrite(int, unsigned char);
void MetroVideoWrite2(int, unsigned char);
void PacLandSharedWrite(int, unsigned char);
void PacLandHDWrite(int, unsigned char);
void SkyHaltWrite(int, unsigned char);
void MetroHaltWrite(int, unsigned char);
void PacLandHaltWrite(int, unsigned char);
void SkyBankWrite(int, unsigned char);
void PacLandBankSwitchWrite(int, unsigned char);
void PacLandScroll0Write(int, unsigned char);
void PacLandScroll1Write(int, unsigned char);
void TestWrite(int, unsigned char);
void SkyScrollWrite(int, unsigned char);
void MetroScrollWrite(int, unsigned char);
void MetroScrollWrite2(int, unsigned char);
void SkyIOWrite(int, unsigned char);
void EMUCreatePalette(RGBQUAD *, int);
// Pac-Man
unsigned char PacIORead(int);
unsigned char PacReadRAM(int);
void PacIOWrite(int, unsigned char);
unsigned char PacIRQRead(int);
void PacIRQWrite(int, unsigned char);
void PacVideoWrite(int, unsigned char);
void JRPacVideoWrite(int, unsigned char);
void AltPacVideoWrite(int, unsigned char);
void PengoSoundWrite(int, unsigned char);
void PengoPortWrite(int, unsigned char);
unsigned char PengoPortRead(int);
void PengoVideoWrite(int, unsigned char);
#define GAME_PAC   0
#define GAME_MSPAC 1
#define GAME_CRUSH 2
#define GAME_JRPAC 3
#define GAME_VANVAN 4

// Super Pac-Man
void SPVideoWrite(int, unsigned char);
void SPColorWrite(int, unsigned char);
void SPSharedWrite(int, unsigned char);
void SPIRQWrite(int, unsigned char);
void SPSoundWrite(unsigned char *);
void SPWriteNULL(int, unsigned char);
void MappyVideoWrite(int, unsigned char);
void MappyColorWrite(int, unsigned char);
void MappyScrollWrite(int, unsigned char);
unsigned char SPReadRAM(int);
unsigned char SPReadNULL(int);
unsigned char SPSharedRead(int);
unsigned char SPIO1Read(int);
unsigned char SPIO2Read(int);
void SuperPacPostLoad(void);

unsigned char Galaga3IORead1(int);
unsigned char Galaga3IORead2(int);
unsigned char Galaga3IORead3(int);
unsigned char GaplusSharedRead2(int);
unsigned char GaplusReadMirror(int);
unsigned char MetroSharedRead(int);
unsigned char GaplusSharedRead(int);
unsigned char GaplusIORead3(int);
unsigned char GaplusReadROM1(int);
unsigned char gaplus_customio_r_1(int);
unsigned char gaplus_customio_r_2(int);
unsigned char PacLandIORead(int);
unsigned char PacLandSharedRead(int);
unsigned char SkyBankRead(int);
unsigned char SkyIORead(int);
unsigned char MetroIORead(int);
unsigned char PacLandHDRead(int);

GAMEOPTIONS VanVanOptions[] = {{"Lives",{"6","5","4","3",NULL},3},
                                {NULL,{NULL},0}};
GAMEOPTIONS JRPacOptions[] = {{"Credits", {"Free","1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit",NULL}, 1},
		{"Lives",{"1","2","3","5",NULL},2},
                                {"Bonus Life",{"10000", "15000","20000","30000",NULL},0},
                                {"Difficulty", {"Hard","Normal",NULL}, 1},
                                {NULL,{NULL},0}};

GAMEOPTIONS MsPacOptions[] = {{"Credits", {"Free","1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit",NULL}, 1},
		{"Lives",{"1","2","3","5",NULL},2},
                              {"Bonus Life",{"10000", "15000","20000","None",NULL},0},
                              {"Difficulty", {"Hard","Normal",NULL}, 1},
                              {"Rack Advance",{"Off","On",NULL},0},
                                {NULL,{NULL},0}};

GAMEOPTIONS CrushOptions[] = {{"Credits", {"Free","1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit",NULL}, 1},
		{"Lives",{"3","4","5","6",NULL},0},
                                {"First Pattern",{"Hard", "Easy",NULL},0},
                                {"Teleport Holes", {"On","Off",NULL}, 1},
                                {NULL,{NULL},0}};

GAMEOPTIONS PacOptions[] = {{"Credits", {"Free","1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit",NULL}, 1},
		{"Lives",{"1","2","3","5",NULL},2},
                                {"Bonus Life",{"10000", "15000","20000","None",NULL},0},
                                {"Difficulty", {"Hard","Normal",NULL}, 1},
                                {"Ghost Names",{"Alternate","Normal",NULL}, 1},
                                {NULL,{NULL},0}};

GAMEOPTIONS PengoOptions[] = {{"Bonus Life",{"30000", "50000",0,0,NULL},0},
		{"Demo Sounds", {"On","Off",NULL}, 1},
                               {"Credits", {"Free","1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit",NULL}, 1},
                               {"Lives",{"5","4","3","2",NULL},2},
                               {"Difficulty", {"Hardest","Hard","Medium","Easy",NULL}, 2},
                               {NULL,{NULL},0}};

GAMEOPTIONS DigDug2Options[] = {{"Lives",{"3","5",NULL},0},
								{"Credits",{"1 Coin/1 Credit","2 Coins/1 Credits","1 Coin/2 Credits","3 Coins/1 Credits",NULL},0},
                                {"Bonus",{"30K 80K","30K 100K","30K 120K","30K 150K",NULL},0},
                                {"Allow Level Select", {"Off","On",NULL}, 0},
                                {"Freeze",{"Off","On",NULL},0},
                                {NULL,{NULL},0}};
GAMEOPTIONS MappyOptions[] = {{"Difficulty",{"Easy","Medium","Hard","Hardest",NULL},0},
								{"Demo Sound", {"Off","On",NULL}, 0},
                                {"Rank Advance",{"Off","On",NULL},0},
                                {"Freeze",{"Off","On",NULL},0},
                                {"Credits",{"1 Coin/1 Credit","1 Coin/2 Credits","1 Coin/3 Credits","1 Coin/6 Credits","2 Coins/1 Credit","2 Coins/3 Credits","3 Coins/1 Credit","3 Coins/2 Credits",NULL},0},
                                {"Bonus Life",{"30K 80K","30K 100K", "30K 120K","30K","40K","30K 100K 100K","40K 120K 120K","None",NULL},0},
                                {"Lives",{"3","5","1","2",NULL},0},
                                {NULL,{NULL},0}};
GAMEOPTIONS SuperPacOptions[] = {{"Rank", {"0-Normal","1-Easy","2","3","4","5","6","7","8-Default","9","10","11-Hard","12-Easy Auto","13-Auto","14-Auto","15-Hard Auto"}, 0},
								{"Credits",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","2 Coins/3 Credits",NULL},0},
                                {"Demo Sound", {"On","Off",NULL}, 0},
                                {"Freeze",{"Off","On",NULL}, 0},
                                {"Bonus Life",{"30K 100K", "30K 80K","30K 120K","30K 80K 80K","30K 100K 100K","30K 120K 120K","30K","None",NULL},0},
                                {"Lives",{"3","1","2","5",NULL},0},
                                {"Service Mode",{"Off","On",NULL},0},
                                {NULL,{NULL},0}};

GAMEOPTIONS MetroOptions[] = {{"Coin 1",{"3 Coins/1 Credit","2 Coins/1 Credit","1 Coin/2 Credits","1 Coin/1 Credit",0,0,0,0},3},
		{"Coin 2",{"3 Coins/1 Credit","2 Coins/1 Credit","1 Coin/2 Credits","1 Coin/1 Credit",0,0,0,0},3},
                               {"Difficulty",{"Very Hard","Hard","Normal","Easy",NULL},2},
                               {"Round Skip",{"Skip","Walk",NULL},1},
                               {"Allow Continue",{"Retry","Continue",NULL},0},
                               {"Demo Sounds",{"Off","On",NULL},1},
                               {"Self Test Mode",{"On","Off",NULL},1},
                               {"Cabinet",{"Table","Upright",NULL},1},
                               {NULL, {NULL}, 0}};

GAMEOPTIONS SkyKidOptions[] = {{"Coinage - slot 2",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
		{"Flip Screen",{"On","Off",NULL},1},
                               {"Coinage - slot 1",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
                               {"Lives",{"5","2","1","3",NULL},3},
                               {"Bonus Kid",{"20K & every 80K","20K 80K","30K & every 90K","30K 90K",NULL},0},
                               {"Round Advance",{"Skip","Walk",NULL},0},
                               {"Attract Mode Sound",{"Off","On",NULL},1},
                               {"Self Test Mode",{"On","Off",NULL},1},
                               {NULL, {NULL}, 0}};

GAMEOPTIONS GaplusOptions[] = {{"Coinage - slot 2",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
		{"Unknown",{"OK","Strange",0,0,0,0,0,0},0},
		{"Coinage - slot 1",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
                               {"Lives",{"3","2","4","5",0,0,0,0},0},
                               {"Bonus Ship",{"50K 150K 150K","50K 150K","50K 150K 300K","50K 100K 200K","50K 100K 100K","30K 100K 200K","30K 100K 100K","30K 70K 70K"},7},
                               {"Round Advance",{"Normal","Advance",NULL},0},
                               {"Difficulty",{"0=Easy","1","2","3","4","5","6","7=Hard"},0},
                               {"Self Test Mode",{"Off","On",NULL},0},
                                 {NULL, {NULL}, 0}};
GAMEOPTIONS PacLandOptions[] = {{"Coinage - slot 2",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
		{"Demo Sounds",{"On","Off",NULL},0},
                               {"Coinage - slot 1",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
                               {"Lives",{"3","2","4","5",0,0,0,0},0},
                               {"Self Test Mode",{"Off","On",NULL},0},
                               {"Start Level Select",{"On","Off",NULL},0},
                               {"Round Select",{"Off","On",NULL},0},
                               {"Difficulty",{"Medium","Easy","Hard","Hardest",NULL},1},
                               {"Bonus Life",{"30K,80K,130K,300K,500K,1M","30K,100K,200K,400K,600K,1M","40K,100K,180K,300K,500K,1M","30K,80K,Every 100K","50K,150K,Every 200K","30K,80K,150K","40K,100K,200K","40K"},0},
                                {NULL, {NULL}, 0}};
GAMEOPTIONS Galaga3Options[] = {{"Coinage - slot 2",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
		{"Unknown",{"OK","Strange",0,0,0,0,0,0},0},
                               {"Coinage - slot 1",{"1 Coin/1 Credit","1 Coin/2 Credits","2 Coins/1 Credit","3 Coins/1 Credit",0,0,0,0},0},
                               {"Lives",{"3","2","4","5",0,0,0,0},0},
                               {"Bonus Ship",{"30K 100K 200K","30K 150K","30K 100K 300K","30K 100K 150K","30K 100K 100K","30K 80K 100K","50K 150K 200K","50K 150K 150K"},5},
                               {"Round Advance",{"Normal","Advance",NULL},0},
                               {"Difficulty",{"0=Easy","1","2","3","4","5","6","7=Hard"},0},
                               {"Self Test Mode",{"On","Off",NULL},1},
                               {"Unknown 1",{"0","1","2","3",NULL},0},
                               {"Unknown 2",{"0","1","2","3","4","5","6","7"},0},
                               {"Unknown 3",{"0","1","2","3","4","5","6","7"},0},
                               {"Unknown 4",{"0","1",NULL},0},
                                 {NULL, {NULL}, 0}};

/* Needs to be global for faster access by all routines */
extern int iFrame;
extern unsigned char *pCoinOpBitmap; /* Pointer to bitmap memory */
extern int iCoinOpPitch;
/* PacLand character bit mapping */
static unsigned char cPacXOff[8] = {8*8+3, 8*8+2, 8*8+1, 8*8, 3, 2, 1, 0};
static unsigned char cPacYOff[8] = {0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8};
/* PacLand sprite bit mapping */
static unsigned int iPacXOff2[16] = {3,2,1,0,8*8+3,8*8+2,8*8+1,8*8+0,16*8+3,16*8+2,16*8+1,16*8+0,24*8+3,24*8+2,24*8+1,24*8+0};
static unsigned int iPacYOff2[16] = {0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8, 32*8, 33*8, 34*8, 35*8, 36*8, 37*8, 38*8, 39*8 };

GFXDECODE mappygfx1 = {4, 64, 16, 16, // bitcount, delta, width, height, count
                    {8192*8,8192*8+4,0,4}, // plane offsets
{ 39*8, 38*8, 37*8, 36*8, 35*8, 34*8, 33*8, 32*8, 7*8, 6*8, 5*8, 4*8, 3*8, 2*8, 1*8, 0*8 },
{ 3, 2, 1, 0, 8*8+3, 8*8+2, 8*8+1, 8*8+0, 16*8+3, 16*8+2, 16*8+1, 16*8+0, 24*8+3, 24*8+2, 24*8+1, 24*8+0 }};
GFXDECODE digdug2gfx1 = {4, 64, 16, 16, // bitcount, delta, width, height, count
                    {16384*8,16384*8+4,0,4}, // plane offsets
{ 39*8, 38*8, 37*8, 36*8, 35*8, 34*8, 33*8, 32*8, 7*8, 6*8, 5*8, 4*8, 3*8, 2*8, 1*8, 0*8 },
{ 3, 2, 1, 0, 8*8+3, 8*8+2, 8*8+1, 8*8+0, 16*8+3, 16*8+2, 16*8+1, 16*8+0, 24*8+3, 24*8+2, 24*8+1, 24*8+0 }};
/* PacMan Characters */
GFXDECODE pacgfx0 = {2, 16, 8, 8, // bitcount, delta, width, height
                    {0,4}, // plane offsets
    { 7*8, 6*8, 5*8, 4*8, 3*8, 2*8, 1*8, 0*8 },
    { 8*8+3, 8*8+2, 8*8+1, 8*8+0, 3, 2, 1, 0 }}; /* bits are packed in groups of four */
/* PacMan Sprites */
GFXDECODE pacgfx1 = {2, 64, 16, 16, // bitcount, delta, width, height, count
                    {0,4}, // plane offsets
	{39*8, 38*8, 37*8, 36*8, 35*8, 34*8, 33*8, 32*8,7*8, 6*8, 5*8, 4*8, 3*8, 2*8, 1*8, 0*8 },
	{ 8*8+3, 8*8+2, 8*8+1, 8*8+0, 16*8+3, 16*8+2, 16*8+1, 16*8+0,24*8+3, 24*8+2, 24*8+1, 24*8+0, 3, 2, 1, 0}};
/* DigDug Sprites */
extern GFXDECODE diggfx1;

/* Gaplus chars 1 & 2 */
static GFXDECODE gaplusgfx0 = {2, 32, 8, 8, // bitcount, delta, width, height
                    {0,2}, // plane offsets
    { 7*8, 6*8, 5*8, 4*8, 3*8, 2*8, 1*8, 0*8 },
    { 16*8+1, 16*8+0, 24*8+1, 24*8+0, 1, 0, 8*8+1, 8*8+0}};
static GFXDECODE gaplusgfx1 = {2, 32, 8, 8, // bitcount, delta, width, height
                    {4,6}, // plane offsets
    { 7*8, 6*8, 5*8, 4*8, 3*8, 2*8, 1*8, 0*8 },
    { 16*8+1, 16*8+0, 24*8+1, 24*8+0, 1, 0, 8*8+1, 8*8+0}};
/* Gaplus sprites */
static GFXDECODE gaplusgfx2 = {3, 64, 16, 16, // bitcount, delta, width, height
                    {8192*8+0,8192*8+4,4}, // plane offsets
    { 39*8, 38*8, 37*8, 36*8, 35*8, 34*8, 33*8, 32*8,7*8,6*8,5*8,4*8,3*8,2*8,1*8,0*8},
    { 3, 2, 1, 0, 8*8+3, 8*8+2, 8*8+1, 8*8+0,16*8+3, 16*8+2, 16*8+1, 16*8+0, 24*8+3, 24*8+2, 24*8+1, 24*8+0}};
static GFXDECODE gaplusgfx3 = {3, 64, 16, 16, // bitcount, delta, width, height
                    {8192*8*2+0,8192*8*2+4,0}, // plane offsets
    { 39*8, 38*8, 37*8, 36*8, 35*8, 34*8, 33*8, 32*8,7*8,6*8,5*8,4*8,3*8,2*8,1*8,0*8},
    { 3, 2, 1, 0, 8*8+3, 8*8+2, 8*8+1, 8*8+0,16*8+3, 16*8+2, 16*8+1, 16*8+0, 24*8+3, 24*8+2, 24*8+1, 24*8+0}};
static GFXDECODE gaplusgfx4 = {3, 64, 16, 16, // bitcount, delta, width, height
                    {0,4,8192*8+4}, // plane offsets
    { 39*8, 38*8, 37*8, 36*8, 35*8, 34*8, 33*8, 32*8,7*8,6*8,5*8,4*8,3*8,2*8,1*8,0*8},
    { 3, 2, 1, 0, 8*8+3, 8*8+2, 8*8+1, 8*8+0,16*8+3, 16*8+2, 16*8+1, 16*8+0, 24*8+3, 24*8+2, 24*8+1, 24*8+0}};


/* skykid tiles 1 */
static GFXDECODE skgfx1 = {2, 16, 8, 8, // bitcount, delta, width, height
                    {0,4}, // plane offsets
    { 3, 2, 1, 0, 8+3, 8+2, 8+1, 8+0 },
    { 0*8, 2*8, 4*8, 6*8, 8*8, 10*8, 12*8, 14*8 }};

/* Dragon Buster Sprites 1 */
static GFXDECODE dbgfx1 = {4, 64, 16, 16, // bitcount, delta, width, height, count
                    {0x4000*8,0x4000*8+4,0,4}, // plane offsets
	{3,2,1,0,8*8+3,8*8+2,8*8+1,8*8,16*8+3,16*8+2,16*8+1,16*8,24*8+3,24*8+2,24*8+1,24*8},
	{0,8*1, 8*2, 8*3, 8*4,8*5,8*6,8*7,32*8,33*8,34*8,35*8,36*8,37*8,38*8,39*8}};

/* Dragon Buster Sprites 2 */
static GFXDECODE dbgfx2 = {4, 64, 16, 16, // bitcount, delta, width, height, count
                    {0x6000*8,0x6000*8+4,0x2000*8,0x2000*8+4,0x6000*8,0x6000*8+4}, // plane offsets
	{3,2,1,0,8*8+3,8*8+2,8*8+1,8*8,16*8+3,16*8+2,16*8+1,16*8,24*8+3,24*8+2,24*8+1,24*8},
	{0,8*1, 8*2, 8*3, 8*4,8*5,8*6,8*7,32*8,33*8,34*8,35*8,36*8,37*8,38*8,39*8}};

/* Skykid Sprites 1 */
static GFXDECODE skgfx2 = {3, 64, 16, 16, // bitcount, delta, width, height, count
                    {0,4,0x4000*8}, // plane offsets
	{3,2,1,0,8*8+3,8*8+2,8*8+1,8*8,16*8+3,16*8+2,16*8+1,16*8,24*8+3,24*8+2,24*8+1,24*8},
	{0,8*1, 8*2, 8*3, 8*4,8*5,8*6,8*7,32*8,33*8,34*8,35*8,36*8,37*8,38*8,39*8}};

/* Skykid Sprites 2 */
static GFXDECODE skgfx3 = {3, 64, 16, 16, // bitcount, delta, width, height, count
                    {0x2000*8,0x2000*8+4,0x4000*8+4}, // plane offsets
	{3,2,1,0,8*8+3,8*8+2,8*8+1,8*8,16*8+3,16*8+2,16*8+1,16*8,24*8+3,24*8+2,24*8+1,24*8},
	{0,8*1, 8*2, 8*3, 8*4,8*5,8*6,8*7,32*8,33*8,34*8,35*8,36*8,37*8,38*8,39*8}};

/* Skykid Sprites 3 */
static GFXDECODE skgfx4 = {2, 64, 16, 16, // bitcount, delta, width, height, count
                    {0x2000*8,0x2000*8+4}, // plane offsets
	{3,2,1,0,8*8+3,8*8+2,8*8+1,8*8,16*8+3,16*8+2,16*8+1,16*8,24*8+3,24*8+2,24*8+1,24*8},
	{0,8*1, 8*2, 8*3, 8*4,8*5,8*6,8*7,32*8,33*8,34*8,35*8,36*8,37*8,38*8,39*8}};

/* Baraduke Characters */
static GFXDECODE bdgfx0 = {2, 16, 8, 8, // bitcount, delta, width, height
                    {0,4}, // plane offsets
    { 8*8+3, 8*8+2, 8*8+1, 8*8+0, 3, 2, 1, 0 },
    { 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8 }};
/* Baraduke background tiles 1 */
static GFXDECODE bdgfx1 = {3, 16, 8, 8, // bitcount, delta, width, height
                    {0,4,0x8000*8}, // plane offsets
    { 3, 2, 1, 0, 8+3, 8+2, 8+1, 8+0 },
    { 0*8, 2*8, 4*8, 6*8, 8*8, 10*8, 12*8, 14*8 }};
/* Baraduke background tiles 2 */
static GFXDECODE bdgfx2 = {3, 16, 8, 8, // bitcount, delta, width, height
                    {0x2000*8,0x2000*8+4,0x8000*8+4}, // plane offsets
    { 3, 2, 1, 0, 8+3, 8+2, 8+1, 8+0 },
    { 0*8, 2*8, 4*8, 6*8, 8*8, 10*8, 12*8, 14*8 }};
/* Baraduke background tiles 3 */
static GFXDECODE bdgfx3 = {3, 16, 8, 8, // bitcount, delta, width, height
                    {0x4000*8,0x4000*8+4,0xa000*8}, // plane offsets
    { 3, 2, 1, 0, 8+3, 8+2, 8+1, 8+0 },
    { 0*8, 2*8, 4*8, 6*8, 8*8, 10*8, 12*8, 14*8 }};
/* Baraduke background tiles */
static GFXDECODE bdgfx4 = {3, 16, 8, 8, // bitcount, delta, width, height
                    {0x6000*8,0x6000*8+4,0xa000*8+4}, // plane offsets
    { 3, 2, 1, 0, 8+3, 8+2, 8+1, 8+0 },
    { 0*8, 2*8, 4*8, 6*8, 8*8, 10*8, 12*8, 14*8 }};

/* Baraduke Sprites */
static GFXDECODE bdgfx5 = {4, 128, 16, 16, // bitcount, delta, width, height, count
                    {0,1,2,3}, // plane offsets
	{4,0,12,8,20,16,28,24,36,32,44,40,52,48,60,56},
	{0,8*8, 8*8*2, 8*8*3, 8*8*4,8*8*5,8*8*6,8*8*7,8*8*8,8*8*9,8*8*10,8*8*11,8*8*12,8*8*13,8*8*14,8*8*15}};


#define SCREENX 224
#define SCREENY 288

MEMHANDLERS mhPengo[] = {{0, 1, PacIORead, PacIOWrite}, /* Must be the first entry */
		                 {0x8000, 0x800, NULL, PengoVideoWrite},
                         {0x9000, 0x100, PengoPortRead, PengoPortWrite},
                         {0,0,NULL,NULL}};
MEMHANDLERS mhPac[] = {{0, 1, PacIORead, PacIOWrite}, /* Must be the first entry */
                                {0x4000, 0x800, NULL, PacVideoWrite},
                                {0x5000, 0x50, PacIRQRead, PacIRQWrite},
                                {0x5080, 0x3f, PacIRQRead, PacIRQWrite},
                                {0xc000, 0x800, NULL, AltPacVideoWrite},
                                {0,0,NULL,NULL}};
MEMHANDLERS mhMappy1[] = {{0x0, 0x800, NULL, MappyVideoWrite},
                                {0x800, 0x800, NULL, MappyColorWrite},
                                {0x2800,0x1000,SPReadNULL, SPWriteNULL},
                                {0x4400,0x400,SPReadNULL, SPWriteNULL},
                                {0x3800,0x800, NULL, MappyScrollWrite},
//                                {0x4040, 0x3c0, SPSharedRead, SPSharedWrite},
                                {0x4800,0x10,mappy_customio_r_1, NULL},
                                {0x4810,0x10,mappy_customio_r_2, NULL},
                                {0x5000, 0x10, NULL, SPIRQWrite},
                                {0x5010,0x4ff0,SPReadNULL, SPWriteNULL},
                                {0,0,NULL,NULL}};
MEMHANDLERS mhMappy2[] = {{0x2000, 2, SPReadNULL, PNPIRQ2Write},
                          {0x40, 0x3c0, SPSharedRead, SPSharedWrite},
                          {0,0,NULL,NULL}};
MEMHANDLERS mhDigDug2_1[] = {{0x0, 0x800, NULL, MappyVideoWrite},
                                {0x800, 0x800, NULL, MappyColorWrite},
                                {0x2800,0x1000,SPReadNULL, SPWriteNULL},
                                {0x4400,0x400,SPReadNULL, SPWriteNULL},
                                {0x3800,0x800, NULL, MappyScrollWrite},
//                                {0x4040, 0x3c0, SPSharedRead, SPSharedWrite},
                                {0x4800,0x10,digdug2_customio_r_1, NULL},
                                {0x4810,0x10,digdug2_customio_r_2, NULL},
                                {0x5000, 0x10, NULL, SPIRQWrite},
                                {0x5010,0x2ff0,SPReadNULL, SPWriteNULL},
                                {0,0,NULL,NULL}};
MEMHANDLERS mhSuperPac1[] = {{0x0, 0x400, NULL, SPVideoWrite},
                                {0x400, 0x400, NULL, SPColorWrite},
//                                {0x4040, 0x3c0, SPSharedRead, SPSharedWrite},
                                {0x4800, 0x10, SPIO1Read, NULL},
                                {0x4810, 0x10, SPIO2Read, NULL},
                                {0x5000, 0x10, NULL, SPIRQWrite},
                                {0x4820, 0x7e0, SPReadNULL, SPWriteNULL},
                                {0,0,NULL,NULL}};

MEMHANDLERS mhSuperPac2[] = {{0x40, 0x3c0, SPSharedRead, SPSharedWrite},
                             {0,0,NULL,NULL}};

MEMHANDLERS mhSkyKid1[] = {
//                                {0x0000, 0x2000, SkyBankRead, NULL},
                                {0x2000, 0x1000, NULL, SkyVideoWrite},
                                {0x6200, 0x200, NULL, SkyScrollWrite},
                                {0x8000, 0x801, NULL, SkyHaltWrite},
                                {0x9000, 0x801, NULL, SkyBankWrite},
                                {0,0,NULL,NULL}};

MEMHANDLERS mhSkyKid2[] = {{0x0002, 0x1, SkyIORead, SkyIOWrite},
                           {0x1000, 0x100, PacLandSharedRead, PacLandSharedWrite},
                           {0x1140, 0x2c0, PacLandSharedRead, PacLandSharedWrite},
                           {0,0,NULL,NULL}};

MEMHANDLERS mhMetroCross1[] = {
                                {0x2000, 0x2000, NULL, MetroVideoWrite},
                                {0x4800, 0x400, NULL, MetroVideoWrite2},
                                {0xb000, 0x3, NULL, MetroScrollWrite},
                                {0xb004, 0x3, NULL, MetroScrollWrite2},
                                {0,0,NULL,NULL}};
//                                0x5000, 0x1000, EMUReadNULL, EMUWriteNULL,
//                                0x8000, 0x801, NULL, MetroHaltWrite,
//                                0x9000, 0x801, NULL, SkyBankWrite};

MEMHANDLERS mhMetroCross2[] = {{0x0002, 0x1, MetroIORead, SkyIOWrite},
                              {0x1000, 0x100, MetroSharedRead, MetroSharedWrite},
                              {0x1140, 0x2c0, MetroSharedRead, MetroSharedWrite},
                              {0,0,NULL,NULL}};

MEMHANDLERS mhBaraduke1[] = {
                                {0x2000, 0x2000, NULL, MetroVideoWrite},
                                {0xb000, 0x3, NULL, MetroScrollWrite},
                                {0xb004, 0x3, NULL, MetroScrollWrite2},
                                {0,0,NULL,NULL}};
//                                0x5000, 0x1000, EMUReadNULL, EMUWriteNULL,
//                                0x8000, 0x801, NULL, MetroHaltWrite,
//                                0x9000, 0x801, NULL, SkyBankWrite};

MEMHANDLERS mhBaraduke2[] = {{0x0002, 0x1, SkyIORead, SkyIOWrite},
                             {0x1000, 0x100, MetroSharedRead, MetroSharedWrite},
                             {0x1140, 0x2c0, MetroSharedRead, MetroSharedWrite},
                             {0,0,NULL,NULL}};

MEMHANDLERS mhPacLand1[] = {{0x0000, 0x2000, NULL, PacLandVideoWrite},
                                {0x3800, 2, NULL, PacLandScroll0Write},
                                {0x3A00, 2, NULL, PacLandScroll1Write},
                                {0x3c00, 1, NULL, PacLandBankSwitchWrite},
//                                0x7800, 1, EMUReadNULL, EMUWriteNULL,
//                                0x7000, 1, NULL, EMUWriteNULL,
//                                0x9800, 1, NULL, EMUWriteNULL,
                                {0x8000, 0x800, NULL, PacLandHaltWrite},
                                {0,0,NULL,NULL}};
MEMHANDLERS mhPacLand2[] = {{0x0002, 1, PacLandHDRead, NULL},
                           {0x1000, 0x400, PacLandSharedRead, PacLandSharedWrite},
                           {0x2000, 1, NULL, EMUWriteNULL},
                           {0x4000, 1, NULL, EMUWriteNULL},
                           {0x6000, 1, NULL, EMUWriteNULL},
//                                          0x1264, 1, NULL, TestWrite,
                           {0xd000, 4, PacLandIORead, NULL},
                           {0,0,NULL,NULL}};
MEMHANDLERS mhGaplus1[] = {{0x0000, 0x800, NULL, GaplusVideoWrite},
                                {0x6800, 0x10, gaplus_customio_r_1, NULL},
                                {0x6810, 0x10, gaplus_customio_r_2, NULL},
                                {0x6820, 0x10, GaplusIORead3, GaplusExpWrite},
                                {0x8c00, 0x01, NULL, GaplusResetWrite},
                                {0xa003, 1, GaplusReadROM1, GaplusStarsWrite},
                                {0,0,NULL,NULL}};
MEMHANDLERS mhGalaga3_1[] = {{0x0000, 0x800, NULL, GaplusVideoWrite},
                                {0x6800, 0x10, Galaga3IORead1, NULL},
                                {0x6810, 0x10, Galaga3IORead2, NULL},
                                {0x6820, 0x10, Galaga3IORead3, GaplusExpWrite},
                                {0x8c00, 0x01, NULL, GaplusResetWrite},
                                {0xa003, 1, GaplusReadROM1, GaplusStarsWrite},
                                {0,0,NULL,NULL}};
MEMHANDLERS mhGaplus2[] = {
                                {0x0000, 0x800, GaplusSharedRead, GaplusVideoWrite},
                                {0x0800, 0x1800, GaplusSharedRead, GaplusStuffWrite},
                                {0x6800, 0x10, gaplus_customio_r_1, GaplusStuffWrite},
                                {0x6810, 0x10, gaplus_customio_r_2, GaplusStuffWrite},
                                {0x6820, 0x10, GaplusIORead3, GaplusStuffWrite},
                                {0x6080,2, NULL, GaplusIRQ2Write},
                                {0,0,NULL,NULL}};
MEMHANDLERS mhGaplus3[] = {
                                {0x0040, 0x3c0, GaplusSharedRead2, GaplusSharedWrite2},
                                {0,0,NULL,NULL}};
/* Main CPU ROMS for Pengo */
LOADROM PENGOROMS1[] = {{"pengo.u8", 0x0000, 0x1000, 0, NULL, NULL},
		              {"pengo.u7", 0x1000, 0x1000, 0, NULL, NULL},
                      {"pengo.u15", 0x2000, 0x1000, 0, NULL, NULL},
                      {"pengo.u14", 0x3000, 0x1000, 0, NULL, NULL},
                      {"pengo.u21", 0x4000, 0x1000, 0, NULL, NULL},
                      {"pengo.u20", 0x5000, 0x1000, 0, NULL, NULL},
                      {"pengo.u32", 0x6000, 0x1000, 0, NULL, NULL},
                      {"pengo.u31", 0x7000, 0x1000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
/* Character ROMS for Pengo */
LOADROM PENGOROMS2[] = {{"ic92", 0x0000, 0x2000, 0, NULL, NULL},
		               {"ic105", 0x2000, 0x2000, 0, NULL, NULL},
                       {"pr1635.051",0x4000, 0x100, 0, NULL, NULL}, /* Sound PROM */
                       {NULL,0,0,0,NULL,NULL}};
/* Main CPU ROMS for Ms. Pac-Man */
LOADROM MSPACROMS1[] = {{"boot1", 0x0000, 0x1000, 0, NULL, NULL},
		                {"boot2", 0x1000, 0x1000, 0, NULL, NULL},
                        {"boot3", 0x2000, 0x1000, 0, NULL, NULL},
                        {"boot4", 0x3000, 0x1000, 0, NULL, NULL},
                        {"boot5", 0x8000, 0x1000, 0, NULL, NULL},
                        {"boot6", 0x9000, 0x1000, 0, NULL, NULL},
                        {NULL, 0, 0, 0, NULL, NULL}};
/* Character ROMS for Ms. Pac-Man */
LOADROM MSPACROMS2[] = {{"5e", 0x0000, 0x1000, 0, NULL, NULL},
		                {"5f", 0x1000, 0x1000, 0, NULL, NULL},
                        {"pacman.spr", 0x2000, 0x100, 0, NULL, NULL}, /* Sound PROM */
                        {NULL,0,0,0,NULL,NULL}};

LOADROM PACROMS1[] = {{"namcopac.rom", 0x0000, 0x4000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
/* Character ROMS for Pac-Man */
LOADROM PACROMS2[] = {{"pacman.5e", 0x0000, 0x1000, 0, NULL, NULL},
		              {"pacman.5f", 0x1000, 0x1000, 0, NULL, NULL},
                      {"pacman.spr", 0x2000, 0x100, 0, NULL, NULL}, /* Sound PROM */
                      {NULL,0,0,0,NULL,NULL}};
/* Main CPU ROMS */
LOADROM MAPPYROMS1[] = {{"mappy1d.64", 0xa000, 0x2000, 0, NULL, NULL},
		{"mappy1c.64", 0xc000, 0x2000, 0, NULL, NULL},
				{"mappy1b.64", 0xe000, 0x2000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
/* Sound CPU ROM */
LOADROM MAPPYROMS2[] = {{"mappy1k.64", 0xe000, 0x2000, 0, NULL,NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};

/* Character ROMS */
LOADROM MAPPYROMS3[] = {{"mappy3b.32", 0x0000, 0x1000, 0, NULL, NULL},
							{"mappy3m.64", 0x1000, 0x2000, 0, NULL, NULL},
                           {"mappy3n.64", 0x3000, 0x2000, 0, NULL, NULL},
                           {"mappy.spr", 0x5000, 0x100, 0, NULL, NULL}, /* Sound PROM */
                           {"mappy.pr2", 0x5100, 0x100, 0, NULL, NULL}, /* char color PROM */
                           {"mappy.pr3", 0x5200, 0x100, 0, NULL, NULL}, /* sprite color PROM */
                           {NULL,0,0,0,NULL,NULL}};
/* Main CPU ROMS */
LOADROM DIGDUG2ROMS1[] = {{"ddug2-3.bin", 0x8000, 0x4000, 0, NULL, NULL},
		{"ddug2-1.bin", 0xc000, 0x4000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
/* Sound CPU ROM */
LOADROM DIGDUG2ROMS2[] = {{"ddug2-4.bin", 0xe000, 0x2000, 0, NULL,NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};

/* Character ROMS */
LOADROM DIGDUG2ROMS3[] = {{"ddug2-3b.bin", 0x0000, 0x1000, 0, NULL, NULL},
						{"ddug2-3m.bin", 0x1000, 0x4000, 0, NULL, NULL},
                           {"ddug2-3n.bin", 0x5000, 0x4000, 0, NULL, NULL},
                           {"ddsnd.bin", 0x9000, 0x100, 0, NULL, NULL}, /* Sound PROM */
                           {"ddclr-4c.bin", 0x9100, 0x100, 0, NULL, NULL}, /* char colors */
                           {"ddclr-5k.bin", 0x9200, 0x100, 0, NULL, NULL}, /* sprite colors */
                           {NULL,0,0,0,NULL,NULL}};
LOADROM PACLANDROMS1[] = {{"pl1-1", 0x8000, 0x4000, 0, NULL, NULL},
		{"pl1-2", 0xC000, 0x4000, 0, NULL, NULL},
                      {NULL, 0,0,0,NULL,NULL}};
LOADROM PACLANDROMS2[] = {{"pl1-7", 0x8000, 0x2000, 0, NULL, NULL},
		{"pl1-mcu.bin", 0xf000, 0x1000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
     /* Banked at 0x4000-0x5fff */
LOADROM PACLANDROMSB[] = {{"pl1-3", 0x0000, 0x4000, 0, NULL, NULL},
		{"pl1-4", 0x4000, 0x4000, 0, NULL, NULL},
		{"pl1-5", 0x8000, 0x4000, 0, NULL, NULL},
                      {"pl1-6", 0xC000, 0x4000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM PACLANDROMSG[] = {{"pl1-12", 0x0000, 0x2000, 0, NULL, NULL}, /* Chars */
		{"pl1-13",  0x2000, 0x2000, 0, NULL, NULL},
                        {"pl1-9", 0x4000, 0x4000,0,NULL,NULL}, /* Sprites */
                        {"pl1-10", 0x8000, 0x4000,0,NULL,NULL},
                        {"pl1-8", 0xC000, 0x4000,0,NULL,NULL},
                        {"pl1-11", 0x10000,0x4000,0,NULL,NULL},
                        {"pl1-2.bin", 0x14000,0x400,0,NULL,NULL}, /* Red & Green palette ROM */
                        {"pl1-1.bin", 0x14400,0x400,0,NULL,NULL}, /* Blue palette ROM */
                        {"pl1-3.bin", 0x14800,0x800,0,NULL,NULL}, /* Sprite colors */
                        {"pl1-5.bin", 0x15800,0x400,0,NULL,NULL}, /* Foreground */
                        {"pl1-4.bin", 0x15c00,0x400,0,NULL,NULL}, /* Background */
                        {"pl-snd",    0x16000,0x200,0,NULL,NULL}, /* Sound */
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM METROCRSROMS1[] = {{"mc2-3.9b", 0x6000, 0x2000, 0, NULL, NULL},
		{"mc2-1.9a", 0x8000, 0x4000, 0, NULL, NULL},
                         {"mc2-2.9a", 0xC000, 0x4000, 0, NULL, NULL},
                      {NULL, 0,0,0,NULL,NULL}};
LOADROM METROCRSROMS2[] = {{"mc1-4.3b", 0x8000, 0x2000, 0, NULL, NULL},
		{"sk1-mcu.bin", 0xf000, 0x1000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM METROCRSROMSG[] = {{"mc1-5.3j", 0x0000, 0x2000, 0, NULL, NULL}, /* Chars */
		{"mc1-7.4p",  0x2000, 0x4000, 0, NULL, NULL}, /* tiles */
                        {"mc2-6.4n",  0x6000, 0x4000, 0, NULL, NULL},
/* Empty space to decode ROMs as 3bpp */
                        {"mc1-8.8k", 0xE000, 0x4000,0,NULL,NULL}, /* Sprites */
                        {"mc1-9.8l", 0x12000, 0x4000,0,NULL,NULL}, /* Sprites */
                        {"7138e.1n", 0x16000,0x800,0,NULL,NULL}, /* Red & green palette ROM */
                        {"7128e.2m", 0x16800,0x800,0,NULL,NULL}, /* Blue palette ROM */
                        {"skysnd.bin",0x17000,0x200,0,NULL,NULL}, /* Sound */
                      {NULL, 0, 0, 0, NULL, NULL}};

LOADROM BARADUKEROMS1[] = {{"prg1.9c", 0x6000, 0x2000, 0, NULL, NULL},
		{"prg2.9a", 0x8000, 0x4000, 0, NULL, NULL},
				{"prg3.9b", 0xC000, 0x4000, 0, NULL, NULL},
                      {NULL, 0,0,0,NULL,NULL}};
LOADROM BARADUKEROMS2[] = {{"prg4.3b", 0x8000, 0x4000, 0, NULL, NULL},
		{"pl1-mcu.bin", 0xf000, 0x1000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM BARADUKEROMSG[] = {{"ch1.3j", 0x0000, 0x2000, 0, NULL, NULL}, /* Chars */
		{"ch2.4p",  0x2000, 0x4000, 0, NULL, NULL},
                        {"ch3.4n",  0x6000, 0x4000, 0, NULL, NULL},
                        {"ch4.4m",  0xA000, 0x4000, 0, NULL, NULL},
                        {"obj1.8k", 0xE000, 0x4000,0,NULL,NULL}, /* Sprites */
                        {"obj2.8l", 0x12000, 0x4000,0,NULL,NULL},
                        {"obj3.8m", 0x16000, 0x4000,0,NULL,NULL},
                        {"obj4.8n", 0x1A000, 0x4000,0,NULL,NULL},
                        {"prmcolbg.1n", 0x1E000,0x800,0,NULL,NULL}, /* Blue + Green palette ROM */
                        {"prmcolr.2m", 0x1E800,0x800,0,NULL,NULL}, /* Red palette ROM */
                        {"skysnd.bin",0x1F000,0x200,0,NULL,NULL}, /* Sound */
                      {NULL, 0, 0, 0, NULL, NULL}};

/* Main CPU ROMS */
LOADROM SUPERPACROMS1[] = {{"sp1.2", 0xc000, 0x2000, 0, NULL, NULL},
						{ "sp1.1", 0xe000, 0x2000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
/* Sound CPU ROM */
LOADROM SUPERPACROMS2[] = {{"spc-3.1k", 0xf000, 0x1000, 0, NULL,NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};

/* Character ROMS */
LOADROM SUPERPACROMS3[] = {{"sp1.6", 0x0000, 0x1000, 0, NULL, NULL},
							{"spv-2.3f", 0x1000, 0x2000, 0, NULL, NULL},
							{"superpac.3m", 0x3000, 0x100, 0, NULL, NULL}, /* Sound PROM */
							{"superpac.3l", 0x3100, 0x100, 0, NULL, NULL}, /* Sprite color PROM */
							{"superpac.4e", 0x3200, 0x100, 0, NULL, NULL}, /* Sprite color PROM */
                           {NULL,0,0,0,NULL,NULL}};
LOADROM SKYKIDROMS1[] = {{"sk2-6c.bin", 0x8000, 0x4000, 0, NULL, NULL},
						{"sk1-6b.bin", 0xC000, 0x4000, 0, NULL, NULL},
                      {NULL, 0,0,0,NULL,NULL}};
     /* Banked at 0x4000-0x5fff */
LOADROM SKYKIDROMSB[] = {{"sk3-6d.bin", 0x0000, 0x4000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM SKYKIDROMS2[] = {{"sk4-3c.bin", 0x8000, 0x2000, 0, NULL, NULL},
		{"sk1-mcu.bin", 0xf000, 0x1000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM SKYKIDROMSG[] = {{"sk6-6l.bin", 0x0000, 0x2000, 0, NULL, NULL}, /* Chars */
		{"sk5-7e.bin",  0x2000, 0x2000, 0, NULL, NULL},
                        {"sk9-10n.bin", 0x4000, 0x4000,0,NULL,NULL},
                        {"sk7-10m.bin", 0x8000, 0x4000,0,NULL,NULL}, /* Sprites */
                        {"sk1-2n.bin", 0xc000,0x100,0,NULL,NULL}, /* Red palette ROM */
                        {"sk2-2p.bin", 0xc100,0x100,0,NULL,NULL}, /* Green palette ROM */
                        {"sk3-2r.bin", 0xc200,0x100,0,NULL,NULL}, /* Blue palette ROM */
                        {"sk-6n.bin", 0xc300,0x200,0,NULL,NULL}, /* Sprite colors */
                        {"sk-5n.bin", 0xc500,0x200,0,NULL,NULL}, /* Background */
                        {"skysnd.bin",    0xc700,0x200,0,NULL,NULL}, /* Sound */
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM DRAGBUSTROMS1[] = {{"db1-2", 0x8000, 0x4000, 0, NULL, NULL},
		{"db1-1", 0xC000, 0x4000, 0, NULL, NULL},
                      {NULL, 0,0,0,NULL,NULL}};
     /* Banked at 0x4000-0x5fff */
LOADROM DRAGBUSTROMSB[] = {{"db1-3", 0x0000, 0x4000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM DRAGBUSTROMS2[] = {{"db1-4", 0x8000, 0x2000, 0, NULL, NULL},
		{"sk1-mcu.bin", 0xf000, 0x1000, 0, NULL, NULL}, // DEBUG
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM DRAGBUSTROMSG[] = {{"db1-6", 0x0000, 0x2000, 0, NULL, NULL}, /* Chars */
		{"db1-5",  0x2000, 0x2000, 0, NULL, NULL},
                        {"db1-7", 0x4000, 0x4000,0,NULL,NULL},
                        {"db1-8", 0x8000, 0x4000,0,NULL,NULL}, /* Sprites */
                        {"db1-1.bpr", 0xc000,0x100,0,NULL,NULL}, /* Green palette ROM */
                        {"db1-2.bpr", 0xc100,0x100,0,NULL,NULL}, /* Red palette ROM */
                        {"db1-3.bpr", 0xc200,0x100,0,NULL,NULL}, /* Blue palette ROM */
                        {"db1-5.bpr", 0xc300,0x200,0,NULL,NULL}, /* Sprite colors */
                        {"db1-4.bpr", 0xc500,0x200,0,NULL,NULL}, /* Background */
                        {"skysnd.bin",    0xc700,0x200,0,NULL,NULL}, /* Sound */
                      {NULL, 0, 0, 0, NULL, NULL}};

LOADROM GAPLUSROMS1[] = {//"gp2-4.64", 0x8000, 0x2000, 0, NULL, NULL,
		{"gp2-4.64", 0xA000, 0x2000, 0, NULL, NULL},
                      {"gp2-3.64", 0xC000, 0x2000, 0, NULL, NULL},
                      {"gp2-2.64", 0xE000, 0x2000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM GAPLUSROMS2[] = {{"gp2-8.64", 0xA000, 0x2000, 0, NULL, NULL},
		{"gp2-7.64", 0xC000, 0x2000,0,NULL,NULL},
                        {"gp2-6.64", 0xE000, 0x2000,0,NULL,NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM GAPLUSROMS3[] = {{"gp2-1.64", 0xE000, 0x2000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM GAPLUSROMSG[] = {{"gp2-5.64", 0x0000, 0x2000, 0, NULL, NULL},
		{"gp2-9.64",  0x2000, 0x2000, 0, NULL, NULL},
                        {"gp2-11.64", 0x4000, 0x2000,0,NULL,NULL},
                        {"gp2-10.64", 0x6000, 0x2000,0,NULL,NULL},
                        {"gp2-12.64", 0x8000, 0x2000,0,NULL,NULL},
                        {"gp2-3f.bin", 0xa000,0x100,0,NULL,NULL}, /* Sound PROM */
                        {"gp2-1p.bin", 0xa100,0x100,0,NULL,NULL}, /* Red palette ROM */
                        {"gp2-1n.bin", 0xa200,0x100,0,NULL,NULL}, /* Green palette ROM */
                        {"gp2-2n.bin", 0xa300,0x100,0,NULL,NULL}, /* Blue palette ROM */
                        {"gp2-6s.bin", 0xa400,0x100,0,NULL,NULL}, /* Char colors */
                        {"gp2-6p.bin", 0xa500,0x200,0,NULL,NULL}, /* Sprite colors low bits */
                        {"gp2-6n.bin", 0xa700,0x200,0,NULL,NULL}, /* Sprite colors high bits */
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM GAL3ROMS1[] = {//"gp2-4.64", 0x8000, 0x2000, 0, NULL, NULL,
		{"gal3_9e.bin", 0xA000, 0x2000, 0, NULL, NULL},
                      {"gal3_9d.bin", 0xC000, 0x2000, 0, NULL, NULL},
                      {"gal3_9c.bin", 0xE000, 0x2000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM GAL3ROMS2[] = {{"gal3_6l.bin", 0xA000, 0x2000, 0, NULL, NULL},
		{"gal3_6m.bin", 0xC000, 0x2000,0,NULL,NULL},
                        {"gal3_6n.bin", 0xE000, 0x2000,0,NULL,NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM GAL3ROMS3[] = {{"gal3_7b.bin", 0xE000, 0x2000, 0, NULL, NULL},
                      {NULL, 0, 0, 0, NULL, NULL}};
LOADROM GAL3ROMSG[] = {{"gal3_9l.bin", 0x0000, 0x2000, 0, NULL, NULL},
		{"gal3_5n.bin",  0x2000, 0x2000, 0, NULL, NULL},
                        {"gal3_5m.bin", 0x4000, 0x2000,0,NULL,NULL},
                        {"gal3_5l.bin", 0x6000, 0x2000,0,NULL,NULL},
                        {"gal3_5k.bin", 0x8000, 0x2000,0,NULL,NULL},
                        {"g3_4f.bin", 0xa000,0x100,0,NULL,NULL}, /* Sound PROM */
                        {"g3_1c.bin", 0xa100,0x100,0,NULL,NULL}, /* Red palette ROM */
                        {"g3_1d.bin", 0xa200,0x100,0,NULL,NULL}, /* Green palette ROM */
                        {"g3_2d.bin", 0xa300,0x100,0,NULL,NULL}, /* Blue palette ROM */
                        {"g3_8g.bin", 0xa400,0x100,0,NULL,NULL}, /* Char colors */
                        {"g3_3f.bin", 0xa500,0x200,0,NULL,NULL}, /* Sprite colors low bits */
                        {"g3_3e.bin", 0xa700,0x200,0,NULL,NULL}, /* Sprite colors high bits */
                      {NULL, 0, 0, 0, NULL, NULL}};
/* Convert 4 bit palette entries into 8 bits */
unsigned char cGaplusColorConvert[16] = {0,0x0e,0x1f,0x2d,0x43,0x51,0x62,0x70,0x8f,0x9d,0xae,0xbc,0xd2,0xe0,0xf1,0xff};

/* The color prom 256 for chars & sprites */
static unsigned char cGaplusSpritePROM[512];
static unsigned char cGaplusCharPROM[256];

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : AltPacVideoWrite(unsigned short, unsigned char)            *
 *                                                                          *
 *  PURPOSE    : Write to the 1K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void AltPacVideoWrite(int usAddr, unsigned char ucByte)
{

   usAddr &= 0x7fff; /* High bit of address bus is not connected, ignore it */
   if (mem_map[MEM_ROMRAM + usAddr] != ucByte) /* Only update flags if changing */
      {
      mem_map[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[usAddr & 0x3ff] = 1; /* Mark this char as changed */
      }

} /* AltPacVideoWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JRPacVideoWrite(unsigned short, unsigned char)             *
 *                                                                          *
 *  PURPOSE    : Write to the 1K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void JRPacVideoWrite(int usAddr, unsigned char ucByte)
{
//int i;

//   if (mem_map[MEM_ROMRAM + usAddr] != ucByte) /* Only update flags if changing */
//      {
      mem_map[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[usAddr & 0x7ff] = 1; /* Mark this char as changed */
//      if (usAddr < 0x4020) /* Line color, mark entire line */
//         for (i=2; i<56; i++)
//            cDirtyChar[i*32] = 1;
//      }

} /* JRPacVideoWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacVideoWrite(unsigned short, unsigned char)               *
 *                                                                          *
 *  PURPOSE    : Write to the 1K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void PacVideoWrite(int usAddr, unsigned char ucByte)
{

   if (mem_map[MEM_ROMRAM + usAddr] != ucByte) /* Only update flags if changing */
      {
      mem_map[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[usAddr & 0x3ff] = 1; /* Mark this char as changed (color or char) */
      }

} /* PacVideoWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacIOWrite(unsigned short, unsigned char)                  *
 *                                                                          *
 *  PURPOSE    : A write to 5003 enables, 5002 disables.                    *
 *                                                                          *
 ****************************************************************************/
void PacIOWrite(int usAddr, unsigned char ucByte)
{
switch (usAddr)
   {
   case 0: /* Set interrupt vector */
      pacstruct.cPacIRQVal = ucByte;
      break;
   case 1:
	  pacstruct.cPacIRQVal = ucByte;
      break;
   case 2:
	  pacstruct.cPacIRQVal = ucByte;
      break;
   }

} /* PacIOWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacSoundRefresh(unsigned int)                              *
 *                                                                          *
 *  PURPOSE    : NAMCO sound hardware emulation.                            *
 *                                                                          *
 ****************************************************************************/
void PacSoundRefresh(unsigned int iBaseAddr)
{
unsigned char *p;

   p = &mem_map[MEM_ROMRAM + iBaseAddr];
   pWave[0] = 32 * (p[0x5] & 0x7);
   pWave[1] = 32 * (p[0xa] & 0x7);
   pWave[2] = 32 * (p[0xf] & 0x7);
   cVolume[0] = p[0x15] & 0xf;
   cVolume[1] = p[0x1a] & 0xf;
   cVolume[2] = p[0x1f] & 0xf;
   iFreq[0] = 65536 * (p[0x14] & 0xf) + 4096 * (p[0x13] & 0xf) + 256 * (p[0x12] & 0xf) + 16 * (p[0x11] & 0xf) + (p[0x10] & 0xf) ;
   iFreq[1] = 65536 * (p[0x19] & 0xf) + 4096 * (p[0x18] & 0xf) + 256 * (p[0x17] & 0xf) + 16 * (p[0x16] & 0xf) ;
   iFreq[2] = 65536 * (p[0x1e] & 0xf) + 4096 * (p[0x1d] & 0xf) + 256 * (p[0x1c] & 0xf) + 16 * (p[0x1b] & 0xf) ;

   iFreq[0] = (iFreq[0] * 1100)/1000; // fix tone
   iFreq[1] = (iFreq[1] * 1100)/1000; // fix tone
   iFreq[2] = (iFreq[2] * 1100)/1000; // fix tone

} /* PacSoundRefresh() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacConvertChars(void)                                      *
 *                                                                          *
 *  PURPOSE    : Convert the PacMan character ROMs into a more usable form. *
 *                                                                          *
 ****************************************************************************/
void PacConvertChars(void)
{
int i;
unsigned char c, *pTemp;

   pTemp = (unsigned char *)EMUAlloc(49152); /* 16K for my expanded version of the character map + 16K for sprites */
/* Convert the 256 characters */
   EMUDecodeGFX(&pacgfx0, 256, (char *)mem_map3, (char *)pTemp, FALSE);
   EMUDecodeGFX(&pacgfx1, 64, (char *)&mem_map3[4096], (char *)&pTemp[16384], FALSE);
   for (i=0; i<16384; i++)
      {
      c = pTemp[16384+i];
      if (c == 3) /* Make another copy with color 3 converted to 0 for invisible 'eyes' sprites */
         c = 0;
      pTemp[32768+i] = c;
      }
    /* Copy the data back into the other map & free temp */
    memcpy(mem_map3, pTemp, 49152);
    EMUFree(pTemp);
} /* PacConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacIRQWrite(unsigned short, unsigned char)                 *
 *                                                                          *
 *  PURPOSE    : A write to 5003 enables, 5002 disables.                    *
 *                                                                          *
 ****************************************************************************/
void PacIRQWrite(int usAddr, unsigned char ucByte)
{

   switch(usAddr & 1)
      {
      case 0: /* IRQ enable */
    	  pacstruct.cPacIRQEnable = ucByte;
         break;
      case 1:
    	  pacstruct.cPacSoundEnable = ucByte;
         break;
      }
   mem_map[MEM_ROMRAM + usAddr] = ucByte; /* Keep a copy for reads */

} /* PacIRQWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacIRQRead(unsigned short)                                 *
 *                                                                          *
 *  PURPOSE    : A write to 5003 enables, 5002 disables.                    *
 *                                                                          *
 ****************************************************************************/
unsigned char PacIRQRead(int usAddr)
{
unsigned char c;

   c = 0;
   switch (usAddr & 0xffc0) /* Bottom 6 address bits are not decoded */
      {
      case 0x5000: /* Input port 0 */
         if (ulKeys & RKEY_UP_P1) /* Up */
            c |= 1;
         if (ulKeys & RKEY_LEFT_P1) /* Left */
            c |= 2;
         if (ulKeys & RKEY_RIGHT_P1) /* Right */
            c |= 4;
         if (ulKeys & RKEY_DOWN_P1) /* Down */
            c |= 8;
         if (iPacGame == GAME_VANVAN && (ulKeys & RKEY_BUTT1_P1)) /* fire button */
            c |= 0x10;
         if (ulKeys & RKEY_COIN1) /* Coin 1 */
            c |= 0x20;
         if (iPacGame == GAME_CRUSH)
            c |= 0x10; /* Select upright cabinet style */
         if (iPacGame == GAME_MSPAC)
            c |= (MsPacOptions[4].iChoice<<4); /* rack advance */
         return 255-c;  /* Active low inputs */

      case 0x5040: /* Input port 1 */
         if (ulKeys & RKEY_UP_P1) /* Up */
            c |= 1;
         if (ulKeys & RKEY_LEFT_P1) /* Left */
            c |= 2;
         if (ulKeys & RKEY_RIGHT_P1) /* Right */
            c |= 4;
         if (ulKeys & RKEY_DOWN_P1) /* Down */
            c |= 8;
         if (iPacGame == GAME_VANVAN && (ulKeys & RKEY_BUTT1_P1)) /* fire button */
            c |= 0x10;
         if (ulKeys & RKEY_P1_START) /* Player 1 start */
            c |= 0x20;
         if (ulKeys & RKEY_P2_START) /* Player 2 start */
            c |= 0x40;
         return 255-c; /* Active low inputs */

      case 0x5080: /* Dipswitch */
         if (iPacGame == GAME_VANVAN)
            {
            c = 0xcd; /* Select upright and not flipscreen, 1c/1c */
            c |= VanVanOptions[0].iChoice << 4; /* Lives = bits 4-5 */
            }
         if (iPacGame == GAME_JRPAC)
            {
            c |= JRPacOptions[0].iChoice; /* Dipswitch coinage = bits 0-1 */
            c |= JRPacOptions[1].iChoice << 2; /* Lives = bits 2-3 */
            c |= JRPacOptions[2].iChoice << 4; /* Bonus Life = bits 4-5 */
            c |= JRPacOptions[3].iChoice << 6; /* Difficulty = bit 6 */
            c |= 0x80; /* Keep unknown option OFF */
            }
         if (iPacGame == GAME_PAC)
            {
            c |= PacOptions[0].iChoice; /* Dipswitch coinage = bits 0-1 */
            c |= PacOptions[1].iChoice << 2; /* Lives = bits 2-3 */
            c |= PacOptions[2].iChoice << 4; /* Bonus Life = bits 4-5 */
            c |= PacOptions[3].iChoice << 6; /* Difficulty = bit 6 */
            c |= PacOptions[4].iChoice << 7; /* Ghost Names = bit 7 */
            }
         if (iPacGame == GAME_MSPAC)
            {
            c |= MsPacOptions[0].iChoice; /* Dipswitch coinage = bits 0-1 */
            c |= MsPacOptions[1].iChoice << 2; /* Lives = bits 2-3 */
            c |= MsPacOptions[2].iChoice << 4; /* Bonus Life = bits 4-5 */
            c |= MsPacOptions[3].iChoice << 6; /* Difficulty = bit 6 */
            }
         if (iPacGame == GAME_CRUSH)
            {
            c |= CrushOptions[0].iChoice; /* Dipswitch coinage = bits 0-1 */
            c |= CrushOptions[1].iChoice << 2; /* Lives = bits 2-3 */
            c |= CrushOptions[2].iChoice << 4; /* First Pattern = bit 4 */
            c |= CrushOptions[3].iChoice << 5; /* Teleport holes = bit 5 */
            c |= 0xc0; /* Turn off unknown dip switches */
            }
         return c;
      default:
         return mem_map[MEM_ROMRAM + usAddr];
      }

} /* PacIRQRead() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacIORead(unsigned short)                                  *
 *                                                                          *
 *  PURPOSE    : A write to 5003 enables, 5002 disables.                    *
 *                                                                          *
 ****************************************************************************/
unsigned char PacIORead(int usAddr)
{
return 0;
} /* PacIORead() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PengoVideoWrite(unsigned short, unsigned char)             *
 *                                                                          *
 *  PURPOSE    : Write to the 1K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void PengoVideoWrite(int usAddr, unsigned char ucByte)
{

   if (mem_map[MEM_ROMRAM + usAddr] != ucByte) /* Only update flags if changing */
      {
      mem_map[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[usAddr & 0x3ff] = 1; /* Mark this char as changed */
      }

} /* PengoVideoWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PengoPortRead(unsigned short)                              *
 *                                                                          *
 *  PURPOSE    : Read data ports for Pengo.                                 *
 *                                                                          *
 ****************************************************************************/
unsigned char PengoPortRead(int usAddr)
{
unsigned char c;

   switch (usAddr)
      {
      case 0x9000: /* DSW 1 - coinage, set to fixed value of 1/1 */
         c = 0xcc;
         break;
      case 0x9040: /* DSW 0 */
         c = 0x20; /* Rack test, OFF */
         c |= PengoOptions[0].iChoice; /* Bonus life = bit 0 */
         c |= PengoOptions[1].iChoice << 1; /* Demo sounds = bit 1 */
         c |= PengoOptions[2].iChoice << 3; /* Lives = bits 3-4 */
         c |= PengoOptions[3].iChoice << 6; /* Difficulty = bits 6-7 */
         break;
      case 0x9080: /* IN1 - active low inputs */
         c = 0xff;
         if (ulKeys & RKEY_UP_P1) /* Up */
            c ^= 1;
         if (ulKeys & RKEY_DOWN_P1) /* Left */
            c ^= 2;
         if (ulKeys & RKEY_LEFT_P1) /* Right */
            c ^= 4;
         if (ulKeys & RKEY_RIGHT_P1) /* Down */
            c ^= 8;
         if (ulKeys & RKEY_P1_START) /* Player 1 start */
            c ^= 0x20;
         if (ulKeys & RKEY_P2_START) /* Player 2 start */
            c ^= 0x40;
         break;
      case 0x90c0: /* IN0 */
         c = 0xff; /* Active low */
         if (ulKeys & RKEY_UP_P1) /* Up */
            c ^= 1;
         if (ulKeys & RKEY_DOWN_P1) /* Left */
            c ^= 2;
         if (ulKeys & RKEY_LEFT_P1) /* Right */
            c ^= 4;
         if (ulKeys & RKEY_RIGHT_P1) /* Down */
            c ^= 8;
         if (ulKeys & RKEY_COIN1) /* Coin 1 */
            {
            c ^= 0x10;
//            bTrace = TRUE; // DEBUG
            }
         if (ulKeys & RKEY_BUTT1_P1) /* Shoot */
            c ^= 0x80;
         break;
      default:
         c = mem_map[MEM_ROMRAM + usAddr];
         break;
      }
   return c;

} /* PengoPortRead() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PengoPortWrite(unsigned short, unsigned char)              *
 *                                                                          *
 *  PURPOSE    : Specific hardware on Pengo.                                *
 *                                                                          *
 ****************************************************************************/
void PengoPortWrite(int usAddr, unsigned char ucByte)
{

   switch (usAddr)
      {
      case 0x9040: /* Interrupt enable */
         pacstruct.cPacIRQEnable = ucByte & 1;
         break;
//      case 0x9041: /* Sound enable */
//         break;
      case 0x9047: /* GFX bank */
         mem_map[MEM_ROMRAM+usAddr] = ucByte; /* For load/save game state */
         if (pacstruct.iGfxBank != (ucByte & 1))
            {
            memset(cDirtyChar, 1, 1024); /* Force a total redraw */
            pacstruct.iGfxBank = ucByte & 1;
            }
         break;
      default:
         mem_map[MEM_ROMRAM + usAddr] = ucByte; /* Always store it so it will be correctly read */
         break;
      }

} /* PengoPortWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PengoSoundRefresh(void)                                    *
 *                                                                          *
 *  PURPOSE    : NAMCO sound hardware emulation.                            *
 *                                                                          *
 ****************************************************************************/
void PengoSoundRefresh(void)
{

   pWave[0] = 32 * (mem_map[0x9005] & 0x7);
   pWave[1] = 32 * (mem_map[0x900a] & 0x7);
   pWave[2] = 32 * (mem_map[0x900f] & 0x7);
   cVolume[0] = mem_map[0x9015];
   cVolume[1] = mem_map[0x901a];
   cVolume[2] = mem_map[0x901f];
   iFreq[0] = 65536 * mem_map[0x9014] + 4096 * mem_map[0x9013] + 256 * mem_map[0x9012] + 16 * mem_map[0x9011] + mem_map[0x9010];
   iFreq[1] = 65536 * mem_map[0x9019] + 4096 * mem_map[0x9018] + 256 * mem_map[0x9017] + 16 * mem_map[0x9016];
   iFreq[2] = 65536 * mem_map[0x901e] + 4096 * mem_map[0x901d] + 256 * mem_map[0x901c] + 16 * mem_map[0x901b];

} /* PengoSoundRefresh() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacSoundUpdate(int)                                        *
 *                                                                          *
 *  PURPOSE    : Create waveform data for the time slice last executed.     *
 *                                                                          *
 ****************************************************************************/
void PacSoundUpdate(signed short *pSoundBuf, int iLen)
{
int i;//, iInc;
int iVoice, f, v;
signed short s, *d;
signed char *p;

//   memset(&pSoundBuf[iSoundLen], 128, iLen); /* Set to middle silence to begin */
   d = pSoundBuf;
   for (i=0; i<iLen; i++)
      {
      s = 0; //0x80;
      for (iVoice=0; iVoice<3; iVoice++)
         {
         if (iFreq[iVoice] && cVolume[iVoice])
            {
            f = iFreq[iVoice];
            v = cVolume[iVoice];
            p = pWave[iVoice] + pWaveforms + (v-1)*256;
            s += p[(iPosition[iVoice] >> iAudioShift) & 0x1f];
            iPosition[iVoice] += f;
            } /* if each active voice */
         } /* for each voice */
      *d++ = (s << 7);
      *d++ = (s << 7); // mono source, stereo output
      } /* for each sound sample */
//      if (pSounds && pSounds[0].bActive) /* If an explosion sample is loaded and active */
//         {
//         d = pSoundBuf;
//         iInc = 1<<(2-iSampleRate); /* To adjust for sample rate vs. playback rate */
//         for (i=0; i<iLen; i++)
//            {
//            *d++ += (pSounds[0].pSound[pSounds[0].iPos] <<5);
//            pSounds[0].iPos += iInc;
//            if (pSounds[0].iPos >= pSounds[0].iLen) /* Reached the end of this sample */
//               {
//               pSounds[0].bActive = FALSE;
//               break;
//               }
//            } /* for */
//         }

} /* PacSoundUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PNPIRQ2Write(unsigned short, unsigned char)                *
 *                                                                          *
 *  PURPOSE    : IRQ enable for PNP CPU 2 (2000-2001)                       *
 *                                                                          *
 ****************************************************************************/
void PNPIRQ2Write(int usAddr, unsigned char ucByte)
{
  superpacstruct.cIRQEnable2 = usAddr & 1;
} /* PNPIRQ2Write() */

unsigned char digdug2_customio_r_1(int usAddr)
{
        static int crednum[] = { 1, 1, 2, 2 };
        static int credden[] = { 1, 2, 1, 3 };
    static long lOld = 0;
        int offset, temp, mode = mem_map1[MEM_ROMRAM + 0x4808];
    unsigned char val;

    offset = usAddr & 0xf;
        /* mode 3 is the standard, and returns actual important values */
        if (mode == 1 || mode == 3)
        {
                switch (offset)
                {
                        case 0:         /* Coin slots, low nibble of port 4 */
                        {
                                static char lastval;
                val = 0;
                if (ulKeys & RKEY_COIN1 && !(lOld & RKEY_COIN1)) /* Coin 1 - rising edge only to do a one-shot */
                   val |= 1;
                lOld = ulKeys;
                                /* bit 0 is a trigger for the coin slot */
                                if ((val & 1) && ((val ^ lastval) & 1)) ++credits;

                                return lastval = val;
                        }

                        case 1:         /* Start buttons, high nibble of port 4 */
                        {
                                static int lastval;

                                temp = DigDug2Options[1].iChoice; /* Credit value */
                                val = 0;
                if (ulKeys & RKEY_P1_START) /* Start player 1 */
                   val |= 1;
                if (ulKeys & RKEY_P2_START) /* Start player 2 */
                   val |= 2;

                                /* bit 0 is a trigger for the 1 player start */
                                if ((val & 1) && ((val ^ lastval) & 1))
                                        if (credits >= credden[temp]) credits -= credden[temp];
                                /* bit 1 is a trigger for the 2 player start */
                                if ((val & 2) && ((val ^ lastval) & 2))
                                        if (credits >= 2 * credden[temp]) credits -= 2 * credden[temp];

                                return lastval = val;
                        }

                        case 2:         /* High BCD of credits */
                                temp = DigDug2Options[1].iChoice;
                                return (credits * crednum[temp] / credden[temp]) / 10;

                        case 3:         /* Low BCD of credits */
                                temp = DigDug2Options[1].iChoice;
                                return (credits * crednum[temp] / credden[temp]) % 10;

                        case 4:         /* Player 1 joystick */
                val = 0;
                if (ulKeys & RKEY_UP_P1) /* up */
                   val |= 1;
                if (ulKeys & RKEY_RIGHT_P1) /* right */
                   val |= 2;
                if (ulKeys & RKEY_DOWN_P1) /* down */
                   val |= 4;
                if (ulKeys & RKEY_LEFT_P1) /* left */
                   val |= 8;
                                return val;

                        case 5:         /* Player 1 buttons */
                val = 0;
                if (ulKeys & RKEY_BUTT1_P1) /* button 1 */
                   val |= 1;
                if (lOld & RKEY_BUTT1_P1) /* button 1 - previous value */
                   val |= 2;
                lOld = ulKeys;
                                return val;

                        case 6:         /* Read, but unknown */
                           return 0;
                        case 7:         /* Read, but unknown */
                           return 0xf;
                }
        }

        /* by default, return what was stored there */
        return mem_map1[MEM_ROMRAM + usAddr];
} /* digdug2_customio_r_1 */

unsigned char digdug2_customio_r_2(int usAddr)
{
        int offset, mode = mem_map1[MEM_ROMRAM + 0x4818];
    static long lOld = 0;
    unsigned char c;

    offset = usAddr & 0xf;

        /* mode 4 is the standard, and returns actual important values */
        if (mode == 4)
        {
                switch (offset)
                {
                        case 2:         /* DSW0, low nibble */
                c = 0; /* unused... */
                                return c;
                        case 4:         /* DSW0, high nibble */
                c = DigDug2Options[0].iChoice << 1;
                c |= DigDug2Options[1].iChoice << 2;
                                return c;

                        case 5:         /* DSW1, high nibble */
                /* Orientation & button 2*/
                c = 0;
                if (ulKeys & RKEY_BUTT2_P1) /* button 2 */
                   c |= 1;
                if (lOld & RKEY_BUTT2_P1) /* button 2 - previous value */
                   c |= 2;
                lOld = ulKeys;
                                return c;

                        case 6:         /* DSW1, low nibble */
                c = DigDug2Options[2].iChoice;
                c |= DigDug2Options[3].iChoice << 2;
                c |= DigDug2Options[4].iChoice << 3;
                                return c;

                        case 7:         /* DSW2 - service switch */
                                return 0;

                        case 0:         /* read, but unknown */
                        case 1:         /* read, but unknown */
                        case 3:         /* read, but unknown */
                                return 0;
                }
        }

        /* by default, return what was stored there */
        return mem_map1[MEM_ROMRAM + usAddr];
} /* digdug2_customio_r_2 */

unsigned char mappy_customio_r_1(int usAddr)
{
        static int crednum[] = { 1, 2, 3, 6, 1, 3, 1, 2 };
        static int credden[] = { 1, 1, 1, 1, 2, 2, 3, 3 };
    static long lOld, lOldButton;
    static int iTime = 0;
    unsigned char c;
        int offset, val, temp, mode = mem_map1[MEM_ROMRAM + 0x4808];

    offset = usAddr & 0xf;
        /*if (errorlog)
                fprintf (errorlog, "I/O read 1: mode %d offset %d\n", mode, offset);*/

        /* mode 3 is the standard, and returns actual important values */
        if (mode == 1 || mode == 3)
        {
                switch (offset)
                {
                        case 0:         /* Coin slots, low nibble of port 4 */
                        {
                                static int count=6;
                        val = 0;
                        if (ulKeys & RKEY_COIN1 && !(lOld & RKEY_COIN1)) /* Coin 1 */
                           {
                           credits++;
                           count = 0;
                           }
                        if (++count < 3)
                          val = 1;
                        lOld = ulKeys;
                        return val;
                        }

                        case 1:         /* Start buttons, high nibble of port 4 */
                        {
                                static int lastval;

                temp = MappyOptions[0].iChoice; /* credits/coin */
                val = 0;
                if (ulKeys & RKEY_P1_START) /* Player 1 start */
                   val |= 1;
                if (ulKeys & RKEY_P2_START) /* Player 2 start */
                   val |= 2;

                                /* bit 0 is a trigger for the 1 player start */
                                if ((val & 1) && ((val ^ lastval) & 1))
                                        if (credits >= credden[temp]) credits -= credden[temp];
                                /* bit 1 is a trigger for the 2 player start */
                                if ((val & 2) && ((val ^ lastval) & 2))
                                        if (credits >= 2 * credden[temp]) credits -= 2 * credden[temp];

                                return lastval = val;
                        }

                        case 2:         /* High BCD of credits */
                temp = MappyOptions[0].iChoice; /* credits/coin */
                                return (credits * crednum[temp] / credden[temp]) / 10;

                        case 3:         /* Low BCD of credits */
                temp = MappyOptions[0].iChoice; /* credits/coin */
                                return (credits * crednum[temp] / credden[temp]) % 10;

                        case 4:         /* Player 1 joystick */
                if (ulKeys & RKEY_LEFT_P1) /* Left */
                   return 8;
                if (ulKeys & RKEY_RIGHT_P1) /* Right */
                   return 2;
                return 0;

                        case 5:         /* Player 1 buttons */
               c = 0;
               if ((ulKeys & RKEY_BUTT1_P1) && (lOldButton & RKEY_BUTT1_P1) == 0) /* button 1 */
                  iTime = 2; // start timer
               lOldButton = ulKeys;
               if (iTime)
                  {
                  iTime--;
                  if (iTime == 1) // button just pressed
                     c |= 1;
                  if (iTime == 0) // previous value
                     c |= 2;
                  }
               return c;

                        case 6:         /* Read, but unknown */
                        case 7:         /* Read, but unknown */
                                return 0;
                }
        }

        /* mode 5 values are actually checked against these numbers during power up */
        else if (mode == 5)
        {
                static int testvals[] = { 8, 4, 6, 14, 13, 9, 13 };
                if (offset >= 1 && offset <= 7)
                        return testvals[offset - 1];
        }

        /* by default, return what was stored there */
        return mem_map1[MEM_ROMRAM + usAddr];
}


unsigned char mappy_customio_r_2(int usAddr)
{
    unsigned char c;
        int offset, mode = mem_map1[MEM_ROMRAM + 0x4818];

    offset = usAddr & 0xf;
        /*if (errorlog)
                fprintf (errorlog, "I/O read 2: mode %d, offset %d\n", mappy_customio_2[8], offset);*/

        /* mode 4 is the standard, and returns actual important values */
        if (mode == 4)
        {
                switch (offset)
                {
                        case 0:         /* DSW1, low nibble */
               c = MappyOptions[4].iChoice; /* credits/coin */
               c |= MappyOptions[5].iChoice << 3;
               return c & 0x0f;

                        case 1:         /* DSW1, high nibble */
               c = MappyOptions[5].iChoice << 3;
               c |= MappyOptions[6].iChoice << 6;
               return c >> 4;

                        case 2:         /* DSW0, low nibble */
               c = MappyOptions[0].iChoice;
               return c & 0x0f;

                        case 4:         /* DSW0, high nibble */
               c = MappyOptions[1].iChoice << 5;
               c = MappyOptions[2].iChoice << 6;
               c = MappyOptions[3].iChoice << 7;
               return c >> 4;

                        case 6:         /* DSW2 - service switch */
//                              return readinputport (2) & 0x0f;
               return 0; // DEBUG

                        case 3:         /* read, but unknown */
                        case 5:         /* read, but unknown */
                        case 7:         /* read, but unknown */
                                return 0;
                }
        }

        /* mode 5 values are actually checked against these numbers during power up */
        else if (mode == 5)
        {
                static int testvals[] = { 8, 4, 6, 14, 13, 9, 13 };
                if (offset >= 1 && offset <= 7)
                        return testvals[offset - 1];
        }

        /* by default, return what was stored there */
        return mem_map1[MEM_ROMRAM + usAddr];
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MappyScrollWrite(unsigned short, unsigned char)            *
 *                                                                          *
 *  PURPOSE    : Write to the Mappy video scroll registers (2K)             *
 *                                                                          *
 ****************************************************************************/
void MappyScrollWrite(int usAddr, unsigned char ucByte)
{
  superpacstruct.cMappyScroll = (usAddr >> 3);
} /* MappyScrollWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MappyVideoWrite(unsigned short, unsigned char)             *
 *                                                                          *
 *  PURPOSE    : Write to the 2K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void MappyVideoWrite(int usAddr, unsigned char ucByte)
{

   if (mem_map1[MEM_ROMRAM+usAddr] != ucByte)
      {
      mem_map1[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[usAddr & 0x7ff] = 1; /* Mark this char as changed */
      }

} /* MappyVideoWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MappyColorWrite(unsigned short, unsigned char)             *
 *                                                                          *
 *  PURPOSE    : Write to the 2K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void MappyColorWrite(int usAddr, unsigned char ucByte)
{
     if (mem_map1[MEM_ROMRAM+usAddr] != ucByte)
        {
        mem_map1[MEM_ROMRAM + usAddr] = ucByte;
        cDirtyChar[usAddr & 0x7ff] = 1; /* Mark this color as changed */
        }

} /* MappyColorWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : EMUDrawSprite5(int, int, uchar, uchar, bool bool)          *
 *                                                                          *
 *  PURPOSE    : Draw an individual sprite with the given attributes.       *
 *               The transparency color is tested after lookup.             *
 *                                                                          *
 ****************************************************************************/
void EMUDrawSprite5(int sx, int sy, int iSprite, int iColor, BOOL bFlipx, BOOL bFlipy, unsigned char *pSpriteData, unsigned char *pColorPROM, unsigned char cColor)
{
unsigned char *d, *p;
int xCount, yCount;//, iDestPitch;
unsigned char c;
register int x, y;

/* Adjust for clipped sprite */
   xCount = yCount = 16; /* Assume full size to draw */
   p = &pSpriteData[iSprite * 256];
   if (sy < 0)
      {
      yCount += sy; /* Shrink height to draw */
      if (bFlipy)
         p += (sy*16);
      else
         p -= (sy*16); /* Adjust sprite pointer also */
      sy = 0; /* Start at 0 */
      }
   else
   if (sy > iSpriteLimitY-16) /* Part of it is off the bottom edge */
      yCount = (iSpriteLimitY-sy); /* Only draw part of it */

   if (sx < 0)
      {
      xCount += sx; /* Shrink width to draw */
      if (bFlipx)
         p += sx;
      else
         p -= sx; /* Adjust sprite pointer */
      sx = 0; /* Start at 0 */
      }
   else
   if (sx > iSpriteLimitX-16) /* Part of it is off the right edge */
      xCount = (iSpriteLimitX-sx); /* Only draw part of it */

   if (xCount < 1 || yCount < 1)
      return; /* Nothing to do! */
   d = &pCoinOpBitmap[sy*iCoinOpPitch + sx];
//   iDestPitch = iCoinOpPitch - xCount;

/* 4 possible flip cases */
   if (bFlipx && bFlipy) /* Both directions flipped */
      {
      pColorPROM += iColor;
      p += 15*16;
      for (y=0; y<yCount; y++)
         {
         for (x=0; x<xCount; x++)
            {
            c = p[15-x];
            c = pColorPROM[c];
            if (c != cColor)
               d[x] = c;
            }
         d += iCoinOpPitch;
         p -= 16;
         }
      }
   if (bFlipx && !bFlipy)
      {
      pColorPROM += iColor;
      for (y=0; y<yCount; y++)
         {
         for (x=0; x<xCount; x++)
            {
            c = p[15-x];
            c = pColorPROM[c];
            if (c != cColor)
               d[x] = c;
            }
         d += iCoinOpPitch;
         p += 16;
         }
      }
   if (!bFlipx && !bFlipy) /* Normal direction */
      {
      pColorPROM += iColor;
      for (y=0; y<yCount; y++)
         {
         for (x=0; x<xCount; x++)
            {
            c = p[x];
            c = pColorPROM[c];
            if (c != cColor)
               d[x] = c;
            }
         d += iCoinOpPitch;
         p += 16;
         }
      }
   if (!bFlipx && bFlipy)
      {
      pColorPROM += iColor;
      p += 15*16;
      for (y=0; y<yCount; y++)
         {
         for (x=0; x<xCount; x++)
            {
            c = p[x];
            c = pColorPROM[c];
            if (c != cColor)
               d[x] = c;
            }
         d += iCoinOpPitch;
         p -= 16;
         }
      }

} /* EMUDrawSprite5() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPDrawSprites(void)                                        *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
void SPDrawSprites(void)
{
int iOffset;
unsigned char ucSprite, ucColor;
int x, y, mx, my, cx, cy, *p;
BOOL bFlipx, bFlipy;

	cx = cy = 0; // suppress compiler warning
/* First 52 sprites are static, so draw them the 'fast' way */
#ifdef BOGUS
        for (iOffset=0; iOffset<104; iOffset += 2)
           {
           ucColor = mem_map1[MEM_ROMRAM + iOffset + 0xf81]; /* Sprite area #1 */
           x = mem_map1[MEM_ROMRAM + iOffset + 0x1780]-17;  /* Sprite area #2 */
           y = (mem_map1[MEM_ROMRAM + iOffset + 0x1781]-40) + 0x100*(mem_map1[MEM_ROMRAM + iOffset + 0x1f81] & 1);
           if (x < 0 || x > 208 || y < 16 || y > 272) /* Disabled sprites have x set to 232 */
              continue;
           ucSprite = mem_map1[MEM_ROMRAM + iOffset + 0xf80]; /* Sprite area #1 */
           ucColor = 90 + (ucColor << 2); /* Since image data is 2bpp */
           EMUDrawSpriteFast(x, y, ucSprite, ucColor, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch);
           mx = x>>3; /* Get the x,y in terms of character coordinates */
           my = y>>3;
           cx = cy = 2;
           if (x & 7) /* If touching next char, need to redraw it */
              cx++;
           if (y & 7) /* Same goes for vertical */
              cy++;
           p = &iCharX[2048+(28*my)]; /* Our special coordinate conversion table */
           for (y=my; y<my+cy; y++)
              {
              for (x=mx; x<mx+cx; x++)
                 {
                 cDirtyChar[p[x]] = 1; /* Mark the char as needing a repaint */
                 }
              p += 28; /* Skip to next line */
              }
           } /* for each simple sprite */
#endif /* BOGUS */
/* The next 14 are used for moving objects, draw them the 'slow' way */
        for (iOffset=0; iOffset<128; iOffset += 2)  /* Up to 64 simultaneous sprites */
           {
          ucColor = mem_map1[MEM_ROMRAM + iOffset + 0xf81]; /* Sprite area #1 */
          if (ucColor >= 0x30 && ucColor < 0x34) // coffee break animation
             ucColor -= 0x10; // LIB0002
          x = mem_map1[MEM_ROMRAM + iOffset + 0x1780]-17;  /* Sprite area #2 */
          if (ucColor == 0 || x == 0xe8) /* Disabled sprites have x set to 232 */
             continue;
          if (x > 0xe8) // negative value
             x |= 0xffffff00;
          ucSprite = mem_map1[MEM_ROMRAM + iOffset + 0xf80]; /* Sprite area #1 */
          if (ucSprite == 52)
             y = 0;
          y = (mem_map1[MEM_ROMRAM + iOffset + 0x1781]-40) + 0x100*(mem_map1[MEM_ROMRAM + iOffset + 0x1f81] & 1);
          bFlipx = mem_map1[MEM_ROMRAM + iOffset + 0x1f80] & 2;
          bFlipy = mem_map1[MEM_ROMRAM + iOffset + 0x1f80] & 1;
          if (ucColor == 0xA) /* Eyes */
             ucSprite += 128; /* Use alternate sprite data with 1's turned into zero's */
          ucColor = 92 + (ucColor << 2); /* Since image data is 2bpp */
          switch (mem_map1[MEM_ROMRAM + iOffset + 0x1f80] & 0x0c)
             {
             case 0:    /* Regular size */
                cx = cy = 2; /* size of drawn area */
                EMUDrawGraphicTransparent(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
//                EMUDrawSprite(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                break;
             case 4:    /* Double Height */
                cx = 2;
                cy = 4; /* size of drawn area */
                ucSprite &= ~1;  /* Make sure it's on an even number */
                if (bFlipy)
                   {
//                   EMUDrawSprite(x, y+16, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x, y, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y+16, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x, y, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                else
                   {
//                   EMUDrawSprite(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x, y+16, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x, y+16, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                break;
             case 8:   /* Double Width */
                cx = 4;
                cy = 2; /* size of drawn area */
                ucSprite &= ~2;
                if (!bFlipx)
                   {
//                   EMUDrawSprite(x, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                else
                   {
//                   EMUDrawSprite(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                break;
             case 12:   /* Double height, double width */
                cx = cy = 4; /* size of drawn area */
                ucSprite &= ~3;
                if (!bFlipy && !bFlipx)
                   {
//                   EMUDrawSprite(x, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x, y+16, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y+16, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x, y+16, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y+16, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                else if (bFlipy && bFlipx)
                   {
//                   EMUDrawSprite(x, y, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x, y+16, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y+16, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x, y+16, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y+16, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                else if (bFlipx)
                   {
//                   EMUDrawSprite(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x, y+16, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y+16, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x, y+16, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y+16, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                else /* bFlipy */
                   {
//                   EMUDrawSprite(x, y, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x, y+16, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
//                   EMUDrawSprite(x+16, y+16, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM);
                   EMUDrawGraphicTransparent(x, y, ucSprite+3, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x, y+16, ucSprite+2, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y, ucSprite+1, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   EMUDrawGraphicTransparent(x+16, y+16, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
                   }
                break;
             } /* switch */
/* Mark the proper characters as needing a redraw */
          mx = x>>3; /* Get the x,y in terms of character coordinates */
          my = y>>3;
          if (x & 7) /* If touching next char, need to redraw it */
             cx++;
          if (y & 7) /* Same goes for vertical */
             cy++;
          p = &iCharX[2048+(28*my)]; /* Our special coordinate conversion table */
          for (y=my; y<my+cy; y++)
             {
             for (x=mx; x<mx+cx; x++)
                {
                if (x>=0 && y>=0 && x<28 && y<36)
                   cDirtyChar[p[x]] = 1; /* Mark the char as needing a repaint */
                }
             p += 28; /* Skip to next line */
             }
       } /* for each of 64 possible sprites */

} /* SPDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPScreenUpdate(void)                                       *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void SPScreenUpdate(void)
{
register int i;
register unsigned char c, *pCharData;

   pCharData = (unsigned char *)&mem_map1[MEM_ROMRAM];
   for (i=0; i<1023; i++)
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         c = pCharData[0];
         if (c == 0x20) /* A space, draw black */
            {
            EMUDrawCharBlack(i, iCoinOpPitch, 0);
            }
         else
            {
            EMUDrawChar(i, pCharPROM, iCoinOpPitch, c, (pCharData[0x400]&0x3f)<<2, lCharAddr, mem_map3);
//            EMUDrawCharFast(i, iPitch, c, (pCharData[0x400] << 2)-16, lCharAddr, mem_map3); /* Update this character/color */
            }
//         lDirtyRect |= 1<<(iCharY[i]>>4); /* Mark this as needing a repaint */
         }
      pCharData++;
      }
/* Draw sprites on top of the characters */
   SPDrawSprites(); /* Draw all of the sprites on top of the characters */

} /* SPScreenUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MappyConvertChars(void)                                    *
 *                                                                          *
 *  PURPOSE    : Convert the Mappy character ROMs into a more usable form.  *
 *                                                                          *
 ****************************************************************************/
void MappyConvertChars(void)
{
unsigned char *pTemp;

   pTemp = (unsigned char *)EMUAlloc(0xc000); /* 16K for my expanded version of the character map + 64K for sprites */
/* Convert the 256 characters */
   EMUDecodeGFX(&pacgfx0, 256, (char *)mem_map3, (char *)pTemp, FALSE);
/* Convert the 128 sprites */
   EMUDecodeGFX(&mappygfx1, 128, (char *)&mem_map3[0x1000], (char *)&pTemp[0x4000], FALSE);
/* Copy the data back into the other map & free temp */
   memcpy(mem_map3, pTemp, 0xc000);
   EMUFree(pTemp);

} /* MappyConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DigDug2ConvertChars(void)                                  *
 *                                                                          *
 *  PURPOSE    : Convert the DigDug2 character ROMs into a more usable form.*
 *                                                                          *
 ****************************************************************************/
void DigDug2ConvertChars(void)
{
unsigned char *pTemp;

   pTemp = (unsigned char *)EMUAlloc(0x14000); /* 16K for my expanded version of the character map + 128K for sprites */
/* Convert the 256 characters */
   EMUDecodeGFX(&pacgfx0, 256, (char *)mem_map3, (char *)pTemp, FALSE);
/* Convert the 256 sprites */
   EMUDecodeGFX(&digdug2gfx1, 256, (char *)&mem_map3[0x1000], (char *)&pTemp[0x4000], FALSE);
/* Copy the data back into the other map & free temp */
   memcpy(mem_map3, pTemp, 0x14000);
   EMUFree(pTemp);

} /* DigDug2ConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPConvertChars(void)                                       *
 *                                                                          *
 *  PURPOSE    : Convert the PacMan character ROMs into a more usable form. *
 *                                                                          *
 ****************************************************************************/
void SPConvertChars(void)
{
int i;
unsigned char c, *pTemp;

   pTemp = (unsigned char *)EMUAlloc(0x18000); /* 16K for my expanded version of the character map + 2*32K for sprites */
/* Convert the 256 characters */
   EMUDecodeGFX(&pacgfx0, 256, (char *)mem_map3, (char *)pTemp, FALSE);
/* Convert the 128 sprites */
   EMUDecodeGFX(&diggfx1, 128, (char *)&mem_map3[0x1000], (char *)&pTemp[0x4000], FALSE);
   for (i=0; i<32768; i++)
      {
      c = pTemp[0x4000+i];
      if (c == 3) /* Make another copy with color 3 converted to 0 for invisible 'eyes' sprites */
         c = 0;
      pTemp[0xc000+i] = c;
      }
/* Copy the data back into the other map & free temp */
   memcpy(mem_map3, pTemp, 0x18000);
   EMUFree(pTemp);

} /* SPConvertChars() */

void EMUDrawMappyChar(int x, int y, int iChar, int iColor, unsigned char *pCharData)
{
unsigned char c, *p, *d;
int iWidth;

   p = &pCharData[iChar * 64];
   // Clip the char to not draw beyond the left or right edge
   iWidth = 8;
   if (x < 0)
      {
      iWidth += x;
      p -= x;
      x = 0;
      }
   if (x > 216)
      {
      iWidth = (224 - x);
      }
   d = (unsigned char *)&pCoinOpBitmap[y*iCoinOpPitch + x];
   for (y=0; y<8; y++)
      {
      for (x=0; x<iWidth; x++)
         {
         c = p[x];
         if (c != cTransparent2)
            d[x] = c + iColor;
         }
      d += iCoinOpPitch;
      p += 8;
      }

} /* EMUDrawMappyChar() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MappyDrawSprites(int, int, int)                            *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
void MappyDrawSprites(int iSpriteRAM1, int iSpriteRAM2, int iSpriteRAM3, int iShift)
{
int iOffset;
unsigned char ucSprite;
int x, y, iColor;
BOOL bFlipx, bFlipy;

        for (iOffset=0; iOffset<128; iOffset += 2)  /* Up to 64 simultaneous sprites */
           {
                /* Is the sprite enabled? */
       y = (mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM2+1]-40) + 0x100*(mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM3 + 1] & 1);
       if (y >= 16) /* Use to detect active sprites */
          {
          iColor = mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM1 + 1] & 0x1f; /* Sprite area #1 */
          x = mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM2]-16;  /* Sprite area #2 */
//          x2 = mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM2] - 16;
          ucSprite = mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM1]; /* Sprite area #1 */
          bFlipx = mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM3] & 2;
          bFlipy = mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM3] & 1;
          iColor <<= iShift; /* multiply by shift value since this is added to sprite image colors */
          switch (mem_map1[MEM_ROMRAM + iOffset + iSpriteRAM3] & 0x0c)
             {
             case 0:    /* Regular size */
                EMUDrawSprite5(x, y, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                break;
             case 4:    /* Double Height */
                ucSprite &= ~1;  /* Make sure it's on an even number */
                if (bFlipy)
                   {
                   EMUDrawSprite5(x, y+16, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x, y, ucSprite+1, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                else
                   {
                   EMUDrawSprite5(x, y, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x, y+16, ucSprite+1, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                break;
             case 8:   /* Double Width */
                ucSprite &= ~2;
                if (!bFlipx)
                   {
                   EMUDrawSprite5(x, y, ucSprite+2, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                else
                   {
                   EMUDrawSprite5(x, y, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y, ucSprite+2, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                break;
             case 12:   /* Double height, double width */
                ucSprite &= ~3;
                if (!bFlipy && !bFlipx)
                   {
                   EMUDrawSprite5(x, y, ucSprite+2, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x, y+16, ucSprite+3, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y+16, ucSprite+1, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                else if (bFlipy && bFlipx)
                   {
                   EMUDrawSprite5(x, y, ucSprite+1, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x, y+16, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y, ucSprite+3, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y+16, ucSprite+2, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                else if (bFlipx)
                   {
                   EMUDrawSprite5(x, y, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x, y+16, ucSprite+1, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y, ucSprite+2, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y+16, ucSprite+3, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                else /* bFlipy */
                   {
                   EMUDrawSprite5(x, y, ucSprite+3, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x, y+16, ucSprite+2, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y, ucSprite+1, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   EMUDrawSprite5(x+16, y+16, ucSprite, iColor, bFlipx, bFlipy, &mem_map3[16384], pSpritePROM, 32);
                   }
                break;
             } /* switch */
          } /* If sprite enabled */
       } /* for each of 64 possible sprites */

} /* MappyDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DigDug2ScreenUpdate(void)                                  *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void DigDug2ScreenUpdate(void)
{
int i, x, y;
int iChar, iColor;
unsigned char *s, *d;

   for (i=1984; i<2048; i++) /* Draw top 2 lines (non-scrolling) */
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         iColor = (mem_map1[MEM_ROMRAM + 0x800 + i] << 2);
         EMUDrawCharFast(i, 512, mem_map1[MEM_ROMRAM + i], 32+iColor, lCharAddr, mem_map3);
         }
      }
   for (i=0; i<1920; i++) /* Draw scrolling region */
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         iColor = ((mem_map1[MEM_ROMRAM + 0x800 + i] & 0x3f) << 2);
         if (iColor < 192)
            EMUDrawCharFast(i, 512, mem_map1[MEM_ROMRAM + i], 32+iColor, lCharAddr, mem_map3);
         else // some colors don't fit in the palette
            EMUDrawChar(i, pCharPROM, 512, mem_map1[MEM_ROMRAM + i], iColor, lCharAddr, mem_map3);
         }
      }
   for (i=1920; i<1984; i++) /* Draw bottom 2 lines (non-scrolling) */
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         iColor = (mem_map1[MEM_ROMRAM + 0x800 + i] << 2);
         EMUDrawCharFast(i, 512, mem_map1[MEM_ROMRAM + i], 32+iColor, lCharAddr, mem_map3);
         }
      }

// Copy the 3 parts of the display to the screen bitmap
// top 16 non-scrolling lines
   s = pCharmap;
   d = pCoinOpBitmap;
   for (i=0; i<16; i++)
      {
      memcpy(d, s, 224);
      s += 512;
      d += iCoinOpPitch;
      }
// Middle 256 scrolling lines
   s = &pCharmap[16*512] + 256 - superpacstruct.cMappyScroll;
   d = &pCoinOpBitmap[iCoinOpPitch*16];
   for (i=0; i<256; i++)
      {
      memcpy(d, s, 224);
      s += 512;
      d += iCoinOpPitch;
      }
// bottom 16 non-scrolling lines
   s = &pCharmap[512*272];
   d = &pCoinOpBitmap[iCoinOpPitch*272];
   for (i=0; i<16; i++)
      {
      memcpy(d, s, 224);
      s += 512;
      d += iCoinOpPitch;
      }

/* Draw sprites on top of the characters */
   MappyDrawSprites(0x1780, 0x1f80, 0x2780, 4); /* Draw all of the sprites on top of the characters */

/* Draw the high priority characters on top of the sprites */
   cTransparent2 = 2;
   for (i=0; i<1920; i++) /* Draw scrolling part of display */
      {
      iColor = mem_map1[MEM_ROMRAM + 0x800 + i];
      if (iColor & 0x40) /* High priority char */
         {
         iChar = mem_map1[MEM_ROMRAM + i];
         iColor = 48 + ((iColor & 0x3f) << 2);
         x = i / 32;
         y = i & 0x1f;
         x = 59 - x;
         y += 2;
         x <<= 3;
         y <<= 3;
         x -= (256-superpacstruct.cMappyScroll);
         if (x >= -7 && x < 224 && iColor == 48)
            EMUDrawMappyChar(x, y, iChar, iColor, mem_map3);
         }
      }

} /* DigDug2ScreenUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MappyScreenUpdate(void)                                    *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void MappyScreenUpdate(void)
{
unsigned char ucChar, ucColor, *s, *d;
signed int i, x, y;

   for (i=1984; i<2048; i++) /* Draw top 2 lines (non-scrolling) */
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         EMUDrawCharFast(i, 512, mem_map1[MEM_ROMRAM + i], (unsigned char)32+((mem_map1[MEM_ROMRAM + 0x800 + i] & 0x3f)<< 2), lCharAddr, mem_map3);
         }
      }

   for (i=0; i<1920; i++) /* Draw scrolling part of display */
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         ucColor = mem_map1[MEM_ROMRAM + 0x800 + i];
         ucChar = mem_map1[MEM_ROMRAM + i];
         ucColor = 32 + ((ucColor & 0x3f) << 2);
         EMUDrawCharFast(i, 512, ucChar, ucColor, lCharAddr, mem_map3);
         }
      }
   for (i=1920; i<1984; i++) /* Draw bottom 2 lines (non-scrolling) */
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         ucColor = mem_map1[MEM_ROMRAM + 0x800 + i];
         ucChar = mem_map1[MEM_ROMRAM + i];
         ucColor = 32 + ((ucColor & 0x3f)<< 2);
         EMUDrawCharFast(i, 512, ucChar, ucColor, lCharAddr, mem_map3);
         }
      }
// Copy the 3 parts of the display to the screen bitmap
// top 16 non-scrolling lines
   s = pCharmap;
   d = pCoinOpBitmap;
   for (i=0; i<16; i++)
      {
      memcpy(d, s, 224);
      s += 512;
      d += iCoinOpPitch;
      }
// Middle 256 scrolling lines
   s = &pCharmap[16*512] + 256 - superpacstruct.cMappyScroll;
   d = &pCoinOpBitmap[iCoinOpPitch*16];
   for (i=0; i<256; i++)
      {
      memcpy(d, s, 224);
      s += 512;
      d += iCoinOpPitch;
      }
// bottom 16 non-scrolling lines
   s = &pCharmap[512*272];
   d = &pCoinOpBitmap[iCoinOpPitch*272];
   for (i=0; i<16; i++)
      {
      memcpy(d, s, 224);
      s += 512;
      d += iCoinOpPitch;
      }

/* Draw sprites on top of the characters */
   MappyDrawSprites(0x1780, 0x1f80, 0x2780, 4); /* Draw all of the sprites on top of the characters */

/* Draw the high priority characters on top of the sprites */
   cTransparent2 = 3;
   for (i=0; i<1920; i++) /* Draw scrolling part of display */
      {
      ucColor = mem_map1[MEM_ROMRAM + 0x800 + i];
      if (ucColor & 0x40) /* High priority char */
         {
         ucChar = mem_map1[MEM_ROMRAM + i];
         ucColor = 48 + ((ucColor & 0x3f) << 2);
         x = i / 32;
         y = i & 0x1f;
         x = 59 - x;
         y += 2;
         x <<= 3;
         y <<= 3;
         x -= (256-superpacstruct.cMappyScroll);
         if (x >= -7 && x < 224)
            EMUDrawMappyChar(x, y, ucChar, ucColor, mem_map3);
         }
      }

} /* MappyScreenUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPSoundWrite(unsigned char *)                              *
 *                                                                          *
 *  PURPOSE    : CPU #2 creates sounds here.                                *
 *                                                                          *
 ****************************************************************************/
void SPSoundWrite(unsigned char *pSoundRegs)
{
int iVoice;


   for (iVoice=0; iVoice<8; iVoice++)
      {
      iFreq[iVoice] = 65536 * (pSoundRegs[6 + 8 * iVoice] & 15) + 256 * pSoundRegs[5 + 8 * iVoice] + pSoundRegs[4 + 8 * iVoice];
      iFreq[iVoice] = (iFreq[iVoice] * 1100/*850*/)/1000;
      cVolume[iVoice] = pSoundRegs[3 + 8 * iVoice] & 0xf;
      if (iFreq[iVoice] == 0)
         {
         iFreq[iVoice] = 1000;
         cVolume[iVoice] = 0;
         }
      pWave[iVoice] = 32 * ((pSoundRegs[6 + 8 * iVoice] >> 4) & 7);
      }

} /* SPSoundWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacPrepSounds(void)                                        *
 *                                                                          *
 *  PURPOSE    : Precalculate the sound waveforms to generate sound faster. *
 *                                                                          *
 ****************************************************************************/
void PacPrepSounds(int iShift)
{
signed char *p;
int v, j;

   p = pWaveforms; /* Destination of pre-calculated data */
   for (v=1; v<16; v++) /* Volume level */
      {
      for (j=0; j<256; j++) /* source data */
          {
          *p++ = ((((pSoundPROM[j] & 0x0f) - 8) * v) >> iShift); /* Do all necessary calculations beforehand */
          }
      }

} /* PacPrepSounds() */

void TestWrite(int usAddr,unsigned char ucByte)
{
if (ucByte == 0)
   ucByte++;
mem_map1[MEM_ROMRAM + usAddr + 0x5800] = ucByte;
} /* TestWrite() */

void GaplusWriteMirror(int usAddr,unsigned char ucByte)
{
mem_map1[MEM_ROMRAM + usAddr + 0x180] = ucByte;
} /* GaplusWriteMirror() */

unsigned char GaplusReadMirror(int usAddr)
{
return mem_map1[MEM_ROMRAM + usAddr + 0x180];
} /* GaplusReadMirror() */

void SkyIOWrite(int usAddr,unsigned char ucByte)
{
   switch (usAddr)
      {
      case 0x02:
         if ((ucByte & 0xf0) == 0x60) /* IO port select */
            cIOMode = ucByte & 7;
         break;
      default:
         mem_map2[MEM_ROMRAM + usAddr] = ucByte;
      }
} /* GaplusWriteMirror() */

unsigned char SkyIORead(int usAddr)
{
unsigned char c = 0;

switch (usAddr)
   {
   case 0x02: /* IO Port 1 */
      switch (cIOMode)
         {
         case 0: /* Lives, bonus life */
            c = SkyKidOptions[4].iChoice << 1; /* Bonus = bits 1,2 */
            c |= SkyKidOptions[3].iChoice << 3; /* Lives = bits 3,4 */
            break;
         case 1: /* Flip screen */
            c = SkyKidOptions[1].iChoice << 2; /* flip = bit 2 */
            c |= SkyKidOptions[7].iChoice << 1; /* Test mode = bit 1 */
            c |= 0xf1;
            break;
         case 2: /* Freeze = bits 0,1 ? */
            c = SkyKidOptions[5].iChoice << 2; /* Round advance = bit 2 */
            c |= SkyKidOptions[6].iChoice << 3; /* Attract mode sound = bit 3 */
            c |= 0xf3;
            break;
         case 3:
            c = 0xff; /* Bit 0 = freeze */
            if (ulKeys & RKEY_BUTT2_P1)
               c ^= 8;
            if (ulKeys & RKEY_BUTT2_P2)
               c ^= 4;
            break;
         case 4:
            c = 0xff;
            if (ulKeys & RKEY_COIN1)  /* Coin 1 */
               c ^= 0x1;
            if (ulKeys & RKEY_P1_START) /* Player 1 start */
               c ^= 0x8;
            if (ulKeys & RKEY_P2_START) /* Player 2 start */
               c ^= 0x10;
            break;
         case 5:
            c = 0xff;
            if (ulKeys & RKEY_UP_P2)
               c ^= 0x8;
            if (ulKeys & RKEY_DOWN_P2)
               c ^= 0x4;
            if (ulKeys & RKEY_RIGHT_P2)
               c ^= 0x2;
            if (ulKeys & RKEY_LEFT_P2)
               c ^= 0x1;
            if (ulKeys & RKEY_BUTT1_P2)
               c ^= 0x10;
            break;
         case 6:
            c = 0xff;
            if (ulKeys & RKEY_UP_P1)
               c ^= 0x8;
            if (ulKeys & RKEY_DOWN_P1)
               c ^= 0x4;
            if (ulKeys & RKEY_RIGHT_P1)
               c ^= 0x2;
            if (ulKeys & RKEY_LEFT_P1)
               c ^= 0x1;
            if (ulKeys & RKEY_BUTT1_P1)
               c ^= 0x10;
            break;
         }
      return c;
//   case 0x14:
//      return 0xf8; /* Tell the 6803 that Vcc standby power is OK */
   default:
      return mem_map2[MEM_ROMRAM + usAddr];
   }
} /* SkyIORead() */

unsigned char MetroIORead(int usAddr)
{
unsigned char c = 0;

switch (usAddr)
   {
   case 0x02: /* IO Port 1 */
      switch (cIOMode)
         {
         case 0:
            c = MetroOptions[6].iChoice << 4; /* Service mode = bit 4 */
            c |= MetroOptions[2].iChoice; /* Difficulty = bits 0,1 */
            c |= MetroOptions[0].iChoice << 2; /* Coin 1 = bits 2,3 */
            break;
         case 1:
            c = MetroOptions[4].iChoice << 4; /* Play = bit 4 */
            c |= MetroOptions[3].iChoice; /* Round Skip = bit 0 */
            c |= MetroOptions[5].iChoice << 1; /* Demo Sounds = bit 1 */
            c |= MetroOptions[1].iChoice << 2; /* Coin 2 = bits 2,3 */
            break;
         case 2:
            c = 0xff; /* Unknown option bits show up as 000000->111111 on display */
            break;
         case 3:
            c = MetroOptions[7].iChoice << 1; /* Cabinet = bit 1 */
            c |= 1; /* Needed to prevent test mode */
            break;
         case 4:
            c = 0xff;
            if (ulKeys & RKEY_COIN1)  /* Coin 1 */
               c ^= 0x1;
            if (ulKeys & RKEY_P1_START) /* Player 1 start */
               c ^= 0x8;
            if (ulKeys & RKEY_P2_START) /* Player 2 start */
               c ^= 0x10;
            break;
         case 5:
            c = 0xff;
            break;
         case 6:
            c = 0xff;
            if (ulKeys & RKEY_UP_P1)
               c ^= 0x8;
            if (ulKeys & RKEY_DOWN_P1)
               c ^= 0x4;
            if (ulKeys & RKEY_RIGHT_P1)
               c ^= 0x2;
            if (ulKeys & RKEY_LEFT_P1)
               c ^= 0x1;
            if (ulKeys & RKEY_BUTT1_P1)
               c ^= 0x10;
            break;
         }
      return c;
//   case 0x14:
//      return 0xf8; /* Tell the 6803 that Vcc standby power is OK */
   default:
      return mem_map2[MEM_ROMRAM + usAddr];
   }
} /* MetroIORead() */

unsigned char GaplusReadROM1(int usAddr)
{
return mem_map1[MEM_ROMRAM + usAddr];
} /* GaplusReadROM1() */

void SkyScrollWrite(int usAddr,unsigned char ucByte)
{
	skykidstruct.iScroll0 = (701 - ((usAddr - 0x6200) ^ 1)) & 0x1ff;
} /* SkyScrollWrite() */

void GaplusStarsWrite(int usAddr,unsigned char ucByte)
{
   mem_map1[MEM_ROMRAM + 0x9000] = ucByte; /* Stick it here for easier load/save */
} /* GaplusStarsWrite() */

void GaplusIRQ1Write(int usAddr,unsigned char ucByte)
{
//   if (usAddr == 0x7c00)
      cIRQEnable1 = 1; /* 0x9400 enables */
//   else
//      cIRQEnable1 = 0; /* 0x7400 disables */
} /* GaplusIRQ1Write() */

void GaplusIRQ2Write(int usAddr,unsigned char ucByte)
{
cIRQEnable2 = usAddr & 1;
} /* GaplusIRQ2Write() */
void GaplusIRQ3Write(int usAddr,unsigned char ucByte)
{
   if (usAddr == 0x6000)
      cIRQEnable3 = 0; /* 0x6000 disables */
   else
      cIRQEnable3 = 1; /* 0x4000 enables */
} /* GaplusIRQ3Write() */

void GaplusResetWrite(int usAddr,unsigned char ucByte)
{
   RESET6809(&regs2);
   RESET6809(&regs3);
} /* GaplusResetWrite() */

unsigned char GaplusSharedRead2(int usAddr)
{
return mem_map1[MEM_ROMRAM + 0x6000 + usAddr];
} /* GaplusSharedRead2() */
void GaplusSharedWrite2(int usAddr, unsigned char ucByte)
{
mem_map1[MEM_ROMRAM + 0x6000 + usAddr] = ucByte;
} /* GaplusSharedWrite2() */



unsigned char GaplusIORead3(int usAddr)
{
unsigned char mode = mem_map1[MEM_ROMRAM + 0x6828];

if (mode == 4 || mode == 1) /* Test mode ? */
   {
   switch (usAddr & 0xf)
      {
      case 0:
         return 0xd; /* dip switches bit (table = 0, upright = 4) */
      case 1:
         return 0x0f;
      case 2:
         return 0x0e;
      case 3:
         return 0x01;
      default:
         return mem_map1[MEM_ROMRAM + usAddr];
      }
   }
else
   if (mode == 2)
      {
      switch (usAddr & 0xf)
         {
         case 2:
            return 0xf;
         default:
            return mem_map1[MEM_ROMRAM + usAddr];
         }
      }
return mem_map1[MEM_ROMRAM + usAddr];
} /* GaplusIORead3() */

unsigned char gaplus_customio_r_1(int usAddr)
{
        static int crednum[] = { 1, 1, 2, 3 };
        static int credden[] = { 1, 2, 1, 1 };
    static long lOld2, lOld;
    static int iCount = 10;
    unsigned char c;
    int offset, val, temp, mode;

    mode = mem_map1[MEM_ROMRAM + 0x6808];

    offset = usAddr & 0xf;


        /* mode 3 is the standard, and returns actual important values */
        if (mode == 1 || mode == 3)
        {
                switch (offset)
                {
                        case 0:         /* Coin slots, low nibble of port 4 */
                        {
                                static int count = 5;
                        val = 0;
                        if (ulKeys & RKEY_COIN1 && !(lOld2 & RKEY_COIN1)) /* Coin 1 */
                           {
                           count = 0;
                           credits++;
                           }
                        lOld2 = ulKeys;
                        if (++count < 3) /* It wants to see the coin in the slot for at least 2 cycles */
                           val = 1;
                        return val;
                        }

                        case 1:         /* Start buttons, high nibble of port 4 */
                        {
                                static int lastval;

                temp = GaplusOptions[0].iChoice; /* credits/coin */
                if (ulKeys & RKEY_P1_START && credits >= credden[temp] && iCount > 50) /* Player 1 start */
                   {
                   lastval = 1;
                   iCount = 0;
                   }
                if (ulKeys & RKEY_P2_START && credits >= (2 * credden[temp]) && iCount > 50) /* Player 2 start */
                   {
                   lastval = 2;
                   iCount = 0;
                   }

                /* bit 0 is a trigger for the 1 player start */
                if (iCount == 0)
                   credits -= (lastval * credden[temp]);
                iCount++;
                if (iCount < 4)
                   return lastval;
                else
                   return 0;
                 }

                        case 2:         /* High BCD of credits */
                temp = GaplusOptions[0].iChoice; /* credits/coin */
                                return (credits * crednum[temp] / credden[temp]) / 10;

                        case 3:         /* Low BCD of credits */
                temp = GaplusOptions[0].iChoice; /* credits/coin */
                                return (credits * crednum[temp] / credden[temp]) % 10;

                case 4:         /* Player 1 joystick */
                c = 0;
                if (ulKeys & RKEY_LEFT_P1) /* Left */
                   c |= 8;
                if (ulKeys & RKEY_DOWN_P1) /* Down */
                   c |= 4;
                if (ulKeys & RKEY_RIGHT_P1) /* Right */
                   c |= 2;
                if (ulKeys & RKEY_UP_P1) /* Down */
                   c |= 1;
                return c;

                case 5:         /* Player 1 buttons */
               c = 0;
               if (ulKeys & RKEY_BUTT1_P1 && !(lOld & RKEY_BUTT1_P1)) /* button 1 */
                  c |= 1;
               if (lOld & RKEY_BUTT1_P1 && (ulKeys & RKEY_BUTT1_P1)) /* button 1 - previous value */
                  c |= 2;
               lOld = ulKeys;
               return c;

                case 6:         /* Read, but unknown */
                case 7:         /* Read, but unknown */
                   return 0;
                }
        }

        /* mode 5 values are actually checked against these numbers during power up */
        else if (mode == 5)
        {
        if (offset == 0 || offset == 1)
           return 0xf;
        else
           return mem_map1[MEM_ROMRAM + usAddr];
        }

        /* by default, return what was stored there */
        return mem_map1[MEM_ROMRAM + usAddr];
}


unsigned char gaplus_customio_r_2(int usAddr)
{
    unsigned char c;
    int offset, mode;

    mode = mem_map1[MEM_ROMRAM + 0x6818];

    offset = usAddr & 0xf;

        /* mode 4 is the standard, and returns actual important values */
        if (mode == 8) /* Test mode */
           {
           if (offset == 0)
              return 6;
           if (offset == 1)
              return 9;
           return mem_map1[MEM_ROMRAM + usAddr];
           }
         if (1)
           {
           switch (offset)
              {
              case 0:         /* DSW A, low nibble */
               c = GaplusOptions[2].iChoice; /* credits/coin */
               c |= GaplusOptions[3].iChoice << 2; /* Fighters */
               return c;

              case 1:         /* DSW B, high nibble */
               c = GaplusOptions[4].iChoice; /* Bonus Ship */
               c |= GaplusOptions[5].iChoice << 3; /* Round Advance */
               return c;

              case 2:         /* DSW B, low nibble */
               c = GaplusOptions[6].iChoice; /* Difficulty */
               c |= GaplusOptions[7].iChoice << 3; /* Test Mode */
               return c;

              case 3:         /* DSW A, high nibble */
               c = GaplusOptions[0].iChoice; /* Coin #2 */
               c |= GaplusOptions[1].iChoice << 2;  /* Demo Sounds */
               return c;

              default:
                  return 0; // DEBUG
              }
        }

        /* by default, return what was stored there */
    return mem_map1[MEM_ROMRAM + usAddr];
} /* gaplus_customio_r_2() */

unsigned char Galaga3IORead3(int usAddr)
{
unsigned char c;
unsigned char mode = mem_map1[MEM_ROMRAM + 0x6828];

if (mode != 2) /* Test mode ? */
   {
   switch (usAddr & 0xf)
      {
      case 0:
         c = 5; /* Force Upright mode + bit 0 is active low TILT */
         c |= (Galaga3Options[7].iChoice << 3); /* test mode (8=OFF, 0=ON) */
         return c;
      case 1:
         return 0x0f;
      case 2:
         return 0x0e;
      case 3:
         return 0x01;
      default:
         return mem_map1[MEM_ROMRAM + usAddr];
      }
   }
else /* Mode == 2 */
   {
   switch (usAddr & 0xf)
      {
      case 0:
         c = 5; /* Force Upright mode + bit 0 is active low TILT */
         c |= (Galaga3Options[7].iChoice << 3); /* test mode (8=OFF, 0=ON) */
         return c;
      case 2:
         return 0xf;
      default:
         return mem_map1[MEM_ROMRAM + usAddr];
      }
   }
//if (mode == 0)
//   return 0xf;
return mem_map1[MEM_ROMRAM + usAddr];
} /* Galaga3IORead3() */

unsigned char Galaga3IORead1(int usAddr)
{
    static long lOld2, lOld;
    unsigned char c;
    int offset, val, mode;
    
    mode = mem_map1[MEM_ROMRAM + 0x6808];

    offset = usAddr & 0xf;

        if (mode == 8) /* Test mode for Galaga3? */
           {
           if (offset == 0)
              return 6;
           if (offset == 1)
              return 9;
           return mem_map1[MEM_ROMRAM + usAddr];
           }


        /* mode 3 is the standard, and returns actual important values */
        if (mode == 1)
        {
                switch (offset)
                {
                        case 0:         /* Coin slots, low nibble of port 4 */
                        {
                        static int count = 5;
                        val = 0;
                        if (ulKeys & RKEY_COIN1 && !(lOld2 & RKEY_COIN1)) /* Coin 1 */
                           {
                           count = 0;
                           credits++;
                           }
                        lOld2 = ulKeys;
/* Galaga3 tests coin A,B,C sequentially and wants to see each coin active for two vblanks */
/* So in order to see coin A we have to leave the bit on for 4 consecutive reads */
                        if (++count < 5) /* It wants to see the coin in the slot for at least 2 cycles */
                           val = 1;
                        return val;
                        }

                        case 3:         /* Start & fire buttons */
                        {
                        val = 0;
                        if (ulKeys & RKEY_BUTT1_P1 && !(lOld & RKEY_BUTT1_P1)) /* button 1 */
                           val |= 1;
//                        if (lOld & RKEY_BUTT1_P1 && !(ulKeys & RKEY_BUTT1_P1)) /* button 1 - previous value */
//                           val |= 2;
                        if (ulKeys & RKEY_P1_START)// && !(lOld & RKEY_P1_START)) /* Player 1 start */
                           val |= 4;
                        if (ulKeys & RKEY_P2_START)// && !(lOld & RKEY_P2_START)) /* Player 2 start */
                           val |= 8;
                        lOld = ulKeys;
                        return val;
                        }

                        case 2:         /* Player 2 controls */
                c = 0;
//                if (ulKeys & RKEY_LEFT_P1) /* Left */
//                   c |= 8;
//                if (ulKeys & RKEY_DOWN_P1) /* Down */
//                   c |= 4;
//                if (ulKeys & RKEY_RIGHT_P1) /* Right */
//                   c |= 2;
//                if (ulKeys & RKEY_UP_P1) /* Down */
//                   c |= 1;
                return c;

                case 1:         /* Player 1 joystick */
                c = 0;
                if (ulKeys & RKEY_LEFT_P1) /* Left */
                   c |= 8;
                if (ulKeys & RKEY_DOWN_P1) /* Down */
                   c |= 4;
                if (ulKeys & RKEY_RIGHT_P1) /* Right */
                   c |= 2;
                if (ulKeys & RKEY_UP_P1) /* Up */
                   c |= 1;
                return c;

                default:
                   return mem_map1[MEM_ROMRAM + usAddr];
                }
        }

        /* by default, return what was stored there */
        return mem_map1[MEM_ROMRAM + usAddr];
} /* Galaga3IORead1() */

unsigned char Galaga3IORead2(int usAddr)
{
    unsigned char c;
    int offset, mode;
    
    mode = mem_map1[MEM_ROMRAM + 0x6818];

    offset = usAddr & 0xf;

        if (mode == 5) /* Some test mode on Galaga3 ? */
           {
           switch (offset)
              {
              case 0:
              case 1:
                 return 0xf;
              default:
                 return mem_map1[MEM_ROMRAM + usAddr];
              }
           }
        if (mode == 4)
           {
           switch (offset)
              {
              case 1:         /* DSW B, high nibble */
               c = Galaga3Options[2].iChoice; /* credits/coin A */
               c |= Galaga3Options[3].iChoice << 2; /* Fighters */
               return c;

              case 2:         /* DSW B, low nibble */
               c = Galaga3Options[4].iChoice; /* Bonus Ship */
               return c;

              case 4:
                return Galaga3Options[6].iChoice; /* Difficulty */
              case 7:
                 return Galaga3Options[0].iChoice; /* credits/coin B */
              default:
                  return mem_map1[MEM_ROMRAM + usAddr];
              }
        }

        /* by default, return what was stored there */
    return mem_map1[MEM_ROMRAM + usAddr];
} /* Galaga3IORead2() */

unsigned char PacLandIORead(int usAddr)
{
unsigned char c;

   switch (usAddr)
      {
      case 0xd000: /* DSW0 */
         c = PacLandOptions[0].iChoice; /* Coin slot 2 */
         c |= PacLandOptions[1].iChoice << 2; /* Demo Sounds */
         c |= PacLandOptions[2].iChoice << 3; /* Coin Slot 1 */
         c |= PacLandOptions[3].iChoice << 5; /* Lives */
         c |= PacLandOptions[4].iChoice << 7; /* Self Test Mode */
         return 255-c;
      case 0xd001: /* DSW1 */
         c = PacLandOptions[5].iChoice; /* Start level select */
         c |= PacLandOptions[6].iChoice << 2; /* Round Select */
         c |= PacLandOptions[7].iChoice << 3; /* Difficulty */
         c |= PacLandOptions[8].iChoice << 5; /* Bonus Life */
         return 255-c;
      case 0xd002: /* Input 1 */
         c = 0xff;
         if (ulKeys & RKEY_DOWN_P1)
            c ^= 1;
         if (ulKeys & RKEY_UP_P1)
            c ^= 2;
         if (ulKeys & RKEY_P1_START)
            c ^= 0x10;
         if (ulKeys & RKEY_P2_START)
            c ^= 0x20;
         return c;
      case 0xd003: /* Input 2 */
         c = 0xff;
         if (ulKeys & RKEY_COIN1)
            c ^= 0x40;
         return c;
      }
   return -1;
} /* PacLandIORead() */
unsigned char PacLandHDRead(int usAddr) /* Read another IO port here */
{
unsigned char c;

    c = 0xff;
    if (ulKeys & RKEY_BUTT1_P1)
       c ^= 0x8;
    if (ulKeys & RKEY_LEFT_P1)
       c ^= 0x10;
    if (ulKeys & RKEY_RIGHT_P1)
       c ^= 0x20;
    return c;

} /* PacLandHDRead() */

unsigned char PacLandSharedRead(int usAddr)
{
return mem_map1[MEM_ROMRAM + usAddr + 0x5800]; /* MCU 0x1000-0x13FF mapped to CPU 0x6800-0x6BFF */
} /* PacLandSharedRead() */

void PacLandSharedWrite(int usAddr,unsigned char ucByte)
{
   mem_map1[MEM_ROMRAM + usAddr + 0x5800] = ucByte;
} /* PacLandSharedWrite() */

void SkyHaltWrite(int usAddr,unsigned char ucByte)
{
   if (usAddr == 0x8000) /* Let it run */
      {
      RESET6803(&regs2a);
      skykidstruct.cCPUEnable = 1;
      mem_map1[MEM_ROMRAM + 0x6982] = 0xa6;
      mem_map1[MEM_ROMRAM + 0x6983] = 0x00;
      mem_map1[MEM_ROMRAM + 0x6984] = 0xa6;
      mem_map1[MEM_ROMRAM + 0x6985] = 0x00;
		/* Init timer A */
//      mem_map2[MEM_ROMRAM + 0x08] &= 0xf7; /* bit 3 (int enable) cleared at reset */
//      mem_map2[MEM_ROMRAM + 0x09] = 0;
//      mem_map2[MEM_ROMRAM + 0x0a] = 0;
      /* Output compare regs set to 0xffff during reset */
//      mem_map2[MEM_ROMRAM + 0x0b] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x0c] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1a] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1b] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1c] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1d] = 0xff;
      }
   else /* Halt the MCU */
      {
	   skykidstruct.cCPUEnable = 0;
      }
} /* SkyHaltWrite() */

void MetroScrollWrite(int usAddr, unsigned char ucByte)
{
mem_map1[usAddr] = ucByte;
switch (usAddr & 3)
   {
   case 0: /* High byte of X scroll */
	   skykidstruct.iScroll0 = (skykidstruct.iScroll0 & 0xff) | ((ucByte & 1)<<8);
      break;
   case 1: /* Low byte of X scroll */
	   skykidstruct.iScroll0 = (skykidstruct.iScroll0 & 0xff00) | ucByte;
      break;
   case 2: /* Low byte of Y scroll */
      iScroll1 = ucByte;
      break;
   }
} /* MetroScrollWrite() */

void MetroScrollWrite2(int usAddr, unsigned char ucByte)
{
mem_map1[usAddr] = ucByte;
switch (usAddr & 3)
   {
   case 0: /* High byte of X scroll */
      iScroll2 = (iScroll2 & 0xff) | ((ucByte & 1)<<8);
      break;
   case 1: /* Low byte of X scroll */
      iScroll2 = (iScroll2 & 0xff00) | ucByte;
      break;
   case 2: /* Low byte of Y scroll */
      iScroll3 = ucByte;
      break;
   }
} /* MetroScrollWrite2() */

unsigned char MetroSharedRead(int usAddr)
{
return mem_map1[MEM_ROMRAM + usAddr + 0x3000]; /* MCU 0x1000-0x13FF mapped to CPU 0x4000-0x43FF */
} /* MetroSharedRead() */

void MetroSharedWrite(int usAddr,unsigned char ucByte)
{
   mem_map1[MEM_ROMRAM + usAddr + 0x3000] = ucByte;
} /* MetroSharedWrite() */

void MetroHaltWrite(int usAddr,unsigned char ucByte)
{
   if (usAddr == 0x8000) /* Let it run */
      {
      RESET6803(&regs2a);
      skykidstruct.cCPUEnable = 1;
//      mem_map1[MEM_ROMRAM + 0x4182] = 0xa6;
//      mem_map1[MEM_ROMRAM + 0x4183] = 0x00;
//      mem_map1[MEM_ROMRAM + 0x4184] = 0xa6;
//      mem_map1[MEM_ROMRAM + 0x4185] = 0x00;
      }
   else /* Halt the MCU */
      {
	   skykidstruct.cCPUEnable = 0;
      }
} /* MetroHaltWrite() */

void PacLandHaltWrite(int usAddr,unsigned char ucByte)
{
   if (usAddr == 0x8000) /* Let it run */
      {
      RESET6803(&regs2a);
      skykidstruct.cCPUEnable = 1;
		/* Init timer A */
//      mem_map2[MEM_ROMRAM + 0x08] &= 0xf7; /* bit 3 (int enable) cleared at reset */
//      mem_map2[MEM_ROMRAM + 0x09] = 0;
//      mem_map2[MEM_ROMRAM + 0x0a] = 0;
      /* Output compare regs set to 0xffff during reset */
//      mem_map2[MEM_ROMRAM + 0x0b] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x0c] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1a] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1b] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1c] = 0xff;
//      mem_map2[MEM_ROMRAM + 0x1d] = 0xff;
      }
   else /* Halt the MCU */
      {
	   skykidstruct.cCPUEnable = 0;
      }
} /* PacLandHaltWrite() */

void PacLandScroll0Write(int usAddr,unsigned char ucByte)
{
	skykidstruct.iScroll0 = ucByte + 256 * (usAddr & 1);

} /* PacLandScroll0Write() */

void PacLandScroll1Write(int usAddr,unsigned char ucByte)
{
   iScroll1 = ucByte + 256 * (usAddr & 1);

} /* PacLandScroll1Write() */

unsigned char SkyBankRead(int usAddr)
{
return pBanked[usAddr + iROMBank];
} /* SkyBankRead() */

void SkyBankWrite(int usAddr,unsigned char ucByte)
{
unsigned char c;

   if ((usAddr & 0x800) == 0)
      c = 1;
   else
      c = 0;
   if (c != skykidstruct.cROMBank) /* ROM Bank changed, update memory */
      {
      skykidstruct.cROMBank = c;
//      iROMBank = c << 13;
      memcpy(&mem_map1[0x0000], &pBanked[skykidstruct.cROMBank << 13], 0x2000); /* Copy in this bank */
      }

} /* SkyBankWrite() */

void PacLandBankSwitchWrite(int usAddr,unsigned char ucByte)
{
unsigned char c;
int i;

   c = ucByte & 7;
   if (c != cROMBank) /* ROM Bank changed, update memory */
      {
      cROMBank = c;
      memcpy(&mem_map1[MEM_ROMRAM + 0x4000], &pBanked[cROMBank << 13], 0x2000); /* Copy in this bank */
//      MessageBeep(0); /* DEBUG - check how frequently it occurs */
      }
   c = (ucByte & 0x18) >> 3;
   if (c != cPaletteBank) /* Color palette changed */
      {
      cPaletteBank = c;
      for (i=0; i<256; i++)
         {
         EMUUpdatePalette(i, &pPalettes[cPaletteBank*256 + i]);
         }
      }

} /* PacLandBankSwitchWrite() */

void SkyVideoWrite(int usAddr,unsigned char ucByte)
{
//   if (mem_map1[MEM_ROMRAM + usAddr] != ucByte)
//      {
      mem_map1[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[usAddr & 0x7ff] = 1;
//      }
} /* SkyVideoWrite() */

void PacLandVideoWrite(int usAddr,unsigned char ucByte)
{
   if (mem_map1[MEM_ROMRAM + usAddr] != ucByte)
      {
      mem_map1[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[usAddr >> 1] = 1;
      }
} /* PacLandVideoWrite() */

void MetroVideoWrite(int usAddr,unsigned char ucByte)
{
//   if (mem_map1[MEM_ROMRAM + usAddr] != ucByte)
//      {
      mem_map1[MEM_ROMRAM + usAddr] = ucByte;
      cDirtyChar[(usAddr & 0x1fff) >> 1] = 1;
//      }
} /* MetroVideoWrite() */

void MetroVideoWrite2(int usAddr,unsigned char ucByte)
{
   if (mem_map1[MEM_ROMRAM + usAddr] != ucByte)
      {
      mem_map1[MEM_ROMRAM + usAddr] = ucByte;
//      lDirtyRect |= 1<<(iCharY[usAddr - 0x4800]>>3);
      }
} /* MetroVideoWrite() */

#ifdef FUTURE
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusLoadSave(int, BOOL)                                  *
 *                                                                          *
 *  PURPOSE    : Load or save the current game state.                       *
 *                                                                          *
 ****************************************************************************/
BOOL GaplusLoadSave(int iGame, BOOL bLoad)
{
char cTemp1[256], cTemp2[256];
int i;

   i = sizeof(REGS6809);
   if (bLoad)
      {
//      if (EMULoadState(iGame, mem_map1, (char *)cTemp1, 256, (char *)&cTemp2, 256))
//         return FALSE;
      memcpy(&mem_map3[MEM_ROMRAM], &mem_map1[MEM_ROMRAM + 0x6000], 0x40); /* Get the sound info into CPU#3's space */
      cIRQEnable1 = cTemp1[0];
      cIRQEnable2 = cTemp1[1];
      cIRQEnable3 = cTemp1[2];
      memcpy(cVolume, &cTemp1[3], 1*8);
      memcpy(iFreq, &cTemp1[11], 4*8);
      memcpy(pWave, &cTemp1[43], 4*8);
      memcpy(iPosition, &cTemp1[65], 4*8);

      memcpy(&regs1,cTemp2,i);
      memcpy(&regs2,&cTemp2[i],i);
      memcpy(&regs3,&cTemp2[2*i],i);
      memset(cDirtyChar,1,1024); /* Force a total redraw */
      }
   else
      {
      cTemp1[0] = cIRQEnable1;
      cTemp1[1] = cIRQEnable2;
      cTemp1[2] = cIRQEnable3;
      memcpy(&cTemp1[3], cVolume, 1*8);
      memcpy(&cTemp1[11], iFreq, 4*8);
      memcpy(&cTemp1[43], pWave, 4*8);
      memcpy(&cTemp1[65], iPosition, 4*8);

      memcpy(cTemp2,&regs1, i);
      memcpy(&cTemp2[i],&regs2, i);
      memcpy(&cTemp2[2*i],&regs3, i);
      memcpy(&mem_map1[MEM_ROMRAM + 0x6000], &mem_map3[MEM_ROMRAM], 0x40); /* Put sound data in CPU#1's space */
//      EMUSaveState(iGame, mem_map1, (char *)cTemp1, 256, (char *)&cTemp2, 256);
      }
   return TRUE;
} /* GaplusLoadSave() */
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SkyKidLoadSave(int, BOOL)                                  *
 *                                                                          *
 *  PURPOSE    : Load or save the current game state.                       *
 *                                                                          *
 ****************************************************************************/
BOOL SkyKidLoadSave(int iGame, BOOL bLoad)
{
char cTemp1[256] = {0};
int i;

   i = sizeof(REGS6809);
   if (bLoad)
      {
//      if (EMULoadState(iGame, mem_map1, (char *)cTemp1, 256, NULL, 0))
//         return FALSE;
      cIRQEnable1 = cTemp1[0];
      cIRQEnable2 = cTemp1[1];
      skykidstruct.cCPUEnable = cTemp1[2];
      cIOMode = cTemp1[3];
      memcpy(cVolume, &cTemp1[4], 1*8);
      memcpy(iFreq, &cTemp1[12], 4*8);
      memcpy(pWave, &cTemp1[44], 4*8);
      memcpy(iPosition, &cTemp1[66], 4*8);

      memcpy(&regs1,&cTemp1[98],i);
      memcpy(&regs2a,&cTemp1[98+i],sizeof(REGS6800));
      memset(cDirtyChar,1,2048); /* Force a total redraw */
 /* Restore RAM of CPU 2 from unused areas of CPU 1 */
      memcpy(&mem_map2[MEM_ROMRAM + 0x0000], &mem_map1[MEM_ROMRAM + 0x3000], 0x100);
      memcpy(&mem_map2[MEM_ROMRAM + 0xc000], &mem_map1[MEM_ROMRAM + 0x3100], 0x800);
      }
   else
      {
      cTemp1[0] = cIRQEnable1;
      cTemp1[1] = cIRQEnable2;
      cTemp1[2] = skykidstruct.cCPUEnable;
      cTemp1[3] = cIOMode;
      memcpy(&cTemp1[4], cVolume, 1*8);
      memcpy(&cTemp1[12], iFreq, 4*8);
      memcpy(&cTemp1[44], pWave, 4*8);
      memcpy(&cTemp1[66], iPosition, 4*8);

      memcpy(&cTemp1[98],&regs1, i);
      memcpy(&cTemp1[98+i],&regs2a, sizeof(REGS6800));
 /* Save RAM of CPU 2 in unused areas of CPU 1 */
      memcpy(&mem_map1[MEM_ROMRAM + 0x3000], &mem_map2[MEM_ROMRAM + 0x0000], 0x100);
      memcpy(&mem_map1[MEM_ROMRAM + 0x3100], &mem_map2[MEM_ROMRAM + 0xc000], 0x800);
//      EMUSaveState(iGame, mem_map1, (char *)cTemp1, 256, NULL, 0);
      }
   return TRUE;
} /* SkyKidLoadSave() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MetroCrossLoadSave(int, BOOL)                              *
 *                                                                          *
 *  PURPOSE    : Load or save the current game state.                       *
 *                                                                          *
 ****************************************************************************/
BOOL MetroCrossLoadSave(int iGame, BOOL bLoad)
{
char cTemp1[256] = {0};
int i;

   i = sizeof(REGS6809);
   if (bLoad)
      {
//      if (EMULoadState(iGame, mem_map1, (char *)cTemp1, 256, NULL, 0))
//         return FALSE;
      cIRQEnable1 = cTemp1[0];
      cIRQEnable2 = cTemp1[1];
      skykidstruct.cCPUEnable = cTemp1[2];
      cIOMode = cTemp1[3];
      memcpy(cVolume, &cTemp1[4], 1*8);
      memcpy(iFreq, &cTemp1[12], 4*8);
      memcpy(pWave, &cTemp1[44], 4*8);
      memcpy(iPosition, &cTemp1[66], 4*8);

      memcpy(&regs1,&cTemp1[98],i);
      memcpy(&regs2a,&cTemp1[98+i],sizeof(REGS6800));
      memset(cDirtyChar,1,4096); /* Force a total redraw */
 /* Restore RAM of CPU 2 from unused areas of CPU 1 */
      memcpy(&mem_map2[MEM_ROMRAM + 0x0000], &mem_map1[MEM_ROMRAM + 0x5000], 0x100);
      memcpy(&mem_map2[MEM_ROMRAM + 0xc000], &mem_map1[MEM_ROMRAM + 0x5100], 0x800);
//      lDirtyRect = -1; /* Force a total repaint */
      }
   else
      {
      cTemp1[0] = cIRQEnable1;
      cTemp1[1] = cIRQEnable2;
      cTemp1[2] = skykidstruct.cCPUEnable;
      cTemp1[3] = cIOMode;
      memcpy(&cTemp1[4], cVolume, 1*8);
      memcpy(&cTemp1[12], iFreq, 4*8);
      memcpy(&cTemp1[44], pWave, 4*8);
      memcpy(&cTemp1[66], iPosition, 4*8);

      memcpy(&cTemp1[98],&regs1, i);
      memcpy(&cTemp1[98+i],&regs2a, sizeof(REGS6800));
 /* Save RAM of CPU 2 in unused areas of CPU 1 */
      memcpy(&mem_map1[MEM_ROMRAM + 0x5000], &mem_map2[MEM_ROMRAM + 0x0000], 0x100);
      memcpy(&mem_map1[MEM_ROMRAM + 0x5100], &mem_map2[MEM_ROMRAM + 0xc000], 0x800);
//      EMUSaveState(iGame, mem_map1, (char *)cTemp1, 256, NULL, 0);
      }
   return TRUE;
} /* MetroCrossLoadSave() */
#endif

/* Initialization function */
void GaplusInit(void)
{
int i, x, y, mx, my;

   credits = 0; /* No quarters yet */
/* Create a lookup table for character positions from addresses */
   for (i=0; i<1024; i++)
      {
      my = i & 0x1f;
      mx = i >> 5;
      if (mx <= 1)
         {
         x = 29 - my;
         y = mx + 34;
         }
      else if (mx >= 30)
         {
         x = 29 - my;
         y = mx - 30;
         }
      else
         {
         x = 29 - mx;
         y = my + 2;
         }
/* Use the second part of charx to mark chars which need a repaint after being clobbered by a sprite */
      if (x >= 0 && x <28 && y >= 0 && y < 36)
         iCharX[2048 + y*28+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      iCharX[i] = x;
      iCharY[i] = y;
      if (x >=0 && x <223 && y>=0 && y<287)
         lCharAddr[i] = (unsigned long)&pCoinOpBitmap[y*iCoinOpPitch+x]; /* Convert game's video address into screen address */
      else
         lCharAddr[i] = 0; /* Non-visible areas */
      }

/* Initialize the stars */
   pStars = (STARS *)EMUAlloc(NUM_STARS * sizeof(STARS));

   for (i=0; i<NUM_STARS; i++)
      {
      pStars[i].x = EMURand() % 224;
      pStars[i].y = EMURand() % 256;
      pStars[i].color = 144 + (EMURand() % 11);
      pStars[i].speed = (EMURand() % 3); /* 0-2 = shift */
      pStars[i].oldcolor = 0;
      }

} /* GaplusInit() */

/* Initialization function */
void PacLandInit(void)
{
int i, x, y;

   cROMBank = cPaletteBank = -1; /* Make sure the first write sets these properly */
   skykidstruct.iScroll0 = iScroll1 = 0;
   credits = 0; /* No quarters yet */
   skykidstruct.cCPUEnable = 1;
/* Create a lookup table for character positions from addresses */
   for (i=0; i<2048; i++)
      {
      x = (i - 3) & 0x3f;
      y = (i >> 6) - 2;
/* Use the second part of charx to mark chars which need a repaint after being clobbered by a sprite */
//      if (x >= 0 && x <36 && y >= 0 && y < 28)
//         iCharX[2048 + y*36+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      iCharX[i] = x;
      iCharY[i] = y;
      if (x >=0 && x <288 && ((y>=0 && y<24) || (y >215 && y < 224)))
         {
         lCharAddr[i] = (unsigned long)&pCoinOpBitmap[y*iCoinOpPitch+x]; /* Convert game's video address into screen address */
         lCharAddr[i+2048] = (unsigned long)&pCoinOpBitmap[y*iCoinOpPitch+x]; /* Convert game's video address into screen address */
         }
      else
      if (x >=0 && x <512 && y>=24 && y<224)
         {
         lCharAddr[i] = (unsigned long)&pForeground[y*512+x]; /* Convert game's video address into screen address */
         lCharAddr[i+2048] = (unsigned long)&pBackground[y*512+x]; /* Convert game's video address into screen address */
         }
      else
         {
         lCharAddr[i] = 0; /* Non-visible areas */
         lCharAddr[i+2048] = 0; /* Non-visible areas */
         }
      }

} /* PacLandInit() */

/* Initialization function */
void MetroInit(void)
{
int i, x, y, mx, my;

skykidstruct.iScroll0 = iScroll1 = iScroll2 = iScroll3 = 0;
   skykidstruct.cCPUEnable = 0;
/* Clear out any pressed keys before beginning */
/* Create a lookup table for character positions from addresses */
   for (i=0; i<2048; i++)
      {
      x = i & 0x3f;
      y = i >> 6;
/* Use the second part of charx to mark chars which need a repaint after being clobbered by a sprite */
//      if (x >= 0 && x <36 && y >= 0 && y < 28)
//         iCharX[2048 + y*36+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      iCharX[i] = x;
      iCharY[i] = y;
      if (x >=0 && x <512 && y>=0 && y<256)
         {
         lCharAddr[i] = (unsigned long)&pForeground[y*512+x]; /* Convert game's video address into screen address */
         lCharAddr[i+2048] = (unsigned long)&pBackground[y*512+x]; /* Convert game's video address into screen address */
         }
      else
         {
         lCharAddr[i] = 0; /* Non-visible areas */
         lCharAddr[i+2048] = 0; /* Non-visible areas */
         }
      }
/* Create a lookup table for character positions from addresses (foreground) */
   for (i=0; i<1024; i++)
      {
      my = i & 0x1f;
      mx = i >> 5;
      if (mx <= 1)
         {
         x = 29 - my;
         y = mx + 34;
         }
      else if (mx >= 30)
         {
         x = 29 - my;
         y = mx - 30;
         }
      else
         {
         x = 29 - mx;
         y = my + 2;
         }
/* Use the second part of charx to mark chars which need a repaint after being clobbered by a sprite */
//      if (x >= 0 && x <28 && y >= 0 && y < 36)
//         iCharX[2048 + y*28+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      mx = y;
      my = x;
      x = mx;
      y = 216 - my;
      iCharX[i] = x;
      iCharY[i] = y;
      if (y >=0 && y <223 && x>=0 && x<287)
         lCharAddr2[i] = (unsigned long)&pCoinOpBitmap[y*iCoinOpPitch+x]; /* Convert game's video address into screen address */
      else
         lCharAddr2[i] = 0; /* Non-visible areas */
      }

} /* MetroInit() */

/* Initialization function */
void SkyKidInit(void)
{
int i, mx, my, x, y;

   cPaletteBank = -1; /* Make sure the first write sets these properly */
   skykidstruct.cROMBank = iROMBank = 0;
   skykidstruct.iScroll0 = 0;
   credits = 0; /* No quarters yet */
   skykidstruct.cCPUEnable = 0;
/* Create a lookup table for character positions from addresses (background) */
   for (i=0; i<2048; i++)
      {
      x = i & 0x3f;
      y = (i >> 6) - 2;
      x <<= 3;
      y <<= 3;
      if (y >= 0 && y < 224)
         lCharAddr[i+0x400] = (unsigned long)&pBackground[y*512+x];
      else
         lCharAddr[i+0x400] = 0;
      }
/* Create a lookup table for character positions from addresses (foreground) */
   for (i=0; i<1024; i++)
      {
      my = i & 0x1f;
      mx = i >> 5;
      if (mx <= 1)
         {
         x = 29 - my;
         y = mx + 34;
         }
      else if (mx >= 30)
         {
         x = 29 - my;
         y = mx - 30;
         }
      else
         {
         x = 29 - mx;
         y = my + 2;
         }
/* Use the second part of charx to mark chars which need a repaint after being clobbered by a sprite */
//      if (x >= 0 && x <28 && y >= 0 && y < 36)
//         iCharX[2048 + y*28+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      mx = y;
      my = x;
      x = mx;
      y = 216 - my;
      iCharX[i] = x;
      iCharY[i] = y;
      if (y >=0 && y <223 && x>=0 && x<287)
         lCharAddr[i] = (unsigned long)&pCoinOpBitmap[y*iCoinOpPitch+x]; /* Convert game's video address into screen address */
      else
         lCharAddr[i] = 0; /* Non-visible areas */
      }

} /* SkyKidInit() */


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusExpWrite(unsigned short, unsigned char)              *
 *                                                                          *
 *  PURPOSE    : Write a byte to the sound hardware.                        *
 *                                                                          *
 ****************************************************************************/
void GaplusExpWrite(int usAddr, unsigned char ucByte)
{

   if (usAddr == 0x6829 && (ucByte & 0x10)) /* Ship exploding */
      {
//      if (pSounds) /* If sample loaded, play it */
//         {
//         pSounds[0].iPos = 0;
//         pSounds[0].bActive = TRUE;
//         }
      }
   mem_map1[MEM_ROMRAM + usAddr] = ucByte;
} /* GaplusExpWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusStuffWrite(unsigned short, unsigned char)            *
 *                                                                          *
 *  PURPOSE    : Write a byte to the shared custom IO chip memory.          *
 *                                                                          *
 ****************************************************************************/
void GaplusStuffWrite(int usAddr, unsigned char ucByte)
{
   mem_map1[MEM_ROMRAM + usAddr] = ucByte;
} /* GaplusStuffWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusSharedRead(unsigned short)                           *
 *                                                                          *
 *  PURPOSE    : Read the shared video memory area.                         *
 *                                                                          *
 ****************************************************************************/
unsigned char GaplusSharedRead(int usAddr)
{
   return mem_map1[MEM_ROMRAM + usAddr];
} /* GaplusSharedRead() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusVideoWrite(unsigned short, unsigned char)            *
 *                                                                          *
 *  PURPOSE    : Write a byte to video memory, update display bitmap.       *
 *                                                                          *
 ****************************************************************************/
void GaplusVideoWrite(int usAddr, unsigned char ucByte)
{

   if (mem_map1[MEM_ROMRAM + usAddr] == ucByte)
     return; /* Nothing to do */

   cDirtyChar[usAddr & 0x3ff] = 1; /* Mark this as needing a redraw */
   mem_map1[MEM_ROMRAM + usAddr] = ucByte; /* Store the new character */

} /* GaplusVideoWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusConvertChars(void)                                   *
 *                                                                          *
 *  PURPOSE    : Convert the Gaplus character ROMs into a more usable form. *
 *                                                                          *
 ****************************************************************************/
void GaplusConvertChars(void)
{
unsigned char *pTemp;

   pTemp = (unsigned char *)EMUAlloc(0x20000); /* 32K for my expanded version of the character map */
/* Convert the 256 characters */
   EMUDecodeGFX(&gaplusgfx0, 256, (char *)mem_sprites, (char *)pTemp, FALSE);
   EMUDecodeGFX(&gaplusgfx1, 256, (char *)mem_sprites, (char *)&pTemp[0x4000], FALSE);
/* Convert the 128 Sprites */
   EMUDecodeGFX(&gaplusgfx2, 128, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x8000], FALSE);
   EMUDecodeGFX(&gaplusgfx3, 128, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x10000], FALSE);
   EMUDecodeGFX(&gaplusgfx4, 128, (char *)&mem_sprites[0x8000], (char *)&pTemp[0x18000], FALSE);

/* Copy the data back into the other map & free temp */
   memcpy(mem_sprites, pTemp, 0x20000);
   EMUFree(pTemp);

} /* GaplusConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacLandConvertChars(void)                                  *
 *                                                                          *
 *  PURPOSE    : Convert the PacLand character ROMs into a more usable form.*
 *                                                                          *
 ****************************************************************************/
void PacLandConvertChars(void)
{
register int x, y;
int i, iBit, iByte;
unsigned char *p, *d, *pTemp, ucTemp;

   pTemp = (unsigned char *)EMUAlloc(0x60000);
/* Convert 1024 characters */
   for (i=0; i<1024; i++)
      {
      d = &pTemp[i * 64]; /* 64 bytes per converted character */
      p = &mem_sprites[i * 16];  /* 16 bytes per original character */
      for (x=0; x<8; x++)
         {
         for (y=0; y<8; y++)
            {
            ucTemp = 0;
            iBit = cPacXOff[x] + cPacYOff[y];
            iByte = iBit >> 3;  /* Get the byte and bit offset of what we care about */
            iBit &= 7;
            if (p[iByte] & (1<<(iBit)))  /* Bit 0 */
               ucTemp += 1;
            if (p[iByte] & (1<<(4+iBit)))  /* Bit 1 */
               ucTemp += 2;
            d[y*8+x] = ucTemp;
            } /* for y */
         } /* for x */
      } /* for i */
/* Copy the characters into 4 orientations for faster drawing */
/* order = normal, mirrored X, mirrored Y, mirrored X+Y */
   for (i=0; i<1024; i++)
      {
      p = &pTemp[i*64]; /* Source character info */
      for (y=0; y<8; y++)
         {
         for (x=0; x<8; x++)
            {
            ucTemp = p[y*8+x];
            p[0x10000 + y*8 + (7-x)] = ucTemp; /* Mirrored X */
            p[0x20000 + (7-y)*8 + x] = ucTemp; /* Mirrored Y */
            p[0x30000 + (7-y)*8 + (7-x)] = ucTemp; /* Mirrored X+Y */
            }
         }
      }

/* Convert the 512 Sprites */
   for (i=0; i<256; i++)
      {
      d = &pTemp[0x40000 + (i * 256)]; /* 256 bytes per converted sprite */
      p = &mem_sprites[0x4000 + (i * 64)];  /* 64 bytes per original sprite */
      for (x=0; x<16; x++)
         {
         for (y=0; y<16; y++)
            {
            ucTemp = 0;
            iBit = iPacXOff2[x] + iPacYOff2[y];
            iByte = iBit >> 3;  /* Get the byte and bit offset of what we care about */
            iBit &= 7;
            if (p[iByte] & (1<<(iBit)))  /* Bit 0 */
               ucTemp += 4;
            if (p[iByte] & (1<<(4+iBit)))  /* Bit 1 */
               ucTemp += 8;
            if (p[iByte+0x4000] & (1<<(iBit)))  /* Bit 2 */
               ucTemp += 1;
            if (p[iByte+0x4000] & (1<<(4+iBit)))  /* Bit 3 */
               ucTemp += 2;
            d[y*16+x] = ucTemp;
            } /* for y */
         } /* for x */
      } /* for i */
   for (i=0; i<256; i++)
      {
      d = &pTemp[0x50000 + (i * 256)]; /* 256 bytes per converted sprite */
      p = &mem_sprites[0xC000 + (i * 64)];  /* 64 bytes per original sprite */
      for (x=0; x<16; x++)
         {
         for (y=0; y<16; y++)
            {
            ucTemp = 0;
            iBit = iPacXOff2[x] + iPacYOff2[y];
            iByte = iBit >> 3;  /* Get the byte and bit offset of what we care about */
            iBit &= 7;
            if (p[iByte] & (1<<(iBit)))  /* Bit 0 */
               ucTemp += 4;
            if (p[iByte] & (1<<(4+iBit)))  /* Bit 1 */
               ucTemp += 8;
            if (p[iByte+0x4000] & (1<<(iBit)))  /* Bit 2 */
               ucTemp += 1;
            if (p[iByte+0x4000] & (1<<(4+iBit)))  /* Bit 3 */
               ucTemp += 2;
            d[y*16+x] = ucTemp;
            } /* for y */
         } /* for x */
      } /* for i */


    /* Copy the data back into the other map & free temp */
    memcpy(mem_sprites, pTemp, 0x60000);
    EMUFree(pTemp);

} /* PacLandConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SkyKidConvertChars(void)                                   *
 *                                                                          *
 *  PURPOSE    : Convert the SkyKid character ROMs into a more usable form. *
 *                                                                          *
 ****************************************************************************/
void SkyKidConvertChars(void)
{
unsigned char *pTemp;

   pTemp = (unsigned char *)EMUAlloc(0x28000);

/* Convert 512 characters */
   EMUDecodeGFX(&bdgfx0, 512, (char *)mem_sprites, (char *)pTemp, FALSE);
/* Convert 512 tiles */
   EMUDecodeGFX(&skgfx1, 512, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x8000], FALSE);

/* Convert the 384 Sprites */
   EMUDecodeGFX(&skgfx2, 128, (char *)&mem_sprites[0x4000], (char *)&pTemp[0x10000], FALSE);
   EMUDecodeGFX(&skgfx3, 128, (char *)&mem_sprites[0x4000], (char *)&pTemp[0x18000], FALSE);
   EMUDecodeGFX(&skgfx4, 128, (char *)&mem_sprites[0x8000], (char *)&pTemp[0x20000], FALSE);

    /* Copy the data back into the other map & free temp */
    memcpy(mem_sprites, pTemp, 0x28000);
    EMUFree(pTemp);

} /* SkyKidConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DragBustConvertChars(void)                                 *
 *                                                                          *
 *  PURPOSE    : Convert the SkyKid character ROMs into a more usable form. *
 *                                                                          *
 ****************************************************************************/
void DragBustConvertChars(void)
{
unsigned char *pTemp;

   pTemp = (unsigned char *)EMUAlloc(0x28000);

/* Convert 512 characters */
   EMUDecodeGFX(&bdgfx0, 512, (char *)mem_sprites, (char *)pTemp, FALSE);
/* Convert 512 tiles */
   EMUDecodeGFX(&skgfx1, 512, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x8000], FALSE);

/* Convert the 384 Sprites */
   EMUDecodeGFX(&dbgfx1, 128, (char *)&mem_sprites[0x4000], (char *)&pTemp[0x10000], FALSE);
   EMUDecodeGFX(&dbgfx2, 128, (char *)&mem_sprites[0x4000], (char *)&pTemp[0x18000], FALSE);
//   EMUDecodeGFX(&skgfx3, 128, &mem_sprites[0x8000], &pTemp[0x20000], FALSE);

    /* Copy the data back into the other map & free temp */
   memcpy(mem_sprites, pTemp, 0x28000);
   EMUFree(pTemp);

} /* DragBustConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MetroCrossConvertChars(void)                               *
 *                                                                          *
 *  PURPOSE    : Convert the MetroCross graphics ROMs into a more usable form. *
 *                                                                          *
 ****************************************************************************/
void MetroCrossConvertChars(void)
{
unsigned char *pTemp;

    pTemp = (unsigned char *)EMUAlloc(0x50000);
    memset(&mem_sprites[0xa000], 0xff, 0x4000);
    EMUDecodeGFX(&bdgfx0, 512, (char *)mem_sprites, (char *)pTemp, FALSE);
    EMUDecodeGFX(&bdgfx1, 512, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x8000], FALSE);
    EMUDecodeGFX(&bdgfx2, 512, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x10000], FALSE);
    EMUDecodeGFX(&bdgfx3, 512, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x18000], FALSE);
    EMUDecodeGFX(&bdgfx4, 512, (char *)&mem_sprites[0x2000], (char *)&pTemp[0x20000], FALSE);

/* Convert the 512 Sprites */
    EMUDecodeGFX(&bdgfx5, 512, (char *)&mem_sprites[0xE000], (char *)&pTemp[0x28000], FALSE);

    /* Copy the data back into the other map & free temp */
    memcpy(mem_sprites, pTemp, 0x50000);
    EMUFree(pTemp);

} /* MetroCrossConvertChars() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PLPrepSounds(void)                                         *
 *                                                                          *
 *  PURPOSE    : Precalculate the sound waveforms to generate sound faster. *
 *                                                                          *
 ****************************************************************************/
void PLPrepSounds(int iShift)
{
signed char *p;
int v, j;

   p = pWaveforms; /* Destination of pre-calculated data */
   for (v=1; v<16; v++) /* Volume level */
      {
      for (j=0; j<512; j++) /* source data */
          {
          *p++ = ((((pSoundPROM[j] & 0x0f) - 8) * v) >> iShift); /* Do all necessary calculations beforehand */
          }
      }

} /* PLPrepSounds() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPSoundUpdate(void)                                        *
 *                                                                          *
 *  PURPOSE    : Create waveform data for the time slice last executed.     *
 *                                                                          *
 ****************************************************************************/
void SPSoundUpdate(signed short *pBuf, int iSampleCount)
{
int i; //, iInc;
int iVoice, f, v;
signed short *d;
signed short s;
signed char *p;

   d = (signed short *)pBuf;
   for (i=0; i<iSampleCount; i++)
      {
      s = 0x0;
      for (iVoice=0; iVoice<8; iVoice++)
         {
         f = iFreq[iVoice];
         v = cVolume[iVoice];
         if (f && v)
            {
            p = pWaveforms + pWave[iVoice] + (v-1)*256;
            s += p[(iPosition[iVoice] >> iAudioShift) & 0x1f];
            iPosition[iVoice] += f;
            } /* if voice is active */
         } /* for each voice */
      *d++ = (0x80 + (signed char)s) << 7;
      d++; // skip right channel for now
      } /* for each sample */
   d = pBuf; // copy left sample to right channel
   for (i=0; i<iSampleCount; i++)
   {
	   d[1] = d[0];
	   d += 2;
   }

} /* SPSoundUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PLSoundUpdate(void)                                        *
 *                                                                          *
 *  PURPOSE    : Create waveform data for the time slice last executed.     *
 *                                                                          *
 ****************************************************************************/
void PLSoundUpdate(signed short *pBuf, int iSampleCount)
{
int i, iPos; //, iInc;
int iVoice, f, v;
signed short *d;
unsigned char *p;

   memset(pBuf, 0, iSampleCount*4); /* Start buffer at level 0 to begin */

   for (iVoice=0; iVoice<8; iVoice++)
      {
      f = iFreq[iVoice];
      v = cVolume[iVoice];
      if (f && v)
         {
         d = pBuf;
         iPos = iPosition[iVoice];
         p = (unsigned char *)pWaveforms + pWave[iVoice] + (v-1)*512;
         for (i=0; i<iSampleCount; i++)
            {
            *d++ += (p[(iPos >> iAudioShift) & 0x1f]) << 8;
            d++; // skip right channel for now
            iPos += f;
            } /* for each sample */
         iPosition[iVoice] = iPos;
         } /* if voice active */
      } /* for iVoice */
//      if (pSounds && pSounds[0].bActive) /* If an explosion sample is loaded and active */
//         {
//         d = (signed char *)&pSoundBuf[iSoundLen];
//         iInc = 1<<(2-iSampleRate); /* To adjust for sample rate vs. playback rate */
//         for (i=0; i<iSampleCount; i++)
//            {
 //           *d++ += pSounds[0].pSound[pSounds[0].iPos] >> 2;
 //           pSounds[0].iPos += iInc;
 //           if (pSounds[0].iPos >= pSounds[0].iLen) /* Reached the end of this sample */
 //              {
 //              pSounds[0].bActive = FALSE;
 //              break;
 //              }
 //           } /* for */
 //        }
   d = pBuf; // copy left sample to right channel
   for (i=0; i<iSampleCount; i++)
   {
	   d[1] = d[0];
	   d += 2;
   }
} /* PLSoundUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PLSoundWrite(unsigned char *)                              *
 *                                                                          *
 *  PURPOSE    : CPU #2 creates sounds here.                                *
 *                                                                          *
 ****************************************************************************/
void PLSoundWrite(unsigned char *pSoundRegs)
{
int iVoice;


   for (iVoice=0; iVoice<8; iVoice++)
      {
      iFreq[iVoice] = 65536 * (pSoundRegs[1 + 8 * iVoice] & 15) + 256 * pSoundRegs[2 + 8 * iVoice] + pSoundRegs[3 + 8 * iVoice];
      iFreq[iVoice] = (iFreq[iVoice] * 1100)/1000;
      cVolume[iVoice] = pSoundRegs[0 + 8 * iVoice] & 0xf;
      if (iFreq[iVoice] == 0)
         {
         iFreq[iVoice] = 1000;
         cVolume[iVoice] = 0;
         }
      pWave[iVoice] = 32 * ((pSoundRegs[1 + 8 * iVoice] >> 4) & 15);
      }

} /* PLSoundWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacLandDrawSprites(int, int, int)                          *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
#define SpriteRAM1A 0x2700
#define SpriteRAM2A 0x2f00
#define SpriteRAM3A 0x3700
void PacLandDrawSprites(int iPriority)
{
int iOffset, iColor;
int x, y, iSprite;
BOOL bFlipx, bFlipy;
unsigned char c;

        for (iOffset=0; iOffset<128; iOffset += 2)  /* Up to 64 simultaneous sprites */
           {
         /* Is the sprite enabled? */
           y = 256 - mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2A] - 40;
       if (y >= 0) /* Use to detect active sprites */
          {
          x = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2A + 1]-72;  /* Sprite area #2 */
          x += 256 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3A + 1] & 1);
          iSprite = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1A]; /* Sprite area #1 */
/* Bit selecting upper set of 256 sprites */
          iSprite += 2 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3A] & 0x80);
          iColor = 64 * iPriority + (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1A + 1] & 0x3f);
          iColor *= 16;
          if (iSprite > 256)
             iColor += 2048; /* Select second set of colors */
          bFlipx = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3A] & 1;
          bFlipy = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3A] & 2;
          c = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3A] & 0xc;
          switch (c)
             {
             case 0:    /* Regular size */
                EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                break;
             case 0x8:    /* Double Height */
                iSprite &= ~2;  /* Make sure it's on an even number */
                if (bFlipy)
                   {
                   EMUDrawSprite2(x, y-16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                else
                   {
                   EMUDrawSprite2(x, y-16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                break;
             case 4:   /* Double Width */
                iSprite &= ~1;
                if (!bFlipx)
                   {
                   EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                else
                   {
                   EMUDrawSprite2(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                break;
             case 12:   /* Double height, double width */
                iSprite &= ~3;
                if (!bFlipy && !bFlipx)
                   {
                   EMUDrawSprite2(x, y-16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y-16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                else if (bFlipy && bFlipx)
                   {
                   EMUDrawSprite2(x, y-16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y-16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                else if (bFlipx)
                   {
                   EMUDrawSprite2(x, y-16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y-16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                else /* bFlipy */
                   {
                   EMUDrawSprite2(x, y-16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y-16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   EMUDrawSprite2(x+16, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x40000], pPLColors);
                   }
                break;
             } /* switch */
         } /* If sprite enabled */
       } /* for each of 128 possible sprites */
} /* PacLandDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SkyKidDrawSprites(int, int, int)                           *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
#define SpriteRAM1B 0x4F80
#define SpriteRAM2B 0x5780
#define SpriteRAM3B 0x5f80
void SkyKidDrawSprites(void)
{
int iOffset, iColor;
int x, y, iSprite;
BOOL bFlipx, bFlipy;
unsigned char c;

        for (iOffset=0; iOffset<128; iOffset += 2)  /* Up to 64 simultaneous sprites */
           {
         /* Is the sprite enabled? */
          y = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2B] - 8;
       if (y >= -15 && y < 223) /* Use to detect active sprites */
          {
          x = 344 - mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2B + 1];  /* Sprite area #2 */
          x -= 256 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B + 1] & 1);
          iSprite = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1B]; /* Sprite area #1 */
/* Bit selecting upper set of 256 sprites */
          iSprite += 2 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 0x80);
          iColor = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1B + 1] & 0x3f;
          iColor *= 8;
//          if (iSprite > 256)
//             iColor += 2048; /* Select second set of colors */
          bFlipx = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 1;
          bFlipy = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 2;
          c = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 0xc;
          switch (c)
             {
             case 0:    /* Regular size */
                EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                break;
             case 0x8:    /* Double Height */
                iSprite &= ~2;  /* Make sure it's on an even number */
                if (bFlipy)
                   {
                   EMUDrawSprite(x, y-16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else
                   {
                   EMUDrawSprite(x, y-16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                break;
             case 4:   /* Double Width */
                iSprite &= ~1;
                if (!bFlipx)
                   {
                   EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x+16, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else
                   {
                   EMUDrawSprite(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x+16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                break;
             case 12:   /* Double height, double width */
                iSprite &= ~3;
                if (!bFlipy && !bFlipx)
                   {
                   EMUDrawSprite(x-16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else if (bFlipy && bFlipx)
                   {
                   EMUDrawSprite(x-16, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else if (bFlipx)
                   {
                   EMUDrawSprite(x-16, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else /* bFlipy */
                   {
                   EMUDrawSprite(x-16, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                break;
             } /* switch */
         } /* If sprite enabled */
       } /* for each of 128 possible sprites */
} /* SkyKidDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DragBustDrawSprites(int, int, int)                         *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
void DragBustDrawSprites(void)
{
int iOffset, iColor;
int x, y, iSprite;
BOOL bFlipx, bFlipy;
unsigned char c;

        for (iOffset=0; iOffset<128; iOffset += 2)  /* Up to 64 simultaneous sprites */
           {
         /* Is the sprite enabled? */
          y = 201 - mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2B];
          iSprite = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1B]; /* Sprite area #1 */
          iSprite += 2 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 0x80);
       if (y >= 0 && y < 223 && iSprite < 384) /* Use to detect active sprites */
          {
          x = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2B + 1];  /* Sprite area #2 */
          x += 256 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B + 1] & 1);
          x -= 60;
/* Bit selecting upper set of 256 sprites */
          iColor = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1B + 1] & 0x1f;
          iColor *= 8;
          iColor += 16;
          bFlipx = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 1;
          bFlipy = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 2;
          c = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3B] & 0xc;
          switch (c)
             {
             case 0:    /* Regular size */
                EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                break;
             case 0x8:    /* Double Height */
                iSprite &= ~2;  /* Make sure it's on an even number */
                if (bFlipy)
                   {
                   EMUDrawSprite(x, y-16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else
                   {
                   EMUDrawSprite(x, y-16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                break;
             case 4:   /* Double Width */
                iSprite &= ~1;
                if (!bFlipx)
                   {
                   EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x+16, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else
                   {
                   EMUDrawSprite(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x+16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                break;
             case 12:   /* Double height, double width */
                iSprite &= ~3;
                if (!bFlipy && !bFlipx)
                   {
                   EMUDrawSprite(x-16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else if (bFlipy && bFlipx)
                   {
                   EMUDrawSprite(x-16, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else if (bFlipx)
                   {
                   EMUDrawSprite(x-16, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                else /* bFlipy */
                   {
                   EMUDrawSprite(x-16, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x-16, y+16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   EMUDrawSprite(x, y+16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[0x10000], &pPLColors[512]);
                   }
                break;
             } /* switch */
         } /* If sprite enabled */
       } /* for each of 128 possible sprites */
} /* DragBustDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MetroDrawSprites(int, int, int)                            *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
void MetroDrawSprites(void)
{
int iOffset, iColor;
int x, y, iSprite, iTall, iWide, col, row;
BOOL bFlipx, bFlipy;
int iXOff, iYOff;
unsigned char *p;

   p = &mem_map1[MEM_ROMRAM + 0x1800 + 0x7f4];
   iXOff = p[1] - ((p[0] & 1)*256);
   iYOff = p[3] - 16 - ((p[2] & 1)*256);
   for (iOffset=0; iOffset<0x800; iOffset += 16)  /* Up to 128 simultaneous sprites */
      {
      p = &mem_map1[MEM_ROMRAM + 0x1800 + iOffset];
      /* Is the sprite enabled? */
      x = p[7] + ((p[6] & 1)<<8);
      y = - p[9];
      iSprite = p[5]*4;
      if (iSprite < 0x200) /* Use to detect active sprites */
         {
         iColor = p[6] & 0xfe;
         iColor <<= 3;
         bFlipx = p[4] & 0x20;
         bFlipy = p[8] & 0x01;
         iTall = (p[8] & 4) >> 2;
         iWide = (p[4] & 0x80) >> 7;
         if ((p[4] & 0x10) && !iWide)
            iSprite += 1;
         if ((p[8] & 0x10) && !iTall)
            iSprite += 2;
         if (x > 512-32)
            x -= 512;
         if (bFlipx & !iWide)
            x -= 16;
         if (!iTall)
            y += 16;
         if (!iTall && (p[8] & 0x10) && bFlipy)
            y -= 16;
         x += iXOff;
         y += iYOff;

         for (row=0; row<=iTall; row++)
            {
            for (col=0; col<=iWide; col++)
               {
               EMUDrawSprite(-69 + (x+16*col),//(bFlipx ? 1-col : col)),
                             191 + (y+16*(bFlipy ? 1-row : row)),
                              iSprite+2*row+col, iColor, bFlipx, bFlipy, &mem_sprites[0x28000], (unsigned char *)pPLColors);
               }
            }
         } /* If sprite enabled */
      } /* for each of 128 possible sprites */
} /* MetroDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BaradukeDrawSprites(int, int, int)                         *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
void BaradukeDrawSprites(void)
{
int iOffset, iColor;
int x, y, iSprite, iTall, iWide, col, row;
BOOL bFlipx, bFlipy;
int iXOff, iYOff;
unsigned char *p;

   p = &mem_map1[MEM_ROMRAM + 0x1800 + 0x7f4];
   iXOff = p[1] - ((p[0] & 1)*256);
   iYOff = p[3] - 16 - ((p[2] & 1)*256);
   for (iOffset=0; iOffset<0x800; iOffset += 16)  /* Up to 128 simultaneous sprites */
      {
      p = &mem_map1[MEM_ROMRAM + 0x1800 + iOffset];
      /* Is the sprite enabled? */
      x = p[7] + ((p[6] & 1)<<8);
      y = - p[9];
      iSprite = p[5]*4;
      if (iSprite < 0x200) /* Use to detect active sprites */
         {
         iColor = p[6] & 0xfe;
         iColor <<= 3;
         bFlipx = p[4] & 0x20;
         bFlipy = p[8] & 0x01;
         iTall = (p[8] & 4) >> 2;
         iWide = (p[4] & 0x80) >> 7;
         if ((p[4] & 0x10) && !iWide)
            iSprite += 1;
         if ((p[8] & 0x10) && !iTall)
            iSprite += 2;
         if (x > 512-32)
            x -= 512;
         if (bFlipx & !iWide)
            x -= 16;
         if (!iTall)
            y += 16;
         if (!iTall && (p[8] & 0x10) && bFlipy)
            y -= 16;
         x += iXOff;
         y += iYOff;

         for (row=0; row<=iTall; row++)
            {
            for (col=0; col<=iWide; col++)
               {
               EMUDrawSprite(-69 + (x+16*(bFlipx ? 1-col : col)),//(bFlipx ? 1-col : col)),
                             191 + (y+16*(bFlipy ? 1-row : row)),
                              iSprite+2*row+col, iColor, bFlipx, bFlipy, &mem_sprites[0x28000], (unsigned char *)pPLColors);
               }
            }
         } /* If sprite enabled */
      } /* for each of 128 possible sprites */
} /* BaradukeDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusDrawSprites(int, int, int)                           *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
#define SpriteRAM1 0xf80
#define SpriteRAM2 0x1780
#define SpriteRAM3 0x1f80
void GaplusDrawSprites(void)
{
int iOffset, iColor;
int x, y, mx, my, cx, cy, iSprite;
int *p;
//uint32_t l;
BOOL bFlipx, bFlipy;
unsigned char c;

        for (iOffset=0; iOffset<128; iOffset += 2)  /* Up to 64 simultaneous sprites */
           {
         /* Is the sprite enabled? */
           y = (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2+1]-71) + 0x100*(mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3 + 1] & 1);
       if (y >= 0 && (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3+1] & 0x80)) /* Use to detect active sprites */
          {
          x = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM2]-8;  /* Sprite area #2 */
          iSprite = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1]; /* Sprite area #1 */
          iColor = 8 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM1 + 1] & 0x3f); /* Sprite area #1 */
          iSprite += 4 * (mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3] & 0x40); /* Sprite area #3 */
          bFlipx = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3] & 2;
          bFlipy = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3] & 1;
          c = mem_map1[MEM_ROMRAM + iOffset + SpriteRAM3] & 0xA8;
          switch (c)
             {
             case 0:    /* Regular size */
                cx = cy = 2;
                EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                break;
             case 0xa0: /* Double width - same sprite drawn twice */
                cx = 4;
                cy = 2;
                EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                EMUDrawSprite2(x+16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                break;
             case 0x8:    /* Double Height */
                cx = 2;
                cy = 4;
                iSprite &= ~1;  /* Make sure it's on an even number */
                if (bFlipy)
                   {
                   EMUDrawSprite2(x, y+16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                else
                   {
                   EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x, y+16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                break;
             case 0x20:   /* Double Width */
                cx = 4;
                cy = 2;
                iSprite &= ~2;
                if (!bFlipx)
                   {
                   EMUDrawSprite2(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                else
                   {
                   EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                break;
             case 0x28:   /* Double height, double width */
                cx = cy = 4;
                iSprite &= ~3;
                if (!bFlipy && !bFlipx)
                   {
                   EMUDrawSprite2(x, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x, y+16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y+16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                else if (bFlipy && bFlipx)
                   {
                   EMUDrawSprite2(x, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x, y+16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y+16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                else if (bFlipx)
                   {
                   EMUDrawSprite2(x, y, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x, y+16, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y+16, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                else /* bFlipy */
                   {
                   EMUDrawSprite2(x, y, iSprite+3, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x, y+16, iSprite+2, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y, iSprite+1, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   EMUDrawSprite2(x+16, y+16, iSprite, iColor, bFlipx, bFlipy, &mem_sprites[32768], cGaplusSpritePROM);
                   }
                break;
             default:
                cx = cy = 0; /* Nothing to do */
                break;
             } /* switch */
//          l = 1<<((y-16)>>3);
//          l |= (l<<1); /* Get all 16 lines involved */
//          lDirtyRect |= l;
          mx = x>>3; /* Get the x,y in terms of character coordinates */
          my = y>>3;
          if (x & 7) /* If touching next char, need to redraw it */
             cx++;
          if (y & 7) /* Same goes for vertical */
             cy++;
          p = &iCharX[2048+(28*my)+mx]; /* Our special coordinate conversion table */
          for (y=0; y<cy; y++)
             {
             for (x=0; x<cx; x++)
                {
                cDirtyChar[p[x]] = 1; /* Mark the char as needing a repaint */
                }
             p += 28; /* Next line */
             }
         } /* If sprite enabled */
       } /* for each of 64 possible sprites */
} /* GaplusDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : EMUDrawCharTransparent6()                                  *
 *                                                                          *
 *  PURPOSE    : Draw the bitmapped character at the given position.        *
 *                                                                          *
 ****************************************************************************/
void EMUDrawCharTransparent6(int iAddr, unsigned char *pColorPROM, int iPitch, int iChar, int iColor, unsigned long *ulCharAddr, unsigned char *pCharData)
{
unsigned char *p, *d;
#ifndef BOGUS //defined(PORTABLE) || defined(USE_ARM_ASM)
int x, y;
unsigned char c;
#endif

   d = (unsigned char *)ulCharAddr[iAddr];
   if (!d) /* Non-visible stuff */
      return;

   p = &pCharData[iChar * 64];
#ifndef BOGUS // defined(PORTABLE) || defined(USE_ARM_ASM)
   pColorPROM += iColor;
   for (y=0; y<8; y++)
      {
      for (x=0; x<8; x++)
         {
         c = p[x];
         if (c != 3)
            d[x] = pColorPROM[c];
         }
      p += 8;
      d += iPitch;
      }
#else
   iPitch -= 8; /* Use to advance to next line in asm code */
   _asm {
        mov  esi,p
        mov  edi,d
        mov  edx,pColorPROM
        add  edx,iColor    /* Add the fixed color offset */
        mov  ecx,iPitch
        xor  eax,eax
        mov  bl,8      /* y count */
drwc0:  mov  bh,8      /* x count */
drwc1:  mov  al,[esi]   /* Draw color or nothing ? */
        inc  esi
        cmp  al,0x3     /* Anything to draw? */
        jz   drwc2      /* nope, skip it */
        mov  al,[edx+eax]  /* Translate color */
        mov  [edi],al  /* Draw the pixel */
drwc2:  inc  edi
        dec  bh
        jnz  drwc1
        add  edi,ecx
        dec  bl
        jnz  drwc0
        }
#endif // PORTABLE
} /* EMUDrawCharTransparent6() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CopyScrollBitmap2(char *, char *, int, int)                *
 *                                                                          *
 *  PURPOSE    : Copy a scrolling bitmap to the destination screen buffer.  *
 *                                                                          *
 ****************************************************************************/
void CopyScrollBitmap2(unsigned char *pDest, unsigned char *pSrc, int iScrollx, int iScrolly)
{
register unsigned char *s, *end;
int i,j,k;

   s = pSrc + iScrollx + iScrolly*512;
   end = pSrc + 256 * 512; /* Bottom edge address */
   if (iScrollx > 223)
      {
      j = 512 - iScrollx;
      k = 288 - j; 
      for (i=0; i<224; i++) /* 224 lines in scrolling region */
         {
#ifndef BOGUS // defined(PORTABLE) || defined(USE_ARM_ASM)
         memcpy(pDest, s, j); // Copy left side
         memcpy(pDest+j, s-iScrollx, k); // Copy right side
#else
         _asm { // copy left side
              mov edi,pDest
              mov esi,s
              mov ecx,j
              mov ebx,j
              shr ecx,2
              and ebx,3
              rep movsd
              mov ecx,ebx
              rep movsb
              }
         _asm { // copy right side
              mov edi,pDest
              mov esi,s
              add edi,j
              sub esi,iScrollx
              mov ecx,k
              mov ebx,k
              shr ecx,2
              and ebx,3
              rep movsd
              mov ecx,ebx
              rep movsb
              }
#endif
         s += 512;
         if (s >= end)
            s -= 256 * 512;
         pDest += iCoinOpPitch;
         }
      }
   else
      {
      for (i=0; i<224; i++)
         {
#ifndef BOGUS // defined(PORTABLE) || defined(USE_ARM_ASM)
         memcpy(pDest, s, 288);
#else
         _asm {
              mov esi,s
              mov edi,pDest
              mov ecx,288/4
              rep movsd
              }
#endif
         s += 512;
         if (s >= end)
            s -= 256 * 512;
         pDest += iCoinOpPitch;
         }
      }

} /* CopyScrollBitmap2() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SkyKidScreenUpdate(void)                                   *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void SkyKidScreenUpdate(void)
{
register int i, iChar, iColor;

/* Draw Background */
   for (i=0; i<2048; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = 512 + mem_map1[MEM_ROMRAM + 0x2000 + i]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + 0x2800 + i]; /* Get the character color */
         if (iColor & 1)
            iChar += 256;
         iColor = ((iColor & 0x7e) << 1) + ((iColor & 1) << 8);
//         EMUDrawCharFast(i, iCoinOpPitch, iChar, iColor, pCoinOpBitmap, mem_sprites); /* Update this character/color */
         EMUDrawChar(i+0x400, pPLColors, 512, iChar, iColor, lCharAddr, &mem_sprites[0x0000]); /* Update this character/color */
         }
      }


   CopyScrollBitmap2(pCoinOpBitmap, pBackground, skykidstruct.iScroll0, 0);

/* Draw foreground on top of background */
   for (i=0; i<1024; i++)
      {
      iChar = mem_map1[MEM_ROMRAM + 0x4000 + i]; /* Get the character value */
      if (iChar != 0x2f) /* If not black */
         {
         iColor = 16 + ((mem_map1[MEM_ROMRAM + 0x4400 + i] & 0x3f) << 2); /* Get the character color */
         EMUDrawCharTransparent2(i, iCoinOpPitch, iChar, iColor, mem_sprites); /* Update this character/color */
//         EMUDrawCharFast(i, iCoinOpPitch, iChar, iColor, pCoinOpBitmap, mem_sprites); /* Update this character/color */
//         EMUDrawChar(i, pPLColors, iCoinOpPitch, iChar, iColor, lCharAddr, &mem_sprites[0x0000]); /* Update this character/color */
         }
      }

   SkyKidDrawSprites();

} /* SkyKidScreenUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DragBustScreenUpdate(void)                                 *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void DragBustScreenUpdate(void)
{
register int i, iChar, iColor;

/* Draw Background */
   for (i=0; i<2048; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = 512 + mem_map1[MEM_ROMRAM + 0x2000 + i]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + 0x2800 + i]; /* Get the character color */
         if (iColor & 1)
            iChar += 256;
         iColor = ((iColor & 0x7e) << 1) + ((iColor & 1) << 8);
//         EMUDrawCharFast(i, iCoinOpPitch, iChar, iColor, pCoinOpBitmap, mem_sprites); /* Update this character/color */
         EMUDrawChar(i+0x400, pPLColors, 512, iChar, iColor, lCharAddr, &mem_sprites[0x0000]); /* Update this character/color */
         }
      }

   CopyScrollBitmap2(pCoinOpBitmap, pBackground, skykidstruct.iScroll0, 0);
#ifdef BOGUS
/* Copy visible area of scrolling region to main bitmap */
   s = pBackground + iScroll0;
   d = pCoinOpBitmap;
   if (iScroll0 > 223)
      {
      j = 512 - iScroll0;
      k = 288 - j; 
      for (i=0; i<224; i++) /* 224 lines in scrolling region */
         {
         memcpy(d, s, j); /* Copy left side */
         memcpy(d+j, s-iScroll0, k); /* Copy right side */
         s += 512;
         d += iCoinOpPitch;
         }
      }
   else
      {
      for (i=0; i<224; i++)
         {
         memcpy(d, s, 288);
         s += 512;
         d += iCoinOpPitch;
         }
      }
#endif
/* Draw foreground on top of background */
   for (i=0; i<1024; i++)
      {
      iChar = mem_map1[MEM_ROMRAM + 0x4000 + i]; /* Get the character value */
      if (iChar != 0x2f) /* If not black */
         {
         iColor = (mem_map1[MEM_ROMRAM + 0x4400 + i] & 0x3f); /* Get the character color */
//         iColor = 16 + ((iColor & 0x1f) << 2) + ((iChar & 0x40)<<1) | (iChar & 0x80) ;
         iColor = 16 + ((iColor & 0x3f) << 2);// + ((iChar & 0x40)<<1) | (iChar & 0x80) ;
         EMUDrawCharTransparent2(i, iCoinOpPitch, iChar, iColor, mem_sprites); /* Update this character/color */
//         EMUDrawCharFast(i, iCoinOpPitch, iChar, iColor, pCoinOpBitmap, mem_sprites); /* Update this character/color */
//         EMUDrawChar(i, pPLColors, iCoinOpPitch, iChar, iColor, lCharAddr, &mem_sprites[0x0000]); /* Update this character/color */
         }
      }

   DragBustDrawSprites();

} /* DragBustScreenUpdate() */

#ifdef BOGUS
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BaradukeScreenUpdate(void)                                 *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void BaradukeScreenUpdate(void)
{
register int i, iChar, iColor;
int j, k, iScrollX, iScrollY;
unsigned char *s, *d, *end;

/* Draw the Foreground and Background */
   for (i=0; i<2048; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + 0x2000 + i*2]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + 0x2001 + i*2]; /* Get the character color */
         iChar += ((iColor & 0x3) << 8);
         iColor = ((iColor & 0xff)<<3);// + ((iColor & 0x1)<<10);
          EMUDrawChar(i, &pPLColors[0], 512, iChar, iColor, lCharAddr, &mem_sprites[0x8000]); /* Update this character/color */
//         EMUDrawCharFast(i, 512, iChar, iColor, pBackground, &mem_sprites[16384]); /* Update this character/color */
         }
      }

   for (i=2048; i<4096; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + 0x2000 + i*2]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + 0x2001 + i*2]; /* Get the character color */
         iChar += ((iColor & 0x3) << 8);
         iColor = ((iColor & 0xff)<<3);// + ((iColor & 1)<<10);
         EMUDrawChar(i, &pPLColors[0], 512, iChar, iColor, lCharAddr, &mem_sprites[0x18000]); /* Update this character/color */
//         EMUDrawCharFast(i, 512, iChar, iColor, pBackground, &mem_sprites[16384]); /* Update this character/color */
         }
      }

/* Copy visible area of scrolling background region to main bitmap */
   iScrollX = (iScroll2 + 16) & 0x1ff;
   iScrollY = (iScroll3 + 25) & 0xff;
   s = pBackground + iScrollX + (iScrollY * 512);
   d = pCoinOpBitmap;
   end = pBackground + 256 * 512; /* Bottom edge address */
   if (iScrollX > 223)
      {
      j = 512 - iScrollX;
      k = 288 - j; 
      for (i=0; i<224; i++) /* 224 lines in scrolling region */
         {
         memcpy(d, s, j); /* Copy left side */
         memcpy(d+j, s-iScrollX, k); /* Copy right side */
         s += 512;
         if (s >= end)
            s -= 256 * 512;
         d += iCoinOpPitch;
         }
      }
   else
      {
      for (i=0; i<224; i++)
         {
         memcpy(d, s, 288);
         s += 512;
         if (s >= end)
            s -= 256 * 512;
         d += iCoinOpPitch;
         }
      }

/* Combine the foreground with the background */
/* Only copy non-transparent bytes */
   iScrollX = (skykidstruct.iScroll0 + 18) & 0x1ff;
   iScrollY = (iScroll1 + 25) & 0xff;
   s = pForeground + iScrollX + (512*iScrollY); /* Skip over first 3 lines */
   d = pCoinOpBitmap; /* Destination bitmap */
   end = pForeground + 256 * 512; /* Bottom edge address */
   if (iScrollX > 224) /* Need to deal with wrap-around */
      {
      j = 512 - iScrollX;
      k = 288 - j; 
      for (i=0; i<224; i++) /* 224 lines in scrolling region */
         {
/* It's ugly already, let's try to make it fast */
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            mov ecx,j
            add ecx,3   /* Round to nearest DWORD */
            shr ecx,2
            mov edx,ulTransparent  /* Comparison value for transparent */
   bmpcp0:  mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcp4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcp1  /* Can skip it */
            mov [edi],al
   bmpcp1:  cmp ah,dl   /* Second byte? */
            jz  bmpcp2  /* can skip it */
            mov [edi+1],ah
   bmpcp2:  shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcp3
            mov [edi+2],al
   bmpcp3:  cmp ah,dl   /* Last byte? */
            jz  bmpcp4
            mov [edi+3],ah                     
   bmpcp4:  add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcp0
            }
/* It's ugly already, let's try to make it fast */
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            sub esi,iScrollX
            mov ecx,k /* DWORDs */
            add edi,j
            add ecx,3
            shr ecx,2
            mov edx,ulTransparent  /* Comparison value for transparent */
   bmpcpr0: mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcpr4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcpr1  /* Can skip it */
            mov [edi],al
   bmpcpr1: cmp ah,dl   /* Second byte? */
            jz  bmpcpr2  /* can skip it */
            mov [edi+1],ah
   bmpcpr2: shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcpr3
            mov [edi+2],al
   bmpcpr3: cmp ah,dl   /* Last byte? */
            jz  bmpcpr4
            mov [edi+3],ah                     
   bmpcpr4: add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcpr0
            }
         s += 512;
         if (s >= end)
            s -= (256 * 512);
         d += iCoinOpPitch;
         }
      }
   else /* simpler copy */
      {
      for (i=0; i<224; i++) /* 224 lines in scrolling region */
         {
/* It's ugly already, let's try to make it fast */
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            mov ecx,288/4 /* DWORDs */
            mov edx,ulTransparent  /* Comparison value for transparent */
   bmpcps0: mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcps4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcps1  /* Can skip it */
            mov [edi],al
   bmpcps1: cmp ah,dl   /* Second byte? */
            jz  bmpcps2  /* can skip it */
            mov [edi+1],ah
   bmpcps2: shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcps3
            mov [edi+2],al
   bmpcps3: cmp ah,dl   /* Last byte? */
            jz  bmpcps4
            mov [edi+3],ah                     
   bmpcps4: add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcps0
            }
         s += 512;
         if (s >= end)
            s -= (256 * 512);
         d += iCoinOpPitch;
         }
      }

   BaradukeDrawSprites();

/* Draw transparent text on top of foreground and background */
   for (i=0; i<1024; i++)
      {
      iChar = mem_map1[MEM_ROMRAM + 0x4800 + i]; /* Get the character value */
      if (iChar != cBlank) /* If not black */
         {
         iColor = (mem_map1[MEM_ROMRAM + 0x4c00+i] & 0x7f) << 4;
//         EMUDrawCharFast(i, iCoinOpPitch, iChar, iColor, pCoinOpBitmap, mem_sprites); /* Update this character/color */
//         EMUDrawChar(i, pPLColors, iCoinOpPitch, iChar, iColor, lCharAddr2, &mem_sprites[0x0000]); /* Update this character/color */

         EMUDrawCharTransparent6(i, pPLColors, iCoinOpPitch, iChar, iColor, lCharAddr2, mem_sprites); /* Update this character/color */
         }
      }

} /* BaradukeScreenUpdate() */
#endif // BOGUS
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MetroScreenUpdate(void)                                    *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void MetroScreenUpdate(void)
{
register int i, iChar, iColor;
int iScrollX, iScrollY;
unsigned char *s, *d, *end;

/* Draw the Foreground and Background */
   for (i=0; i<2048; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + 0x2000 + i*2]; /* Get the character value */
//         if (iChar == cBlank) /* If black */
//            EMUDrawCharBlack(i, 512, ulTransparent);
//         else
            {
            iColor = mem_map1[MEM_ROMRAM + 0x2001 + i*2]; /* Get the character color */
            iChar += ((iColor & 0x3) << 8);
            iColor = iColor<<3;
            EMUDrawChar(i, pPLColors, 512, iChar, iColor, lCharAddr, &mem_sprites[0x8000]); /* Update this character/color */
            }
//         EMUDrawCharFast(i, 512, iChar, iColor, pBackground, &mem_sprites[16384]); /* Update this character/color */
         }
      }

   for (i=2048; i<4096; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + 0x2000 + i*2]; /* Get the character value */
//         if (iChar == cBlank) /* If black */
//            EMUDrawCharBlack(i, 512, ulTransparent);
//         else
            {
            iColor = mem_map1[MEM_ROMRAM + 0x2001 + i*2]; /* Get the character color */
            iChar += ((iColor & 0x3) << 8);
            iColor = iColor<<3;
            EMUDrawChar(i, &pPLColors[2048], 512, iChar, iColor, lCharAddr, &mem_sprites[0x18000]); /* Update this character/color */
            }
//         EMUDrawCharFast(i, 512, iChar, iColor, pBackground, &mem_sprites[16384]); /* Update this character/color */
         }
      }

/* Copy visible area of scrolling background region to main bitmap */
   iScrollX = (skykidstruct.iScroll0 + 26) & 0x1ff;
   iScrollY = (iScroll1 + 25) & 0xff;
   CopyScrollBitmap2(pCoinOpBitmap, pForeground, iScrollX, iScrollY);

   MetroDrawSprites();

/* Combine the foreground with the background */
/* Only copy non-transparent bytes */

   iScrollX = (iScroll2 + 24) & 0x1ff;
   iScrollY = (iScroll3 + 25) & 0xff;
   s = pBackground + iScrollX + (512*iScrollY); /* Skip over first 3 lines */
   d = pCoinOpBitmap; /* Destination bitmap */
   end = pBackground + 256 * 512; /* Bottom edge address */
   if (iScrollX > 224) /* Need to deal with wrap-around */
      {
//      j = 512 - iScrollX;
//      k = 288 - j;
      for (i=0; i<224; i++) /* 224 lines in scrolling region */
         {
#if  defined(_X86) && !defined(PORTABLE)
/* It's ugly already, let's try to make it fast */
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            mov ecx,j
            add ecx,3   /* Round to nearest DWORD */
            shr ecx,2
            mov edx,ulTransparent  /* Comparison value for transparent */
   bmpcp0:  mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcp4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcp1  /* Can skip it */
            mov [edi],al
   bmpcp1:  cmp ah,dl   /* Second byte? */
            jz  bmpcp2  /* can skip it */
            mov [edi+1],ah
   bmpcp2:  shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcp3
            mov [edi+2],al
   bmpcp3:  cmp ah,dl   /* Last byte? */
            jz  bmpcp4
            mov [edi+3],ah                     
   bmpcp4:  add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcp0
            }
/* It's ugly already, let's try to make it fast */
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            sub esi,iScrollX
            mov ecx,k /* DWORDs */
            add edi,j
            add ecx,3
            shr ecx,2
            mov edx,ulTransparent  /* Comparison value for transparent */
   bmpcpr0: mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcpr4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcpr1  /* Can skip it */
            mov [edi],al
   bmpcpr1: cmp ah,dl   /* Second byte? */
            jz  bmpcpr2  /* can skip it */
            mov [edi+1],ah
   bmpcpr2: shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcpr3
            mov [edi+2],al
   bmpcpr3: cmp ah,dl   /* Last byte? */
            jz  bmpcpr4
            mov [edi+3],ah                     
   bmpcpr4: add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcpr0
            }
#endif // PORTABLE
         s += 512;
         if (s >= end)
            s -= (256 * 512);
         d += iCoinOpPitch;
         }
      }
   else /* simpler copy */
      {
      for (i=0; i<224; i++) /* 224 lines in scrolling region */
         {
/* It's ugly already, let's try to make it fast */
#if  defined(_X86) && !defined(PORTABLE)
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            mov ecx,288/4 /* DWORDs */
            mov edx,ulTransparent  /* Comparison value for transparent */
   bmpcps0: mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcps4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcps1  /* Can skip it */
            mov [edi],al
   bmpcps1: cmp ah,dl   /* Second byte? */
            jz  bmpcps2  /* can skip it */
            mov [edi+1],ah
   bmpcps2: shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcps3
            mov [edi+2],al
   bmpcps3: cmp ah,dl   /* Last byte? */
            jz  bmpcps4
            mov [edi+3],ah                     
   bmpcps4: add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcps0
            }
#endif // PORTABLE
         s += 512;
         if (s >= end)
            s -= (256 * 512);
         d += iCoinOpPitch;
         }
      }


/* Draw transparent text on top of foreground and background */
   for (i=0; i<1024; i++)
      {
      iChar = mem_map1[MEM_ROMRAM + 0x4800 + i]; /* Get the character value */
      if (iChar != cBlank) /* If not black */
         {
         iColor = (mem_map1[MEM_ROMRAM + 0x4c00+i] & 0x7f) << 4;
//         EMUDrawCharFast(i, iCoinOpPitch, iChar, iColor, pCoinOpBitmap, mem_sprites); /* Update this character/color */
//         EMUDrawChar(i, pPLColors, iCoinOpPitch, iChar, iColor, lCharAddr2, &mem_sprites[0x0000]); /* Update this character/color */

         EMUDrawCharTransparent6(i, pPLColors, iCoinOpPitch, iChar, iColor, lCharAddr2, mem_sprites); /* Update this character/color */
         }
      }

} /* MetroScreenUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacLandScreenUpdate(void)                                  *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void PacLandScreenUpdate(void)
{
register int i, iChar, iColor;
unsigned char *s, *d;
int j, k;

/* Draw background */
/* First 3 lines are special (non-scrolling region) */
//   for (i=0x880; i<0x940; i++)
//      {
//      if (cDirtyChar[i]) /* Char changed */
//         {
//         cDirtyChar[i] = 0;
//         iChar = mem_map1[MEM_ROMRAM + i*2]; /* Get the character value */
//         iColor = mem_map1[MEM_ROMRAM + i*2+1]; /* Get the character color */
//         iChar += ((iColor & 0xc0) << 4); /* 0x40 = flipx, 0x80 = flipy */
//         if (iColor & 1)
//            iChar += 256;
//         iColor = ((iColor & 0x3e) << 1) + ((iChar & 0x1c0)<<1) ;
//         EMUDrawChar(i, &pPLColors[3072], iCoinOpPitch, iChar, iColor, lCharAddr, &mem_sprites[0x8000]); /* Update this character/color */
//         }
//      }
/* Middle (scrolling) section */
   for (i=0x940; i<0xf40; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + i*2]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + i*2+1]; /* Get the character color */
         iChar += ((iColor & 0xc0) << 4); /* 0x40 = flipx, 0x80 = flipy */
         if (iColor & 1)
            iChar += 256;
         iColor = ((iColor & 0x3e) << 1) + ((iChar & 0x1c0)<<1) ;
         EMUDrawChar(i, &pPLColors[5120], 512, iChar, iColor, lCharAddr, &mem_sprites[0x8000]); /* Update this character/color */
         }
      }
/* Last line (non-scrolling) */
//   for (i=0xf40; i<0xf80; i++)
//      {
//      if (cDirtyChar[i]) /* Char changed */
//         {
//         cDirtyChar[i] = 0;
//         iChar = mem_map1[MEM_ROMRAM + i*2]; /* Get the character value */
//         iColor = mem_map1[MEM_ROMRAM + i*2+1]; /* Get the character color */
//         iChar += ((iColor & 0xc0) << 4); /* 0x40 = flipx, 0x80 = flipy */
//         if (iColor & 1)
//            iChar += 256;
//         iColor = ((iColor & 0x3e) << 1) + ((iChar & 0x1c0)<<1) ;
//         EMUDrawChar(i, &pPLColors[3072], iCoinOpPitch, iChar, iColor, lCharAddr, &mem_sprites[0x8000]); /* Update this character/color */
//         }
//      }

/* Draw foreground */
/* First three lines are special (non-scrolling) */
   for (i=0x80; i<0x140; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + i*2]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + i*2+1]; /* Get the character color */
         iChar += ((iColor & 0xc0) << 4); /* 0x40 = flipx, 0x80 = flipy */
         if (iColor & 1)
            iChar += 256;
         iColor = ((iColor & 0x1e) << 1) + ((iChar & 0x1e0)<<1) ;
         EMUDrawChar(i, &pPLColors[4096], iCoinOpPitch, iChar, iColor, lCharAddr, mem_sprites); /* Update this character/color */
//         EMUDrawCharTransparent3(i, &pPLColors[2048], iCoinOpPitch, iChar, iColor, mem_sprites, 0); /* Update this character/color */
         }
      }
/* Scrolling region */
   for (i=0x140; i<0x740; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + i*2]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + i*2+1]; /* Get the character color */
         iChar += ((iColor & 0xc0) << 4); /* 0x40 = flipx, 0x80 = flipy */
         if (iColor & 1)
            iChar += 256;
         iColor = ((iColor & 0x1e) << 1) + ((iChar & 0x1e0)<<1) ;
         EMUDrawChar(i, &pPLColors[4096], 512, iChar, iColor, lCharAddr, mem_sprites); /* Update this character/color */
         }
      }
/* Last line is special (non-scrolling) */
   for (i=0x740; i<0x780; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + i*2]; /* Get the character value */
         iColor = mem_map1[MEM_ROMRAM + i*2+1]; /* Get the character color */
         iChar += ((iColor & 0xc0) << 4); /* 0x40 = flipx, 0x80 = flipy */
         if (iColor & 1)
            iChar += 256;
         iColor = ((iColor & 0x1e) << 1) + ((iChar & 0x1e0)<<1) ;
         EMUDrawChar(i, &pPLColors[4096], iCoinOpPitch, iChar, iColor, lCharAddr, mem_sprites); /* Update this character/color */
//         EMUDrawCharTransparent3(i, &pPLColors[2048], iCoinOpPitch, iChar, iColor, mem_sprites, 0); /* Update this character/color */
         }
      }


/* Copy the background layer */
   s = pBackground + 512*3*8 + 3 + iScroll1; /* Skip over first 5 lines */
   d = pCoinOpBitmap + 24 * iCoinOpPitch; /* Destination bitmap */
   if (iScroll1 > 224) /* Need to deal with wrap-around */
      {
      j = 512 - iScroll1;
      k = 288 - j; 
      for (i=0; i<192; i++) /* 192 lines in scrolling region */
         {
         memcpy(d, s, j); /* Copy left side */
         memcpy(d+j, s-iScroll1, k); /* Copy right side */
         s += 512;
         d += iCoinOpPitch;
         }
      }
   else /* simple copy */
      {
      for (i=0; i<192; i++) /* 192 lines in scrolling region */
         {
         memcpy(d, s, 288); /* 288 pixels across */
         s += 512;
         d += iCoinOpPitch;
         }
      }
/* Draw sprites on top of the background, but under the foreground */
   PacLandDrawSprites(0);

/* Combine the foreground with the background */
/* Only copy non-transparent bytes */
   s = pForeground + 512*3*8 + 3 + skykidstruct.iScroll0; /* Skip over first 3 lines */
   d = pCoinOpBitmap + 24 * iCoinOpPitch; /* Destination bitmap */
   if (skykidstruct.iScroll0 > 224) /* Need to deal with wrap-around */
      {
      j = 512 - skykidstruct.iScroll0;
      k = 288 - j; 
      for (i=0; i<192; i++) /* 192 lines in scrolling region */
         {
/* It's ugly already, let's try to make it fast */
#if  defined(_X86) && !defined(PORTABLE)
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            mov ecx,j
            add ecx,3   /* Round to nearest DWORD */
            shr ecx,2
            mov edx,-1  /* Comparison value for transparent */
   bmpcp0:  mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcp4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcp1  /* Can skip it */
            mov [edi],al
   bmpcp1:  cmp ah,dl   /* Second byte? */
            jz  bmpcp2  /* can skip it */
            mov [edi+1],ah
   bmpcp2:  shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcp3
            mov [edi+2],al
   bmpcp3:  cmp ah,dl   /* Last byte? */
            jz  bmpcp4
            mov [edi+3],ah                     
   bmpcp4:  add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcp0
            }
//         for (l=0; l<j; l++) /* Copy left side */
//            {
//            c = s[l];
//            if (c != 0xff)
//               d[l] = c;
//            }
/* It's ugly already, let's try to make it fast */
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            sub esi,iScroll0
            mov ecx,k /* DWORDs */
            add edi,j
            add ecx,3
            shr ecx,2
            mov edx,-1  /* Comparison value for transparent */
   bmpcpr0: mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcpr4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcpr1  /* Can skip it */
            mov [edi],al
   bmpcpr1: cmp ah,dl   /* Second byte? */
            jz  bmpcpr2  /* can skip it */
            mov [edi+1],ah
   bmpcpr2: shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcpr3
            mov [edi+2],al
   bmpcpr3: cmp ah,dl   /* Last byte? */
            jz  bmpcpr4
            mov [edi+3],ah                     
   bmpcpr4: add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcpr0
            }
#endif // PORTABLE
//         for (l=0; l<k; l++) /* Copy right side */
//            {
//            c = s[l-iScroll0];
//            if (c != 0xff)
//               d[l+j] = c;
//            }
//         memcpy(d+j, s-iScroll0, k); /* Copy right side */
         s += 512;
         d += iCoinOpPitch;
         }
      }
   else /* simpler copy */
      {
      for (i=0; i<192; i++) /* 192 lines in scrolling region */
         {
#if  defined(_X86) && !defined(PORTABLE)
/* It's ugly already, let's try to make it fast */
       _asm { /* Copy left side */
            mov esi,s
            mov edi,d
            mov ecx,288/4 /* DWORDs */
            mov edx,-1  /* Comparison value for transparent */
   bmpcps0: mov eax,[esi]  /* Grab a dword for more efficiency */
            add esi,4
            cmp eax,edx /* Transparent? */
            jz  bmpcps4  /* Yes, skip it */
/* Must test each byte one at a time */
            cmp al,dl   /* First byte? */
            jz  bmpcps1  /* Can skip it */
            mov [edi],al
   bmpcps1: cmp ah,dl   /* Second byte? */
            jz  bmpcps2  /* can skip it */
            mov [edi+1],ah
   bmpcps2: shr eax,16  /* Shift down upper 2 bytes for access */
            cmp al,dl   /* Third byte? */
            jz  bmpcps3
            mov [edi+2],al
   bmpcps3: cmp ah,dl   /* Last byte? */
            jz  bmpcps4
            mov [edi+3],ah                     
   bmpcps4: add edi,4   /* Skip to next dest DWORD */
            dec ecx
            jnz bmpcps0
            }
#endif // PORTABLE
//         for (l=0; l<288; l++)
//            {
//            c = s[l];
//            if (c != 0xff)
//               d[l] = c;
//            }
//         memcpy(d, s, 288); /* 288 pixels across */
         s += 512;
         d += iCoinOpPitch;
         }
      }
/* Second pass to draw colors which show through */
   PacLandDrawSprites(1);

} /* PacLandScreenUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusScreenUpdate(void)                                   *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void GaplusScreenUpdate(void)
{
register int i, iChar;
register unsigned char c, ucColor;
static int iStarScrollPos = 0;
int x, y;
unsigned char cStars; /* Star control bits */

/* Un-draw the stars */
/* Do it in descending order in case some stars are on top of each other */
   cStars = mem_map1[MEM_ROMRAM + 0x9000]; /* I stuck it here for easier load/save */
   if (cStars) /* If stars are enabled */
      {
      for (i=NUM_STARS; i>=0; i--)
        {
        if (pStars[i].oldcolor)
           {
           x = pStars[i].x;
/* The stars should start at 16, but 18 gives us 2 unpainted blocks at top and bottom */
           y = 16 + (unsigned int)((pStars[i].y + (iStarScrollPos >> pStars[i].speed)) & 0xff);
           if (y < 272)
        	   pCoinOpBitmap[iCoinOpPitch * y + x] = pStars[i].oldcolor; /* Restore the old pixel */
           }
        }
      }

   for (i=64; i<960; i++) /* Middle part of screen */
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + i]; /* Get the character value */
         ucColor = mem_map1[MEM_ROMRAM + 0x400 + i]; /* Get the character color */
         if (ucColor & 0x80)
            iChar += 256;
         ucColor = ((ucColor & 0x3f) << 2);
         EMUDrawCharFast(i, iCoinOpPitch, iChar, 144+ucColor, lCharAddr, mem_sprites); /* Update this character/color */
//         EMUDrawChar(i, cGaplusCharPROM, iCoinOpPitch, iChar, ucColor, lCharAddr, mem_sprites); /* Update this character/color */
         }
      }
   for (i=0; i<64; i++) /* Bottom 2 lines */
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + i]; /* Get the character value */
         ucColor = mem_map1[MEM_ROMRAM + 0x400 + i]; /* Get the character color */
         if (ucColor & 0x80)
            iChar += 256;
         ucColor = ((ucColor & 0x3f) << 2);
         EMUDrawCharFast(i, iCoinOpPitch, iChar, 144+ucColor, lCharAddr, mem_sprites); /* Update this character/color */
         }
      }
   for (i=960; i<1024; i++) /* Top 2 lines */
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         iChar = mem_map1[MEM_ROMRAM + i]; /* Get the character value */
         ucColor = mem_map1[MEM_ROMRAM + 0x400 + i]; /* Get the character color */
         if (ucColor & 0x80)
            iChar += 256;
         ucColor = ((ucColor & 0x3f) << 2);
         EMUDrawCharFast(i, iCoinOpPitch, iChar, 144+ucColor, lCharAddr, mem_sprites); /* Update this character/color */
         }
      }

/* Draw the stars */
   if (cStars)
      {
      if (cStars == 6)
         iStarScrollPos++; /* Normal play */
      else
         iStarScrollPos--; /* Parsec 4, and others reverse direction */
      for (i=0; i<NUM_STARS; i++)
        {
        x = pStars[i].x;
/* The stars should start at 16, but 18 gives us 2 unpainted blocks at top and bottom */
        y = 16 + (unsigned int)((pStars[i].y + (iStarScrollPos >> pStars[i].speed)) & 0xff);
        if (y < 272)
           {
           c = pCoinOpBitmap[iCoinOpPitch*y+x]; /* Old pixel color */
           if (c == 0xA0) /* only draw if on black background */
              {
              pStars[i].oldcolor = 0xA0; /* Save the old pixel */
              pCoinOpBitmap[iCoinOpPitch * y + x] = pStars[i].color;
              }
           else
              pStars[i].oldcolor = 0; /* Mark as not drawn */
           }
        }
      }
/* Draw sprites on top of the characters and stars */
   GaplusDrawSprites(); /* Draw all of the sprites on top of the characters */

} /* GaplusScreenUpdate() */

void Gaplus_Reset(void)
{
    RESET6809(&regs1);
    RESET6809(&regs2);
    RESET6809(&regs3);

} /* Gaplus_Reset() */

int Gaplus_Init(GAME_BLOB *pBlob, char *pszROM, int iGameLoad)
{
    int i;
    RGBQUAD *pRGB;
    int iError = SG_NO_ERROR;
    
    if (pszROM == NULL) // reset request
    {
        Gaplus_Reset();
        return iError;
    }
    
    iCoinOpPitch = (SCREENX + 32);
    pCoinOpBitmap = (unsigned char *)EMUAlloc(iCoinOpPitch * (SCREENY+32));
    iCharX = (int *)EMUAlloc(4096*sizeof(int));
    iCharY = (int *)EMUAlloc(4096*sizeof(int));
    lCharAddr = (long unsigned int *)EMUAlloc(4096 * sizeof(long));
    pColorConvert = (short unsigned int *)EMUAlloc(256 * sizeof(short));
    cDirtyChar = (unsigned char *)EMUAlloc(4096);
    GaplusInit();
    //    pSounds = EMUAlloc(sizeof(SNDSAMPLE));
    //    if (EMULoadSamples(pSounds, szGalagaSample, 1, TEXT("galaga")))
    //       {
    //       EMUFree(pSounds);
    //       pSounds = NULL; /* No sound, don't try to play it */
    //       }
    iSpriteLimitX = 224;
    iSpriteLimitY = 288;
    cTransparent = 0x9f;
    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*50); /* Allow up to 50 hardware emulation handlers */
    emuh2 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*50); /* Allow up to 50 hardware emulation handlers */
    emuh3 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*50); /* Allow up to 50 hardware emulation handlers */
    pWaveforms = (signed char *)EMUAlloc(4096);
    mem_map1 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map2 = (unsigned char *)EMUAlloc(0x20000);
    mem_map3 = (unsigned char *)EMUAlloc(0x20000);
    mem_sprites = (unsigned char *)EMUAlloc(0x28000);
    cIRQEnable1 = 1;
    cIRQEnable3 = 1;
    cIRQEnable2 = 1;
    
    /*--- Load the Character/sound/palette ROMs into memory ---*/
    if (iROMSet == 0)
    {
        if (EMULoadRoms(GAPLUSROMSG, pszROM, NULL, NULL, mem_sprites, FALSE))
            goto cleanup;
    }
    else
    {
        if (EMULoadRoms(GAL3ROMSG, pszROM, NULL, NULL, mem_sprites, FALSE))
            goto cleanup;
    }
    memcpy(pSoundPROM, &mem_sprites[0xa000], 0x100); /* Copy sound waveforms */
    memcpy(cGaplusCharPROM, &mem_sprites[0xa400],0x100); /* Character colors */
    memcpy(cGaplusSpritePROM, &mem_sprites[0xa500],0x200); /* Sprite colors */
    /* Combine lower and upper bits of Sprite color lookup table and adjust for realized palette */
    for (i=0; i<512; i++)
    {
        unsigned char c;
        c = (mem_sprites[0xa500+i] & 0xf) + (mem_sprites[0xa700+i] << 4);
        if (c < 224)
            c += 0x10; /* Adjust for identity palette */
        else
            c -= 0x60; /* Last 16 colors are at 0x90 */
        cGaplusSpritePROM[i] = c;
    }
    /* Re-map character colors to fit the available palette colors */
    for (i=0; i<256; i++)
    {
        cGaplusCharPROM[i] += 0x90; /* Add identity palette offset */
    }
    PacPrepSounds(3); /* Prepare pre-calculated waveform data */
    
    pRGB = (RGBQUAD *)EMUAlloc(sizeof(RGBQUAD) * 256);
    for (i=0; i<128; i++) /* Convert the palette ROM entries into RGB values */
    {
        unsigned char r,g,b;
        r = mem_sprites[0xa100 + i] & 0xf;
        g = mem_sprites[0xa200 + i] & 0xf;
        b = mem_sprites[0xa300 + i] & 0xf;
        pRGB[i+16].rgbRed = cGaplusColorConvert[r];
        pRGB[i+16].rgbGreen = cGaplusColorConvert[g];
        pRGB[i+16].rgbBlue = cGaplusColorConvert[b];
    }
    for (i=240; i<256; i++) /* Convert the palette ROM entries into RGB values */
    {
        unsigned char r,g,b;
        r = mem_sprites[0xa100 + i] & 0xf;
        g = mem_sprites[0xa200 + i] & 0xf;
        b = mem_sprites[0xa300 + i] & 0xf;
        pRGB[i-96].rgbRed = cGaplusColorConvert[r];
        pRGB[i-96].rgbGreen = cGaplusColorConvert[g];
        pRGB[i-96].rgbBlue = cGaplusColorConvert[b];
    }
    /* Put the first 16 character colors in the palette for faster drawing */
    for (i=0; i<64; i++)
    {
        unsigned char r,g,b;
        r = mem_sprites[0xa1f0 + (cGaplusCharPROM[i] & 0xf)] & 0xf;
        g = mem_sprites[0xa2f0 + (cGaplusCharPROM[i] & 0xf)] & 0xf;
        b = mem_sprites[0xa3f0 + (cGaplusCharPROM[i] & 0xf)] & 0xf;
        pRGB[i+160].rgbRed = cGaplusColorConvert[r];
        pRGB[i+160].rgbGreen = cGaplusColorConvert[g];
        pRGB[i+160].rgbBlue = cGaplusColorConvert[b];
    }
    EMUCreatePalette(pRGB, 240);
    EMUFree(pRGB);
    
    
    /* Convert the character ROM into a more usable form */
    GaplusConvertChars();
    
    if (iROMSet == 0)
    {
        /*--- Load CPU#1 ROMs into memory ---*/
        if (EMULoadRoms(GAPLUSROMS1, pszROM, NULL, NULL, mem_map1, TRUE))
            goto cleanup;
        /*--- Load CPU#2 ROMs into memory ---*/
        if (EMULoadRoms(GAPLUSROMS2, pszROM, NULL, NULL, mem_map2, TRUE))
            goto cleanup;
        /*--- Load CPU#3 ROMs into memory ---*/
        if (EMULoadRoms(GAPLUSROMS3, pszROM, NULL, NULL, mem_map3, TRUE))
            goto cleanup;
    }
    else
    {
        /*--- Load CPU#1 ROMs into memory ---*/
        if (EMULoadRoms(GAL3ROMS1, pszROM, NULL, NULL, mem_map1, TRUE))
            goto cleanup;
        /*--- Load CPU#2 ROMs into memory ---*/
        if (EMULoadRoms(GAL3ROMS2, pszROM, NULL, NULL, mem_map2, TRUE))
            goto cleanup;
        /*--- Load CPU#3 ROMs into memory ---*/
        if (EMULoadRoms(GAL3ROMS3, pszROM, NULL, NULL, mem_map3, TRUE))
            goto cleanup;
    }
    
    /*--- Setup the hardware emulation handlers ---*/
    if (iROMSet == 0) /* Gaplus */
        EMUSetupHandlers(mem_map1, emuh1, mhGaplus1);
    else
        EMUSetupHandlers(mem_map1, emuh1, mhGalaga3_1);
    EMUSetupHandlers(mem_map2, emuh2, mhGaplus2);
    EMUSetupHandlers(mem_map3, emuh3, mhGaplus3);
    
    /* All set to start, tell the parent window to resize to what we need */
    memset(&regs1, 0, sizeof(regs1));
    memset(&regs2, 0, sizeof(regs1));
    memset(&regs3, 0, sizeof(regs1));
    for (i=0; i<16; i++)
    {
        regs1.ulOffsets[i] = (unsigned long)mem_map1;
        regs2.ulOffsets[i] = (unsigned long)mem_map2;
        regs3.ulOffsets[i] = (unsigned long)mem_map3;
    }
    regs1.mem_map = mem_map1;
    regs2.mem_map = mem_map2;
    regs3.mem_map = mem_map3;
    regs1.pEMUH = emuh1;
    regs2.pEMUH = emuh2;
    regs3.pEMUH = emuh3;
    
    //   EMUOpenSound((1<<iSampleRate)*11025, 60, 1, 8);
    iAudioShift = 14+iSampleRate;
    
    if (iROMSet == 0) /* Gaplus */
        iStop = 0xf0; /* Load hiscore at this frame */
    else
        iStop = 0x203; /* Galaga3 */
    //   if (bAutoLoad)
    //      GaplusLoadSave(6, TRUE);
    Gaplus_Reset();
cleanup:
    return iError;
} /* Gaplus_Init() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GaplusPlay(HANDLE, HWND, char *)                           *
 *                                                                          *
 *  PURPOSE    : Emulate the Namco Gaplus arcade hardware.                  *
 *                                                                          *
 ****************************************************************************/
void Gaplus_Play(GAME_BLOB *pBlob, BOOL bAudio, BOOL bVideo, uint32_t ulSysKeys)
{
    int j;
    
      if (iFrame == iStop) /* We can load the highscore now, setup code has finished */
         {
//         if (!EMULoadHiscore(pszTemp,0xa6)) /* If successfully loaded */
//            {
//            memcpy(&mem_map1[MEM_ROMRAM+0x0900], pszTemp, 0xa0);
//            memcpy(&mem_map1[MEM_ROMRAM+0x3ed], &pszTemp[0xa0], 6);
//            memset(&cDirtyChar[0x3ed],1,6); /* Force a repaint of these chars */
//            bHiLoaded = TRUE;
//            }
         }
      if (cIRQEnable1)
         regs1.ucIRQ |= INT_IRQ; /* VBlank interrupt on cpu #3 */
      if (cIRQEnable2)
         regs2.ucIRQ |= INT_IRQ; /* VBlank interrupt on cpu #3 */
      if (cIRQEnable3)
         regs3.ucIRQ |= INT_IRQ; /* VBlank interrupt on cpu #3 */
#define SLICE 32
#define SPEED 1536000/(60*SLICE)
      for (j=0; j<SLICE; j++)
         {
         if (regs1.ucIRQ || regs1.usRegPC != 0xd150) /* CWAI, don't bother */
            {
            regs1.iClocks = SPEED;
            EXEC6809(&regs1);
//            bTrace = FALSE;
            }
         if (regs2.ucIRQ || regs2.usRegPC != 0xbf84) /* Stuck on CWAI here */
            {
            regs2.iClocks = SPEED;
            EXEC6809(&regs2);
            }
         if (regs3.ucIRQ || regs3.usRegPC != 0xe053) /* Save time if stuck in busy loop */
            {
            regs3.iClocks = SPEED;
            EXEC6809(&regs3);
//            EXEC6809(&regs3); // hack addr = 0xe053
            }
         }
      SPSoundWrite(&mem_map3[MEM_ROMRAM+0x0000]); /* force an update of the sound parameters */
      SPSoundUpdate(pBlob->pAudioBuf, pBlob->iSampleCount); /* 60x per second is enough updates to get clean sound */
      if (bVideo)
         {
         GaplusScreenUpdate(); /* Draw any characters that need changing */
         EMUScreenUpdate(224, 288);
         }
/* Save the hi-score table */
//   memcpy(pszTemp, &mem_map1[MEM_ROMRAM + 0x900], 0xa0);
//   memcpy(&pszTemp[0xa0], &mem_map1[MEM_ROMRAM + 0x3ed], 6);
//   if (bHiLoaded)
//      EMUSaveHiscore(pszTemp, 0xa6);
//   if (bAutoLoad)
//      GaplusLoadSave(6, FALSE);

//   EMUEndTimer();
//   EMUCloseSound();

} /* Gaplus_Play() */

void Gaplus_Terminate(GAME_BLOB *pBlob)
{
    EMUFree(emuh1); /* Free emulation handler table */
    EMUFree(emuh2); /* Free emulation handler table */
    EMUFree(emuh3); /* Free emulation handler table */
    EMUFree(mem_map1); /* Free memory map */
    EMUFree(mem_map2); /* Free memory map */
    EMUFree(mem_map3); /* Free memory map */
    EMUFree(mem_sprites);
    EMUFree(pWaveforms);
    EMUFree(pStars);
    EMUFree(iCharX);
    EMUFree(iCharY);
    EMUFree(lCharAddr);
    EMUFree(pColorConvert);
    EMUFree(cDirtyChar);
    //   EMUDeletePalette();
    //   if (pSounds) /* If it loaded successfully */
    //      EMUFreeSamples(pSounds, 1); /* Free the sound sample */
    EMUFree(pCoinOpBitmap);

} /* Gaplus_Terminate() */

#ifdef FUTURE
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacLandPlay(HANDLE, HWND, char *)                          *
 *                                                                          *
 *  PURPOSE    : Emulate the PacLand arcade hardware.                       *
 *                                                                          *
 ****************************************************************************/
void PacLandPlay(char *szDir, int iROMSet)
{
int i, j;
int iNumHandlers1, iNumHandlers2;
RGBQUAD *pRGB;

    EMUCreateVideoBuffer(288, 224, 8, &pCoinOpBitmap);
    pForeground = (unsigned char *)EMUAlloc(512*256);
    pBackground = (unsigned char *)EMUAlloc(512*256);
    PacLandInit();
    cTransparent = 0xff; /* Sprite transparency color */
    iSpriteLimitX = 288;
    iSpriteLimitY = 216;
    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    emuh2 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    pWaveforms = (unsigned char *)EMUAlloc(8192);
    mem_map1 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map2 = (unsigned char *)EMUAlloc(0x20000);
    pPalettes = (unsigned char *)EMUAlloc(1024 * sizeof(PALETTEENTRY)); /* Memory for the 4 palette sets */
    pBanked = (unsigned char *)EMUAlloc(0x10000); /* 64K for banked ROMs */
    mem_sprites = (unsigned char *)EMUAlloc(0x60000);
//    pSounds = NULL; // no sampled sounds for Pac-Land
    pPLColors = (unsigned char *)EMUAlloc(8192); /* Sprite/Char lookup tables */
    memset(cDirtyChar, 1, 0x800); /* Force initial repaint of entire display */
    pRGB = EMUAlloc(sizeof(RGBQUAD) * 256);
    EMUCreatePalette(pRGB, 240);
    EMUFree(pRGB);

    if (iROMSet == 0)
       {
/*--- Load the Banked program ROMs into memory ---*/
       if (EMULoadRoms(PACLANDROMSB, szDir, NULL, NULL, pBanked, FALSE))
          goto cleanup;
/*--- Load the Character ROMs into memory ---*/
       if (EMULoadRoms(PACLANDROMSG, szDir, NULL, NULL, mem_sprites, FALSE))
          goto cleanup;
       }
    else
       {
/*--- Load the Banked program ROMs into memory ---*/
       if (EMULoadRoms(DRAGBUSTROMSB, szDir, NULL, NULL, pBanked, FALSE))
          goto cleanup;
/*--- Load the Character ROMs into memory ---*/
       if (EMULoadRoms(DRAGBUSTROMSG, szDir, NULL, NULL, mem_sprites, FALSE))
          goto cleanup;
       }
    memcpy(pSoundPROM, &mem_sprites[0x16000], 0x200); /* Copy sound waveforms */
    memcpy(pPLColors, &mem_sprites[0x14800], 0x2000); /* Sprite/char color lookup tables */
    for (i=0; i<1024; i++) /* Fix sprite colors */
       {
       unsigned char c;
       c = pPLColors[i];
       if (c == 0x7f)
          {
          pPLColors[i+2048] = c;
          pPLColors[i] = 0xff;
          }
       else
          pPLColors[i+2048] = 0xff;
       if (c == 0x7f)
          c = 0xff;
       if (c >= 0xf0) /* High priority colors */
          {
          pPLColors[i+1024] = c;
          }
       else
          {
          pPLColors[i+1024] = 0xff;
          }
       pPLColors[i+1024] = c;
       pPLColors[i+3072] = c;
       }
    for (i=4096; i<6144; i++)
       if (pPLColors[i] == 0x7f) /* Both 7F and FF are transparent in foreground */
          pPLColors[i] = 0xff;   /* Make it easier to deal with by setting both to FF */

    PLPrepSounds(3); /* Prepare pre-calculated waveform data */
   /* Convert the palette ROMs into a more usable form */
   for (i=0; i<1024; i++)
      {
      unsigned char c, r, g, b;
      c = mem_sprites[0x14000 + i];
      r = c & 0xf;
      g = c >> 4;
      b = mem_sprites[0x14400 + i];
      pPalettes[i].peRed = cGaplusColorConvert[r];  /* Convert the 4-bit palette entries to 8 bits */
      pPalettes[i].peGreen = cGaplusColorConvert[g];
      pPalettes[i].peBlue = cGaplusColorConvert[b];
      pPalettes[i].peFlags = 0;
      }
   /* Convert the character ROM into a more usable form */
    PacLandConvertChars();

    if (iROMSet == 0)
       {
/*--- Load CPU#1 ROMs into memory ---*/
       if (EMULoadRoms(PACLANDROMS1, szDir, &iNumHandlers1, emuh1, mem_map1, TRUE))
          goto cleanup;
/*--- Load CPU#2 ROMs into memory ---*/
       if (EMULoadRoms(PACLANDROMS2, szDir, &iNumHandlers2, emuh2, mem_map2, TRUE))
          goto cleanup;
       }
    else
       {
/*--- Load CPU#1 ROMs into memory ---*/
       if (EMULoadRoms(DRAGBUSTROMS1, szDir, &iNumHandlers1, emuh1, mem_map1, TRUE))
          goto cleanup;
/*--- Load CPU#2 ROMs into memory ---*/
       if (EMULoadRoms(DRAGBUSTROMS2, szDir, &iNumHandlers2, emuh2, mem_map2, TRUE))
          goto cleanup;
       }
    memset(&mem_map1[MEM_FLAGS+0x4000], 0xbf, 0x2000); /* Flag banked ROMs */
    memcpy(&mem_map1[MEM_ROMRAM + 0x4000], pBanked, 0x2000); /* Copy ROM Bank 0 to start */

/*--- Setup the hardware emulation handlers ---*/
   EMUSetupHandlers(mem_map1, emuh1, mhPacLand1);
   EMUSetupHandlers(mem_map2, emuh2, mhPacLand2);

/* Speed things up by freeing the non-visible video RAM from having to call a handler */
   for (i=0; i<4096; i++)
      {
      if (lCharAddr[i] == 0) /* Non-visible */
         {
         mem_map1[MEM_FLAGS + i*2] = 0;
         mem_map1[MEM_FLAGS + i*2+1] = 0;
         }
      }

/* All set to start, tell the parent window to resize to what we need */
   memset(&regs1, 0, sizeof(regs1));
   memset(&regs2a, 0, sizeof(regs2a));
   regs1.mem_map = mem_map1;
   regs1.pEMUH = emuh1;
   for (i=0; i<16; i++)
      {
      regs1.ulOffsets[i] = (unsigned long)mem_map1;
      regs2a.ulOffsets[i] = (unsigned long)mem_map2;
      }
   RESET6809(&regs1);
   regs2a.mem_map = mem_map2;
   regs2a.pEMUH = emuh2;
   RESET6803(&regs2a);

//   EMUOpenSound((1<<iSampleRate)*11025, 60, 1, 8);
   iAudioShift = 14+iSampleRate;

   bUserAbort = FALSE;
   ulKeys = 0; /* Start with no keys pressed */
   iFrame = 0;
//   EMUStartTimer(60);

   while (!bUserAbort)
      {
//      if (iFrame == 0x20) /* We can load the highscore now, setup code has finished */
//         EMULoadHiscore(&mem_map[MEM_ROMRAM+0xae], 2);
      regs1.ucIRQ |= INT_IRQ; /* VBlank interrupt on CPU */
      regs2a.ucIRQ |= INT_IRQ; /* VBlank interrupt on MCU */
      for (j=0; j<200; j++) /* Unfortunately we need to slice it thin to keep the sound working properly */
         {
         regs1.iClocks = 1536000/(60*200);
         if (regs1.ucIRQ || regs1.usRegPC != 0xdeac) /* busy loop, don't bother */
            EXEC6809(&regs1); // hack addr = 0xdeac
         if (skykidstruct.cCPUEnable)
            {
            regs2a.iClocks = 1536000/(60*200);
            M6803TimerUpdate(&regs2a);
         if (regs2a.ucIRQ || regs2.usRegPC != 0x80d7) /* busy loop, don't bother */
            EXEC6803(&regs2a); // hack addr = 0x80d7
            }
         }
      PLSoundWrite(&mem_map1[MEM_ROMRAM+0x6900]); /* force an update of the sound parameters */
//      PLSoundUpdate(); /* 60x per second is enough updates to get clean sound */
//      EMUDoSound(FALSE); /* Try to play the sound here */
      if (!(iFrame & iFrameSkip))
         {
         PacLandScreenUpdate(); /* Draw any changes */
//         lDirtyRect = -1;
         EMUScreenUpdate(288, 224);
         }
      iFrame++; /* Count the number of frames */
/* Allow messages to flow while we waste time */
//      EMUTimerDelay();
//      EMUDoSound(TRUE); /* Second try after a little delay */
      }
/* Save the hi-score table */
//   EMUSaveHiscore(&mem_map[MEM_ROMRAM+0xae], 2);

//   EMUEndTimer();
//   EMUCloseSound();

cleanup:
   EMUFree(emuh1); /* Free emulation handler table */
   EMUFree(emuh2); /* Free emulation handler table */
   EMUFree(mem_map1); /* Free memory map */
   EMUFree(mem_map2); /* Free memory map */
   EMUFree(mem_sprites);
   EMUFree(pWaveforms);
   EMUFree(pPLColors);
   EMUFree(pBanked);
   EMUFree(pForeground);
   EMUFree(pBackground);
   EMUFree(pPalettes);
//   EMUDeletePalette();
   EMUFreeVideoBuffer(pCoinOpBitmap);

} /* PacLandPlay() */
#endif // FUTURE

void SkyKid_Terminate(GAME_BLOB *pBlob)
{
	/* Save the hi-score table */
	if (bHiLoaded)
        SGSaveHighScore(pBlob->szGameName, &mem_map1[MEM_ROMRAM+0x5000], 80);

	//   if (bAutoLoad)
	//      SkyKidLoadSave(6, FALSE);
	
    EMUFree(pBackground);
    pBackground = NULL;
    EMUFree(pColorConvert);
    pColorConvert = NULL;
    EMUFree(pCoinOpBitmap);
    pCoinOpBitmap = NULL;
    EMUFree(emuh1);
    emuh1 = NULL;
    EMUFree(emuh2);
    emuh2 = NULL;
    EMUFree(pWaveforms);
    pWaveforms = NULL;
    EMUFree(mem_map1);
    mem_map1 = NULL;
    EMUFree(mem_map2);
    mem_map2 = NULL;
    EMUFree(pBanked);
    pBanked = NULL;
    EMUFree(pPLColors);
    pPLColors = NULL;
    EMUFree(lCharAddr);
    lCharAddr = NULL;
    EMUFree(iCharX);
    iCharX = NULL;
    EMUFree(iCharY);
    iCharY = NULL;
    EMUFree(cDirtyChar);
    cDirtyChar = NULL;
	
} /* SkyKid_Terminate() */

void SkyKid_Reset(void)
{
int i;

	for (i=0; i<16; i++)
      {
      regs1.ulOffsets[i] = (unsigned long)mem_map1;
      regs2a.ulOffsets[i] = (unsigned long)mem_map2;
      }
   RESET6809(&regs1);
   regs1.ulOffsets[0] = 0; // brute force banking
   RESET6803(&regs2a);
   skykidstruct.cCPUEnable = FALSE;
} /* SkyKid_Reset() */

void SkyKidPostLoad(void)
{
int i;

	memset(cDirtyChar,1,2048); // force a complete repaint
	regs1.mem_map = mem_map1;
	regs1.pEMUH = emuh1;
	regs2a.mem_map = mem_map2;
	regs2a.pEMUH = emuh2;
	for (i=0; i<16; i++)
      {
      regs1.ulOffsets[i] = (unsigned long)mem_map1;
      regs2a.ulOffsets[i] = (unsigned long)mem_map2;
      }
	PLSoundWrite(&mem_map2[0x1100]); /* force an update of the sound parameters */
	memcpy(&mem_map1[0x0000], &pBanked[skykidstruct.cROMBank << 13], 0x2000); /* Copy in this bank */
	iFrame = 0x500; // don't let it skip the self-test
} /* SkyKidPostLoad() */

int SkyKid_Init(GAME_BLOB *pBlob, char *pszROM, int iGameLoad)
{
int i;
RGBQUAD *pRGB;
int iError = SG_NO_ERROR;

    if (pszROM == NULL) // reset request
    {
    	SkyKid_Reset();
    	return iError;
    }
    bHiLoaded = FALSE;
    pBackground = NULL;
    pColorConvert = NULL;
    pCoinOpBitmap = NULL;
    emuh1 = emuh2 = NULL;
    pWaveforms = NULL;
    mem_map1 = mem_map2 = pBanked = NULL;
    pPLColors = NULL;
    lCharAddr = NULL;
    iCharX = iCharY = NULL;
    cDirtyChar = NULL;
    
    cDirtyChar = (unsigned char *)EMUAlloc(4096);
    iCharX = (int *)EMUAlloc(2048*sizeof(int));
    iCharY = (int *)EMUAlloc(2048*sizeof(int));
    lCharAddr = (long unsigned int*)EMUAlloc(4096 * sizeof(long));
    pBackground = (unsigned char *)EMUAlloc(512 * 224); /* Memory for background bitmap */
    pColorConvert = (unsigned short *)EMUAlloc(256 * sizeof(short));
    pCoinOpBitmap = (unsigned char *)EMUAlloc((288+32) * (224+32));
    iCoinOpPitch = (288+32);
    if (pCoinOpBitmap == NULL || pBackground == NULL || pColorConvert == NULL)
    {
 	   iError = SG_OUTOFMEMORY;
 	   goto cleanup;
    }
    SkyKidInit();
    cTransparent = 0; /* Sprite transparency color */
    iSpriteLimitX = 288;
    iSpriteLimitY = 224;
    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    emuh2 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    pWaveforms = (signed char *)EMUAlloc(8192);
    mem_map1 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map2 = (unsigned char *)EMUAlloc(0x20000);
    pBanked = (unsigned char *)EMUAlloc(0x4000); /* 16K for banked ROMs */
    mem_sprites = (unsigned char *)EMUAlloc(0x30000);
    pPLColors = (unsigned char *)EMUAlloc(4096); /* Sprite/Char lookup tables */
//    pSounds = NULL; // no sound samples (e.g. explosions) with SkyKid
//    __android_log_print(ANDROID_LOG_VERBOSE, "SkyKid_Init", "About to load SKYKIDROMSB");
    if (EMULoadRoms(SKYKIDROMSB, pszROM, NULL, NULL, pBanked, FALSE))
	{
    	iError = SG_FILENOTFOUND;
    	goto cleanup;
	}
//    __android_log_print(ANDROID_LOG_VERBOSE, "SkyKid_Init", "About to load SKYKIDROMSG");
/*--- Load the Character ROMs into memory ---*/  
    if (EMULoadRoms(SKYKIDROMSG, pszROM, NULL, NULL, mem_sprites, FALSE))
	{
    	iError = SG_FILENOTFOUND;
    	goto cleanup;
	}

    memcpy(pSoundPROM, &mem_sprites[0xc700], 0x200); /* Copy sound waveforms */
//    __android_log_print(ANDROID_LOG_VERBOSE, "SkyKid_Init", "About to copy data into pPLColors, pPLColors = %08x", (int)pPLColors);
    memcpy(pPLColors, &mem_sprites[0xc500], 0x200); /* char color lookup table */
//    __android_log_print(ANDROID_LOG_VERBOSE, "SkyKid_Init", "returned from memcpy");
    memcpy(&pPLColors[512], &mem_sprites[0xc300], 0x200); /* Sprite color lookup table */
	for (i=0; i<1024; i++) /* Fix char/sprite colors */
	{
	    pPLColors[i] = pPLColors[i] + 0x10;
	}

	PLPrepSounds(3); /* Prepare pre-calculated waveform data */
	   /* Convert the palette ROMs into a more usable form */
	pRGB = (RGBQUAD *)EMUAlloc(sizeof(RGBQUAD) * 256);
   for (i=0; i<168; i++)
      {
      unsigned char r, g, b;
      r = (mem_sprites[0xc000 + i] & 0xf);
      g = (mem_sprites[0xc100 + i] & 0xf);
      b = (mem_sprites[0xc200 + i] & 0xf);
      pRGB[i+16].rgbRed = cGaplusColorConvert[r];  /* Convert the 4-bit palette entries to 8 bits */
      pRGB[i+16].rgbGreen = cGaplusColorConvert[g];
      pRGB[i+16].rgbBlue = cGaplusColorConvert[b];
      }
    EMUCreatePalette(pRGB, 224);
    EMUFree(pRGB);

   /* Convert the character ROM into a more usable form */
    SkyKidConvertChars();

//    __android_log_print(ANDROID_LOG_VERBOSE, "SkyKid_Init", "About to load SKYKIDROMS1");
    if (EMULoadRoms(SKYKIDROMS1, pszROM, NULL, NULL, mem_map1, TRUE))
	{
    	iError = SG_FILENOTFOUND;
    	goto cleanup;
	}
	/*--- Load CPU#2 ROMs into memory ---*/
//    __android_log_print(ANDROID_LOG_VERBOSE, "SkyKid_Init", "About to load SKYKIDROMS2");
    if (EMULoadRoms(SKYKIDROMS2, pszROM, NULL, NULL, mem_map2, TRUE))
	{
    	iError = SG_FILENOTFOUND;
    	goto cleanup;
	}
	/* Set up banked ROM area at 0000-2000 */
   memset(&mem_map1[MEM_FLAGS+0x0000], 0xbf, 0x2000); /* Flag banked ROMs */
   memcpy(&mem_map1[MEM_ROMRAM + 0x0000], pBanked, 0x2000); /* Copy ROM Bank 0 to start */

	/*--- Setup the hardware emulation handlers ---*/
   EMUSetupHandlers(mem_map1, emuh1, mhSkyKid1);
   EMUSetupHandlers(mem_map2, emuh2, mhSkyKid2);

	/* Speed things up a bit by removing non-visible screen areas */
   for (i=0; i<2048; i++) /* Background */
   {
      if (lCharAddr[i+0x400] == 0)
         {
         mem_map1[MEM_FLAGS + 0x2000 + i] = 0;
         mem_map1[MEM_FLAGS + 0x2800 + i] = 0;
         }
   }
	/* All set to start, tell the parent window to resize to what we need */
   memset(&regs1, 0, sizeof(regs1));
   memset(&regs2a, 0, sizeof(regs2a));
   regs1.mem_map = mem_map1;
   regs1.pEMUH = emuh1;
   regs2a.mem_map = mem_map2;
   regs2a.pEMUH = emuh2;
   SkyKid_Reset();
	if (pBlob->iAudioSampleRate >= 40000)
	   iAudioShift = 16;
	else if (pBlob->iAudioSampleRate >= 20000)
	   iAudioShift = 15;
	else
	   iAudioShift = 14;

   // Define memory areas for load/save states and networking
   i = 0;
   pBlob->mem_areas[i].pPrimaryArea = (unsigned char *)&regs1;
   pBlob->mem_areas[i++].iAreaLength = sizeof(regs1);
   pBlob->mem_areas[i].pPrimaryArea = (unsigned char *)&regs2a;
   pBlob->mem_areas[i++].iAreaLength = sizeof(regs2a);
   pBlob->mem_areas[i].pPrimaryArea = (unsigned char *)&skykidstruct;
   pBlob->mem_areas[i++].iAreaLength = sizeof(skykidstruct);
   pBlob->mem_areas[i].pPrimaryArea = mem_map1;
   pBlob->mem_areas[i++].iAreaLength = 0x8000;
   pBlob->mem_areas[i].pPrimaryArea = &mem_map2[0x0000];
   pBlob->mem_areas[i++].iAreaLength = 0x1200;
   pBlob->mem_areas[i].pPrimaryArea = &mem_map2[0xc000];
   pBlob->mem_areas[i++].iAreaLength = 0x800;
   pBlob->mem_areas[i].iAreaLength = 0; // end of list

   if (iGameLoad >= 0)
   {
     if (!SGLoadGame(pBlob->szGameName, pBlob, iGameLoad))
     {
    	SkyKidPostLoad();
     }
   }

   cleanup:
   	   return iError;

} /* SkyKid_Init() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SkyKid_Play(GAME_BLOB *pBlob, BOOL, BOOL, ULONG)           *
 *                                                                          *
 *  PURPOSE    : Emulate the SkyKid arcade hardware.                        *
 *                                                                          *
 ****************************************************************************/
void SkyKid_Play(GAME_BLOB *pBlob, BOOL bAudio, BOOL bVideo, uint32_t ulSysKeys)
{
int j;

		if (pBlob->bRewound)
		{
			pBlob->bRewound = FALSE;
			SkyKidPostLoad();
		}
      if (!bHiLoaded && memcmp(&mem_map1[MEM_ROMRAM + 0x500c],"\x11\xa\x16\xa", 4) == 0) /* We can load the highscore now, setup code has finished */
      {
         bHiLoaded = TRUE;
         SGLoadHighScore(pBlob->szGameName, &mem_map1[0x5000], 80);
      }
      regs1.ucIRQ |= INT_IRQ; /* VBlank interrupt on CPU */
      regs2a.ucIRQ |= INT_IRQ; /* VBlank interrupt on MCU */ 
      for (j=0; j<200; j++) /* Unfortunately we need to slice it thin to keep the sound working properly */
         {
         regs1.iClocks = 1536000/(60*200);
         if (regs1.ucIRQ || regs1.usRegPC != 0x8084) /* busy loop, don't bother */
            EXEC6809(&regs1);
         if (skykidstruct.cCPUEnable)
            {
            regs2a.iClocks = 1536000/(60*200);
            M6803TimerUpdate(&regs2a);
            EXEC6803(&regs2a);
            }
         }
      if (bAudio)
      {
    	  PLSoundWrite(&mem_map2[0x1100]); /* force an update of the sound parameters */
    	  PLSoundUpdate(pBlob->pAudioBuf, pBlob->iSampleCount); /* 60x per second is enough updates to get clean sound */
      }
      if (bVideo)
         {
         SkyKidScreenUpdate(); /* Draw any changes */
//         lDirtyRect = -1;
         EMUScreenUpdate(288, 224);
         }

} /* SkyKid_Play() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DragBustPlay(HANDLE, HWND, char *)                         *
 *                                                                          *
 *  PURPOSE    : Emulate the Dragon Buster arcade hardware.                 *
 *                                                                          *
 ****************************************************************************/
void DragBustPlay(char *szDir, int iROMSet)
{
int i, j;
int iNumHandlers1, iNumHandlers2;
RGBQUAD *pRGB;

    pBackground = (unsigned char *)EMUAlloc(512 * 224); /* Memory for background bitmap */
    EMUCreateVideoBuffer(288, 224, 8, &pCoinOpBitmap);
    SkyKidInit();
    cTransparent = 0; /* Sprite transparency color */
    iSpriteLimitX = 288;
    iSpriteLimitY = 224;
    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    emuh2 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    pWaveforms = (signed char *)EMUAlloc(8192);
    mem_map1 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map2 = (unsigned char *)EMUAlloc(0x20000);
    pBanked = (unsigned char *)EMUAlloc(0x4000); /* 16K for banked ROMs */
    mem_sprites = (unsigned char *)EMUAlloc(0x28000);
    pPLColors = (unsigned char *)EMUAlloc(4096); /* Sprite/Char lookup tables */

/*--- Load the Banked program ROMs into memory ---*/
    if (EMULoadRoms(DRAGBUSTROMSB, szDir, NULL, NULL, pBanked, FALSE))
       goto cleanup;
/*--- Load the Character ROMs into memory ---*/  
    if (EMULoadRoms(DRAGBUSTROMSG, szDir, NULL, NULL, mem_sprites, FALSE))
       goto cleanup;

    memcpy(pSoundPROM, &mem_sprites[0xc700], 0x200); /* Copy sound waveforms */
    memcpy(pPLColors, &mem_sprites[0xc500], 0x200); /* char color lookup table */
    memcpy(&pPLColors[512], &mem_sprites[0xc300], 0x200); /* Sprite color lookup table */
    for (i=0; i<1024; i++) /* Fix char/sprite colors */
       {
       if (pPLColors[i] != 0xff)
          pPLColors[i] = pPLColors[i] + 0x10;
       else
          pPLColors[i] = 0;
       }

    PLPrepSounds(3); /* Prepare pre-calculated waveform data */
   /* Convert the palette ROMs into a more usable form */
    pRGB = (RGBQUAD *)EMUAlloc(sizeof(RGBQUAD) * 256);
   for (i=0; i<240; i++)
      {
      unsigned char r, g, b;
      r = (mem_sprites[0xc000 + i] & 0xf);
      g = (mem_sprites[0xc100 + i] & 0xf);
      b = (mem_sprites[0xc200 + i] & 0xf);
      pRGB[i+16].rgbRed = cGaplusColorConvert[r];  /* Convert the 4-bit palette entries to 8 bits */
      pRGB[i+16].rgbGreen = cGaplusColorConvert[g];
      pRGB[i+16].rgbBlue = cGaplusColorConvert[b];
      }
    EMUCreatePalette(pRGB, 256);
    EMUFree(pRGB);

   /* Convert the character ROM into a more usable form */
    DragBustConvertChars();

/*--- Load CPU#1 ROMs into memory ---*/
    if (EMULoadRoms(DRAGBUSTROMS1, szDir, &iNumHandlers1, emuh1, mem_map1, TRUE))
       goto cleanup;
/*--- Load CPU#2 ROMs into memory ---*/
    if (EMULoadRoms(DRAGBUSTROMS2, szDir, &iNumHandlers2, emuh2, mem_map2, TRUE))
       goto cleanup;
/* Set up banked ROM area at 0000-2000 */
   memset(&mem_map1[MEM_FLAGS+0x0000], 0xbf, 0x2000); /* Flag banked ROMs */
   memcpy(&mem_map1[MEM_ROMRAM + 0x0000], pBanked, 0x2000); /* Copy ROM Bank 0 to start */

/*--- Setup the hardware emulation handlers ---*/
   EMUSetupHandlers(mem_map1, emuh1, mhSkyKid1);
   EMUSetupHandlers(mem_map2, emuh2, mhSkyKid2);

/* Speed things up a bit by removing non-visible screen areas */
   for (i=0; i<2048; i++) /* Background */
      if (lCharAddr[i+0x400] == 0)
         {
         mem_map1[MEM_FLAGS + 0x2000 + i] = 0;
         mem_map1[MEM_FLAGS + 0x2800 + i] = 0;
         }

/* All set to start, tell the parent window to resize to what we need */
   memset(&regs1, 0, sizeof(regs1));
   memset(&regs2a, 0, sizeof(regs2a));
   regs1.mem_map = mem_map1;
   regs2a.mem_map = mem_map2;
   regs1.pEMUH = emuh1;
   regs2a.pEMUH = emuh2;
   for (i=0; i<16; i++)
      {
      regs1.ulOffsets[i] = (unsigned long)mem_map1;
      regs2a.ulOffsets[i] = (unsigned long)mem_map2;
      }
   RESET6809(&regs1);
   RESET6803(&regs2a);

//   EMUOpenSound((1<<iSampleRate)*11025, 60, 1, 8);
   iAudioShift = 14+iSampleRate;

   bUserAbort = FALSE;
   ulKeys = 0; /* Start with no keys pressed */
   iFrame = 0;
//   EMUStartTimer(60);
   while (!bUserAbort)
      {
//      if (!bHiLoaded && memcmp(&mem_map1[MEM_ROMRAM + 0x500c],"\x11\xa\x16\xa", 4) == 0) /* We can load the highscore now, setup code has finished */
//         {
//        bHiLoaded = TRUE;
//         EMULoadHiscore(&mem_map1[MEM_ROMRAM+0x5000], 80);
//         }
      regs1.ucIRQ |= INT_IRQ; /* VBlank interrupt on CPU */
      regs2a.ucIRQ |= INT_IRQ; /* VBlank interrupt on MCU */ 
      for (j=0; j<200; j++) /* Unfortunately we need to slice it thin to keep the sound working properly */
         {
         regs1.iClocks = 1536000/(60*200);
         if (regs1.ucIRQ || regs1.usRegPC != 0x8084) /* busy loop, don't bother */
            EXEC6809(&regs1);
         if (skykidstruct.cCPUEnable)
            {
            regs2a.iClocks = 1536000/(60*200);
            M6803TimerUpdate(&regs2a);
            if (regs2a.ucIRQ || regs2.usRegPC != 0xf081) /* busy loop, don't bother */
               EXEC6803(&regs2a);
            }
         }
      PLSoundWrite(&mem_map2[MEM_ROMRAM+0x1100]); /* force an update of the sound parameters */
//      PLSoundUpdate(); /* 60x per second is enough updates to get clean sound */
//      EMUDoSound(FALSE); /* Try to play the sound here */
//      if (!(iFrame & iFrameSkip))
         {
         DragBustScreenUpdate(); /* Draw any changes */
//         lDirtyRect = -1;
         EMUScreenUpdate(288, 224);
         }
      iFrame++; /* Count the number of frames */
/* Allow messages to flow while we waste time */
//      EMUTimerDelay();
//      EMUDoSound(TRUE); /* Second try after a little delay */
      }
/* Save the hi-score table */
//   if (bHiLoaded)
//      EMUSaveHiscore(&mem_map1[MEM_ROMRAM+0x5000], 80);

//   EMUEndTimer();
//   EMUCloseSound();

cleanup:
   EMUFree(emuh1); /* Free emulation handler table */
   EMUFree(emuh2); /* Free emulation handler table */
   EMUFree(mem_map1); /* Free memory map */
   EMUFree(mem_map2); /* Free memory map */
   EMUFree(mem_sprites);
   EMUFree(pBackground);
   EMUFree(pWaveforms);
   EMUFree(pPLColors);
   EMUFree(pBanked);
//   EMUDeletePalette();
   EMUFreeVideoBuffer(pCoinOpBitmap);

} /* DragBustPlay() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MetroCrossPlay(HANDLE, HWND, char *)                       *
 *                                                                          *
 *  PURPOSE    : Emulate the Namco Metro Cross arcade hardware.             *
 *                                                                          *
 ****************************************************************************/
void MetroCrossPlay(char *szDir, int iROMSet)
{
int i, j;
int iNumHandlers1, iNumHandlers2;
RGBQUAD *pRGB;
int iCount;
uint32_t *pTemp;

    pBackground = (unsigned char *)EMUAlloc(512 * 256); /* Memory for background bitmap */
    pForeground = (unsigned char *)EMUAlloc(512 * 256); /* Memory for foreground bitmap */
    EMUCreateVideoBuffer(288, 224, 8, &pCoinOpBitmap);
    MetroInit();
    cTransparent = 0xf; /* Sprite transparency color */
    cBlank = 0x2b; /* Blank space background character */
    iSpriteLimitX = 288;
    iSpriteLimitY = 224;
    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    emuh2 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    pWaveforms = (signed char *)EMUAlloc(8192);
    mem_map1 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map2 = (unsigned char *)EMUAlloc(0x20000);
    mem_sprites = (unsigned char *)EMUAlloc(0x50000);
    pPLColors = (unsigned char *)EMUAlloc(8192); /* Color palette */
    pPalettes = (PALETTEENTRY *)EMUAlloc(2048 * sizeof(PALETTEENTRY)); /* Memory for the 4 palette sets */

/*--- Load the Character ROMs into memory ---*/  
    if (EMULoadRoms(METROCRSROMSG, szDir, NULL, NULL, mem_sprites, FALSE))
       goto cleanup;

    memcpy(pSoundPROM, &mem_sprites[0x017000], 0x200); /* Copy sound waveforms */
    PLPrepSounds(3); /* Prepare pre-calculated waveform data */
/* Find the unique colors to create a palette and lookup table */
   iCount = 0; /* Total number of unique colors */
   pTemp = (uint32_t *)EMUAlloc(8192);
   for (i=0; i<2048; i++)
      {
      unsigned char c, r, g, b;
      uint32_t l;
      c = mem_sprites[0x16000 + i];
      g = c & 0xf;
      b = (c >> 4) & 0xf; /* Trim off the lsb of blue for smaller total colors */
      r = mem_sprites[0x16800 + i] & 0xf;
      l = r | (g << 8) | (b << 16);
      for (j=0; j<iCount; j++)
         {
         if (l == pTemp[j]) /* Already exists? */
            break;
         }
      if (j == iCount) /* New Color */
         {
         pTemp[iCount++] = l; /* Store the new color */
         }
      }
/* Now recode a color table to reference the condensed palette */
   for (i=0; i<2048; i++)
      {
      unsigned char c, r, g, b;
      uint32_t l;
      c = mem_sprites[0x16000 + i];
      g = c & 0xf;
      b = (c >> 4) & 0xf; /* Trim off the lsb of blue for smaller total colors */
      r = mem_sprites[0x16800 + i] & 0xf;
      l = r | (g << 8) | (b << 16);
      for (j=0; j<iCount; j++)
         {
         if (l == pTemp[j]) /* Found the color */
            break;
         }
      pPLColors[i] = j + 0x10; /* Store references to the idealized palette */
      }
/* Pen 7 is transparent, set a special color to mark it */
   memcpy(&pPLColors[2048], pPLColors, 2048);
   for (i=7; i<2048; i+=8)
      pPLColors[i+2048] = 0xc0;
   ulTransparent = 0xc0;
   ulTransparent |= ulTransparent <<8 | ulTransparent <<16 | ulTransparent<<24;

/* Create the idealized palette */
   pRGB = (RGBQUAD *)EMUAlloc(sizeof(RGBQUAD) * 256);
   for (i=0; i<iCount; i++)
      {
      pRGB[i+16].rgbRed = cGaplusColorConvert[pTemp[i] & 0xff];
      pRGB[i+16].rgbGreen = cGaplusColorConvert[(pTemp[i] >> 8) & 0xff];
      pRGB[i+16].rgbBlue = cGaplusColorConvert[(pTemp[i] >> 16) & 0xff];
      }
    EMUFree(pTemp);
    pRGB[0xc0].rgbRed = 0;
    pRGB[0xc0].rgbGreen = 0;
    pRGB[0xc0].rgbBlue = 0;
   /* Convert the palette ROMs into a more usable form */
    EMUCreatePalette(pRGB, 240);
    EMUFree(pRGB);

   /* Convert the character ROM into a more usable form */
    MetroCrossConvertChars();

/*--- Load CPU#1 ROMs into memory ---*/
    if (EMULoadRoms(METROCRSROMS1, szDir, &iNumHandlers1, emuh1, mem_map1, TRUE))
       goto cleanup;
/*--- Load CPU#2 ROMs into memory ---*/
    if (EMULoadRoms(METROCRSROMS2, szDir, &iNumHandlers2, emuh2, mem_map2, TRUE))
       goto cleanup;

/*--- Setup the hardware emulation handlers ---*/
   EMUSetupHandlers(mem_map1, emuh1, mhMetroCross1);
   EMUSetupHandlers(mem_map2, emuh2, mhMetroCross2);

/* All set to start, tell the parent window to resize to what we need */
   memset(&regs1, 0, sizeof(regs1));
   memset(&regs2a, 0, sizeof(regs2a));
   regs1.mem_map = mem_map1;
   regs2a.mem_map = mem_map2;
   regs1.pEMUH = emuh1;
   regs2a.pEMUH = emuh2;
   for (i=0; i<16; i++)
      {
      regs1.ulOffsets[i] = (unsigned long)mem_map1;
      regs2a.ulOffsets[i] = (unsigned long)mem_map2;
      }
   RESET6809(&regs1);
   RESET6803(&regs2a);

//   EMUOpenSound((1<<iSampleRate)*11025, 60, 1, 8);
   iAudioShift = 14+iSampleRate;

   bUserAbort = FALSE;
   ulKeys = 0; /* Start with no keys pressed */
   iFrame = 0;
//   EMUStartTimer(60);
   MetroHaltWrite(0x8000,0); /* Get things started in the MCU */
//   ohandle = EMUCreate("c:\\emuc.log");
//   bTrace = TRUE;
//   if (bAutoLoad)
//      MetroCrossLoadSave(6, TRUE);
   while (!bUserAbort)
      {
//      if (!bHiLoaded && memcmp(&mem_map1[MEM_ROMRAM + 0x1470],"\xb4\x2b\x2b\x08", 4) == 0) /* We can load the highscore now, setup code has finished */
//         {
//         bHiLoaded = TRUE;
//         EMULoadHiscore(&mem_map1[MEM_ROMRAM+0x1470], 0x80);
//         }
      regs1.ucIRQ |= INT_IRQ; /* VBlank interrupt on CPU */
      regs2a.ucIRQ |= INT_IRQ; /* VBlank interrupt on MCU */ 
      for (j=0; j<200; j++) /* Unfortunately we need to slice it thin to keep the sound working properly */
         {
         regs1.iClocks = 1536000/(60*200);
         if (regs1.ucIRQ || regs1.usRegPC != 0x8084) /* busy loop, don't bother */
            EXEC6809(&regs1);
         if (skykidstruct.cCPUEnable)
            {
            regs2a.iClocks = 1536000/(60*200);
            M6803TimerUpdate(&regs2a);
            if (regs2a.ucIRQ || regs2a.usRegPC != 0xf081) /* busy loop, don't bother */
            EXEC6803(&regs2a);
//            EXEC6803(mem_map2, &regs2a, emuh2, &i, &ucIRQ2, -1, NULL);
//            EXEC6800(mem_map2, &regs2a, emuh2, &i, &ucIRQ2, 0xf081, NULL);
            }
         }
      PLSoundWrite(&mem_map2[MEM_ROMRAM+0x1100]); /* force an update of the sound parameters */
//      PLSoundUpdate(); /* 60x per second is enough updates to get clean sound */
//      EMUDoSound(FALSE); /* Try to play the sound here */
//      if (!(iFrame & iFrameSkip))
         {
         MetroScreenUpdate();
//         lDirtyRect |= 0x7FFFFFC; /* Always paint scrolling area */
         EMUScreenUpdate(288, 224);
         }
      iFrame++; /* Count the number of frames */
/* Allow messages to flow while we waste time */
//      EMUTimerDelay();
//      EMUDoSound(TRUE); /* Second try after a little delay */
      }
/* Save the hi-score table */
//   if (bHiLoaded)
//      EMUSaveHiscore(&mem_map1[MEM_ROMRAM+0x1470], 0x80);
//   if (bAutoLoad)
//      MetroCrossLoadSave(6, FALSE);

//   EMUEndTimer();
//   EMUCloseSound();

cleanup:
   EMUFree(emuh1); /* Free emulation handler table */
   EMUFree(emuh2); /* Free emulation handler table */
   EMUFree(mem_map1); /* Free memory map */
   EMUFree(mem_map2); /* Free memory map */
   EMUFree(mem_sprites);
   EMUFree(pBackground);
   EMUFree(pForeground);
   EMUFree(pWaveforms);
   EMUFree(pPLColors);

//   EMUDeletePalette();
   EMUFreeVideoBuffer(pCoinOpBitmap);

} /* MetroCrossPlay() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BaradukePlay(HANDLE, HWND, char *)                         *
 *                                                                          *
 *  PURPOSE    : Emulate the Namco Baraduke arcade hardware.                *
 *                                                                          *
 ****************************************************************************/
void BaradukePlay(char *szDir, int iROMSet)
{
int i, j;
int iNumHandlers1, iNumHandlers2;
RGBQUAD *pRGB;
int iCount;
uint32_t *pTemp;

    pBackground = (unsigned char *)EMUAlloc(512 * 256); /* Memory for background bitmap */
    pForeground = (unsigned char *)EMUAlloc(512 * 256); /* Memory for foreground bitmap */
    EMUCreateVideoBuffer(288, 224, 8, &pCoinOpBitmap);
    MetroInit();
    cTransparent = 0xf; /* Sprite transparency color */
    cBlank = 0x20; /* Blank space background character */
    ulTransparent = 0x13131313; /* Transparent foreground color */
    iSpriteLimitX = 288;
    iSpriteLimitY = 224;
    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    emuh2 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    pWaveforms = (signed char *)EMUAlloc(8192);
    mem_map1 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map2 = (unsigned char *)EMUAlloc(0x20000);
    mem_sprites = (unsigned char *)EMUAlloc(0x50000);
    pPLColors = (unsigned char *)EMUAlloc(8192); /* Color palette */
    pRGB = (RGBQUAD *)EMUAlloc(sizeof(RGBQUAD) * 256);
    pTemp = (uint32_t *)EMUAlloc(8192);

/*--- Load the Character ROMs into memory ---*/  
    if (EMULoadRoms(BARADUKEROMSG, szDir, NULL, NULL, mem_sprites, FALSE))
       goto cleanup;

    memcpy(pSoundPROM, &mem_sprites[0x1f000], 0x200); /* Copy sound waveforms */
    PLPrepSounds(3); /* Prepare pre-calculated waveform data */

/* Find the unique colors to create a palette and lookup table */
   iCount = 0; /* Total number of unique colors */
   pTemp = (uint32_t *)EMUAlloc(8192);
   for (i=0; i<2048; i++)
      {
      unsigned char c, r, g, b;
      uint32_t l;
      c = mem_sprites[0x1e000 + i];
      g = c & 0xf;
      b = (c >> 4) & 0xf; /* Trim off the lsb of blue for smaller total colors */
      r = mem_sprites[0x1e800 + i] & 0xf;
      l = r | (g << 8) | (b << 16);
      for (j=0; j<iCount; j++)
         {
         if (l == pTemp[j]) /* Already exists? */
            break;
         }
      if (j == iCount) /* New Color */
         {
         pTemp[iCount++] = l; /* Store the new color */
         }
      }
/* Now recode a color table to reference the condensed palette */
   for (i=0; i<2048; i++)
      {
      unsigned char c, r, g, b;
      uint32_t l;
      c = mem_sprites[0x1e000 + i];
      g = c & 0xf;
      b = (c >> 4) & 0xf; /* Trim off the lsb of blue for smaller total colors */
      r = mem_sprites[0x1e800 + i] & 0xf;
      l = r | (g << 8) | (b << 16);
      for (j=0; j<iCount; j++)
         {
         if (l == pTemp[j]) /* Found the color */
            break;
         }
      pPLColors[i] = j + 0x10; /* Store references to the idealized palette */
      }
/* Create the idealized palette */
   if (iCount > 240)
      iCount = 240;
   for (i=0; i<iCount; i++)
      {
      pRGB[i+16].rgbRed = cGaplusColorConvert[pTemp[i] & 0xff];
      pRGB[i+16].rgbGreen = cGaplusColorConvert[(pTemp[i] >> 8) & 0xff];
      pRGB[i+16].rgbBlue = cGaplusColorConvert[(pTemp[i] >> 16) & 0xff];
      }
    EMUFree(pTemp);    
   /* Convert the palette ROMs into a more usable form */
    EMUCreatePalette(pRGB, 256);
    EMUFree(pRGB);

   /* Convert the character ROM into a more usable form */
    MetroCrossConvertChars();

/*--- Load CPU#1 ROMs into memory ---*/
    if (EMULoadRoms(BARADUKEROMS1, szDir, &iNumHandlers1, emuh1, mem_map1, TRUE))
       goto cleanup;
/*--- Load CPU#2 ROMs into memory ---*/
    if (EMULoadRoms(BARADUKEROMS2, szDir, &iNumHandlers2, emuh2, mem_map2, TRUE))
       goto cleanup;

/*--- Setup the hardware emulation handlers ---*/
   EMUSetupHandlers(mem_map1, emuh1, mhBaraduke1);
   EMUSetupHandlers(mem_map2, emuh2, mhBaraduke2);

/* All set to start, tell the parent window to resize to what we need */
   memset(&regs1, 0, sizeof(regs1));
   memset(&regs2a, 0, sizeof(regs2a));
   regs1.mem_map = mem_map1;
   regs1.pEMUH = emuh1;
   for (i=0; i<16; i++)
      {
      regs1.ulOffsets[i] = (unsigned long)mem_map1;
      regs2a.ulOffsets[i] = (unsigned long)mem_map2;
      }
   RESET6809(&regs1);
   regs2a.mem_map = mem_map2;
   regs2a.pEMUH = emuh2;
   RESET6803(&regs2a);

//   EMUOpenSound((1<<iSampleRate)*11025, 60, 1, 8);
   iAudioShift = 14+iSampleRate;

   bUserAbort = FALSE;
   ulKeys = 0; /* Start with no keys pressed */
   iFrame = 0;
//   EMUStartTimer(60);
   MetroHaltWrite(0x8000,0); /* Get things started in the MCU */

   while (!bUserAbort)
      {
//      if (!bHiLoaded && memcmp(&mem_map1[MEM_ROMRAM + 0x500c],"\x11\xa\x16\xa", 4) == 0) /* We can load the highscore now, setup code has finished */
//         {
//         bHiLoaded = TRUE;
//         EMULoadHiscore(&mem_map1[MEM_ROMRAM+0x5000], 80);
//         }
      regs1.ucIRQ |= INT_IRQ; /* VBlank interrupt on CPU */
      regs2a.ucIRQ |= INT_IRQ; /* VBlank interrupt on MCU */ 
      for (j=0; j<200; j++) /* Unfortunately we need to slice it thin to keep the sound working properly */
         {
         regs1.iClocks = 1536000/(60*200);
//         if (ucIRQ1 || regs1.usRegPC != 0x8084) /* busy loop, don't bother */
            EXEC6809(&regs1);
         if (skykidstruct.cCPUEnable)
            {
            regs2a.iClocks = 1536000/(60*200);
            M6803TimerUpdate(&regs2a);
//         if (ucIRQ2 || regs2.usRegPC != 0xf081) /* busy loop, don't bother */
            EXEC6803(&regs2a);
            }
         }
//      if (!(iFrame & iFrameSkip))
//         BaradukeScreenUpdate(); /* Draw any changes */
      PLSoundWrite(&mem_map2[MEM_ROMRAM+0x1100]); /* force an update of the sound parameters */
//      PLSoundUpdate(); /* 60x per second is enough updates to get clean sound */
//      EMUDoSound(FALSE); /* Try to play the sound here */
//      lDirtyRect = -1;
      EMUScreenUpdate(288, 224);
      iFrame++; /* Count the number of frames */
/* Allow messages to flow while we waste time */
//      EMUTimerDelay();
//      EMUDoSound(TRUE); /* Second try after a little delay */
      }
/* Save the hi-score table */
//   if (bHiLoaded)
//      EMUSaveHiscore(&mem_map1[MEM_ROMRAM+0x5000], 80);

//   EMUEndTimer();
//   EMUCloseSound();

cleanup:
   EMUFree(emuh1); /* Free emulation handler table */
   EMUFree(emuh2); /* Free emulation handler table */
   EMUFree(mem_map1); /* Free memory map */
   EMUFree(mem_map2); /* Free memory map */
   EMUFree(mem_sprites);
   EMUFree(pBackground);
   EMUFree(pForeground);
   EMUFree(pWaveforms);
   EMUFree(pPLColors);

//   EMUDeletePalette();
   EMUFreeVideoBuffer(pCoinOpBitmap);

} /* BaradukePlay() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPSharedRead(unsigned short)                               *
 *                                                                          *
 *  PURPOSE    : Read from the 1K shared memory area.                       *
 *                                                                          *
 ****************************************************************************/
unsigned char SPSharedRead(int usAddr)
{
   return mem_map1[MEM_ROMRAM + 0x4000 + (usAddr & 0x3ff)]; /* have both CPU's use the area in CPU1's space */

} /* SPSharedRead() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPSharedWrite(unsigned short, unsigned char)               *
 *                                                                          *
 *  PURPOSE    : Write to the 1K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void SPSharedWrite(int usAddr, unsigned char ucByte)
{
   mem_map1[MEM_ROMRAM + 0x4000 + (usAddr & 0x3ff)] = ucByte; /* have both CPU's use the area in CPU1's space */

} /* SPSharedWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SuperPacInit(void)                                         *
 *                                                                          *
 *  PURPOSE    : Emulate Super PacMan arcade hardware.                      *
 *                                                                          *
 ****************************************************************************/
void SuperPacInit(void)
{
int i, x, y, mx, my;

//   iDirtyHeight = 16;
//   iDirtySections = 18;
/* Set all volume levels to 0 */
   memset(cVolume, 0, sizeof(cVolume));
   coin1 = coin2 = start1 = start2 = credits = 0;
   memset(cDirtyChar,0,4096); /* clean up dirty char map flags */
/* Pre-calculate character positions from the address offset */
   for (i=0; i<1024; i++)
      {
      my = i & 0x1f;
      mx = i >> 5;
      if (mx <= 1)
         {
         x = 29 - my;
         y = mx + 34;
         }
      else if (mx >= 30)
         {
         x = 29 - my;
         y = mx - 30;
         }
      else
         {
         x = 29 - mx;
         y = my + 2;
         }
/* Use the second part of charx to mark chars which need a repaint after being clobbered by a sprite */
      if (x >= 0 && x <28 && y >= 0 && y < 36)
         iCharX[2048 + y*28+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      iCharX[i] = x;
      iCharY[i] = y;
      if (x >=0 && x <223 && y>=0 && y<287)
         lCharAddr[i] = (unsigned long)&pCoinOpBitmap[y*iCoinOpPitch+x]; /* Convert game's video address into screen address */
      else
         lCharAddr[i] = 0; /* Non-visible areas */
      }

} /* SuperPacInit() */

void MappyShowScore(void)
{
int i;
BOOL bLZ; // leading zero
unsigned char *p, pszTemp[16];

   p = &mem_map1[MEM_ROMRAM + 0x1385];
/* Convert BCD to binary */
   for (i=0; i<3; i++)
      {
      pszTemp[i*2] =   p[i] >> 4;
      pszTemp[i*2+1] = p[i] & 0xf;
      }
   bLZ = TRUE;
   for (i=0; i<6; i++)
      {
      if (pszTemp[i] != 0)
         bLZ = FALSE;
      if (!bLZ)
         MappyVideoWrite((unsigned short)(0x7f3-i),(char)(pszTemp[i]));
      }
} /* MappyShowScore() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SuperPacPlay(HANDLE, HWND, char *)                         *
 *                                                                          *
 *  PURPOSE    : Emulate Super PacMan arcade hardware.                      *
 *                                                                          *
 ****************************************************************************/
void SuperPac_Play(GAME_BLOB *pBlob, BOOL bAudio, BOOL bVideo, uint32_t ulSysKeys)
{
int j;
int iFreq, iSlice;

    iFreq = iSlice = 0; // suppress compiler warning
	if (pBlob->bRewound)
	{
		pBlob->bRewound = FALSE;
		SuperPacPostLoad();
	}

	  if (iROMSet == 0) // Super Pac-Man
      {
          if (!bHiLoaded && mem_map1[0x115e] == 0x4f) // need to load high score
            {
            bHiLoaded = TRUE;
            if (!SGLoadHighScore(pBlob->szGameName, &mem_map1[0x1138], 0x28))
                memcpy(&mem_map1[0x1087], &mem_map1[0x1138], 3); // copy highest score
            }
    	  iFreq = 1200000;
    	  iSlice = 16;
      }
      if (iROMSet == 1) // Mappy
      {
          if (iFrame == 0x440) /* Load the hiscore table */
             {
             bHiLoaded = TRUE;
             if (!SGLoadHighScore(pBlob->szGameName, &mem_map1[MEM_ROMRAM+0x1460], 40))
                {
                /* Copy current high score from top of table */
                memcpy(&mem_map1[MEM_ROMRAM+0x1385], &mem_map1[MEM_ROMRAM+0x1460],3);
                // Display it
                MappyShowScore();
                }
             }
    	  iFreq = 1100000;
    	  iSlice = 10;
      }
      if (iROMSet == 2) // DigDug 2
      {
    	  if (iFrame == 0x120)
    	  {
             bHiLoaded = TRUE;
    	     SGLoadHighScore(pBlob->szGameName, &mem_map1[MEM_ROMRAM+0x11b0], 80);
    	  }
    	  iFreq = 1600000;
    	  iSlice = 10;
      }
      if (superpacstruct.cIRQEnable1) /* Do VBLANK interrupt if enabled */
         regs1.ucIRQ |= INT_IRQ; /* CPU1 has IRQ generated by VBLANK */
      if (superpacstruct.cIRQEnable2) /* If this CPU is allowed to run */
         regs2.ucIRQ |= INT_IRQ; /* CPU2 has IRQ generated by VBLANK */
      for (j=0; j<iSlice; j++) /* To keep in sync, slice 100 times per frame */
         {
         regs1.iClocks = iFreq/(60*iSlice);
         EXEC6809(&regs1);
         if (superpacstruct.cCPU2Enable) /* If this CPU is allowed to run */
            {
            regs2.iClocks = iOldTicks = iFreq/(60*iSlice);
            EXEC6809(&regs2);
            }
         }
      if (bAudio)
         {
         SPSoundWrite(&mem_map2[0]); /* force an update of the sound parameters */
         SPSoundUpdate(pBlob->pAudioBuf, pBlob->iSampleCount); /* 60x per second is enough updates to get clean sound */
         }

      if (bVideo)
         {
    	 if (iROMSet == 0)
    		 SPScreenUpdate(); /* Draw all of the characters/colors that changed */
    	 else if (iROMSet == 1)
    		 MappyScreenUpdate();
    	 else if (iROMSet == 2)
    		 DigDug2ScreenUpdate();
         EMUScreenUpdate(224, 288);
         }
      ulOldKeys = ulKeys;

} /* SuperPac_Play() */

void SuperPac_Terminate(GAME_BLOB *pBlob)
{

	/* Save the hi-score table */

	   if (bHiLoaded)
	   {
		  if (iROMSet == 0) // Super Pac-Man
			  SGSaveHighScore(pBlob->szGameName, &mem_map1[0x1138], 0x28);
		  else if (iROMSet == 1) // Mappy
			  SGSaveHighScore(pBlob->szGameName, &mem_map1[0x1460], 40);
	      else if (iROMSet == 2)
  	          SGLoadHighScore(pBlob->szGameName, &mem_map1[0x11b0], 80);
       }
//	   if (bAutoLoad)
//	      MappyLoadSave(6, FALSE);

	   EMUFree(emuh1); /* Free emulation handler table */
	   EMUFree(emuh2); /* Free emulation handler table */
	   EMUFree(mem_map1); /* Free memory map */
	   EMUFree(mem_map2); /* Free memory map */
	   EMUFree(mem_map3); /* Free memory map */
	   EMUFree(pWaveforms);
	   pCoinOpBitmap -= ((iCoinOpPitch*32) + 32);
	   EMUFree(pCoinOpBitmap);
	   EMUFree(iCharX);
	   EMUFree(iCharY);
	   EMUFree(lCharAddr);
	   EMUFree(pColorConvert);
	   EMUFree(pCharmap);
	   EMUFree(pCharPROM);
	   EMUFree(pSpritePROM);
} /* SuperPac_Terminate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MappyInit(void)                                            *
 *                                                                          *
 *  PURPOSE    : Initialize the Mappy emulation.                            *
 *                                                                          *
 ****************************************************************************/
void MappyInit(void)
{
int i, x, y, mx, my;

//   iDirtyHeight = 16;
//   iDirtySections = 18;
/* Clear out any pressed keys before beginning */
   superpacstruct.cMappyScroll = 255;
/* Set all volume levels to 0 */
   memset(cVolume, 0, sizeof(cVolume));
   coin1 = coin2 = start1 = start2 = credits = 0;
   memset(cDirtyChar,0,2048); /* clean up dirty char map flags */
/* Pre-calculate character positions from the address offset */
   for (i=0; i<2048; i++)
      {
      if (i >= 2048 - 64)
         {
         /* Draw the top 2 lines. */
         mx = i & 0x1f;
         my = (i - (2048 - 64)) / 32;
         x = 29 - mx;
         y = my;
         }
      else if (i >= 2048 - 128)
         {
     /* Draw the bottom 2 lines. */
         mx = i & 0x1f;
         my = (i - (2048 - 128)) / 32;
         x = 29 - mx;
         y = my + 34;
         }
      else
         {
      /* draw the rest of the screen */
         mx = i / 32;
         my = i & 0x1f;
         x = 59 - mx;
         y = my + 2;
         }
//      if (x >=0 && x < 62 && y >=0 && y < 34)
//         iCharX[2048 + y*64+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      iCharX[i] = x;
      iCharY[i] = y;
//      if (x == 8 && y == 56)
//         x |= 0;
      if (x < 0 || x > 511 || y < 0 || y > 287)
         lCharAddr[i] = 0; /* Non-visible areas */
      else
         lCharAddr[i] = (unsigned long)&pCharmap[y*512+x]; /* Convert game's video address into screen address */
      }

} /* MappyInit() */

void SuperPac_Reset(void)
{
   RESET6809(&regs1);
   RESET6809(&regs2);
   superpacstruct.cIRQEnable1 = superpacstruct.cCPU2Enable = 0;
} /* SuperPac_Reset() */

void SuperPacPostLoad(void)
{
	memset(cDirtyChar,1,2048); // force a complete repaint
	regs1.mem_map = mem_map1;
	regs1.pEMUH = emuh1;
	regs2.mem_map = mem_map2;
	regs2.pEMUH = emuh2;
    SPSoundWrite(&mem_map2[0]); /* force an update of the sound parameters */
    if (iFrame < 0x500)
       iFrame = 0x500; // don't let it skip the self-test
} /* SuperPacPostLoad() */
// Super Pac-Man (0), Mappy (1), Dig Dug 2 (2)
int SuperPac_Init(GAME_BLOB *pBlob, char *pszROM, int iGameLoad)
{
int i;
//int iNumHandlers1, iNumHandlers2;
RGBQUAD *pRGB;
int iError = SG_NO_ERROR;

    if (pszROM == NULL) // reset request
    {
    	SuperPac_Reset();
    	return iError;
    }
    bHiLoaded = FALSE;
    pColorConvert = NULL;
    pCoinOpBitmap = NULL;
    emuh1 = emuh2 = NULL;
    pWaveforms = NULL;
    mem_map1 = mem_map2 = mem_map3 = NULL;
    pPLColors = NULL;
    lCharAddr = NULL;
    iCharX = iCharY = NULL;
    cDirtyChar = NULL;
    pCharmap = NULL;
//    iNumHandlers1 = iNumHandlers2 = 0;
    pCharPROM = pSpritePROM = NULL;

    cDirtyChar = (unsigned char *)EMUAlloc(4096);
    iCharX = (int *)EMUAlloc(4096*sizeof(int));
    iCharY = (int *)EMUAlloc(4096*sizeof(int));
    lCharAddr = (long unsigned int *)EMUAlloc(4096 * sizeof(long));
    pColorConvert = (unsigned short *)EMUAlloc(256 * sizeof(short));
    pCoinOpBitmap = (unsigned char *)EMUAlloc((288+64) * (224+64));
    iCoinOpPitch = (224+64);
    pCharPROM = (unsigned char *)EMUAlloc(256); /* Allocate memory for color information */
    pSpritePROM = (unsigned char *)EMUAlloc(256); /* Point to correct color PROM */
    if (pCoinOpBitmap == NULL || pColorConvert == NULL)
    {
 	   iError = SG_OUTOFMEMORY;
 	   goto cleanup;
    }
    pCoinOpBitmap += (iCoinOpPitch*32) + 32; // allow for slop over
    if (iROMSet == 0)
    {
    	SuperPacInit();
        iSpriteLimitY = 287; /* Clipping rectangle for sprite handler */
        cTransparent = 0;
    }
    else if (iROMSet == 1 || iROMSet == 2)
    {
        pCharmap = (unsigned char *)EMUAlloc(512*288);
    	MappyInit();
        iSpriteLimitY = 272; /* Clipping rectangle for sprite handler */
    }
    if (iROMSet == 2)
        cTransparent = 0; /* Transparency color for drawing sprites */

    iSpriteLimitX = 224;
    iSuperPacGame = 0; /* Playing superpacman */

    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    emuh2 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
//    mem_map1 = EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map1 = (unsigned char *)EMUAlloc(0x30000+0x40000); /* Allocate 192K for 2 banks and flag map */
    mem_map2 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map3 = (unsigned char *)EMUAlloc(0x20000); /* Allocate 64K for the 2 character/sprite ROMS */
    pWaveforms = (signed char *)EMUAlloc(4096);

    if (iROMSet == 0)
    {
/*--- Load the Superpacman ROMs into memory for CPU 1 ---*/
		if (EMULoadRoms(SUPERPACROMS1, pszROM, NULL, NULL, mem_map1, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
	/*--- Load the Superpacman ROMs into memory for CPU 2 ---*/
		if (EMULoadRoms(SUPERPACROMS2, pszROM, NULL, NULL, mem_map2, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
	/*--- Load the Character/Sprite ROMs into memory ---*/
		if (EMULoadRoms(SUPERPACROMS3, pszROM, NULL, NULL, mem_map3, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
	    memcpy(pSoundPROM, &mem_map3[0x3000], 0x100); /* Copy sound waveforms */
	    PacPrepSounds(3);
	    memcpy(pSpritePROM, &mem_map3[0x3100], 0x100); /* Copy sprite color data */
	    memcpy(pCharPROM, &mem_map3[0x3200], 0x100); // char color data
	    for (i=0; i<256; i++)
	    {
	       pCharPROM[i] += 10; // adjust for our palette
	    }
	    SPConvertChars();
	    /*--- Setup the hardware emulation handlers for CPU #1 ---*/
       EMUSetupHandlers(mem_map1, emuh1, mhSuperPac1);
	    /*--- Setup the hardware emulation handlers for CPU #2 ---*/
       EMUSetupHandlers(mem_map2, emuh2, mhSuperPac2);
	   /* Free up the non-visible video addresses to speed things up a bit */
		  for (i=0; i<1024; i++)
			 {
			 if (lCharAddr[i] == 0) /* non-visible */
				{
				mem_map1[MEM_FLAGS + i] = 0;
				mem_map1[MEM_FLAGS + 0x400 + i] = 0;
				}
			 }
    }
    if (iROMSet == 1)
    {
	/*--- Load the Mappy ROMs into memory for CPU 1 ---*/
		if (EMULoadRoms(MAPPYROMS1, pszROM, NULL, NULL, mem_map1, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
	/*--- Load the Mappy ROMs into memory for CPU 2 ---*/
		if (EMULoadRoms(MAPPYROMS2, pszROM, NULL, NULL, mem_map2, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
	/*--- Load the Character/Sprite ROMs into memory ---*/
		if (EMULoadRoms(MAPPYROMS3, pszROM, NULL, NULL, mem_map3, FALSE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
	    memcpy(pSoundPROM, &mem_map3[0x5000], 0x100); /* Copy sound waveforms */
	    PacPrepSounds(2);
	    for (i=0; i<256; i++)
	      pCharPROM[i] = (31 - ((mem_map3[0x5100 + (i^3)] & 0x0f) + 0x10)) + 0x10;
	         /* sprites */
	    for (i=0; i<256; i++)
	      pSpritePROM[i] = (31 - (mem_map3[0x5200 + i] & 0xf)) + 0x10;
	    MappyConvertChars();
	    /*--- Setup the hardware emulation handlers for CPU #1 ---*/
	    EMUSetupHandlers(mem_map1, emuh1, mhMappy1);
	 /*--- Setup the hardware emulation handlers for CPU #2 ---*/
	    EMUSetupHandlers(mem_map2, emuh2, mhMappy2);
	/* Free up the non-visible video addresses to speed things up a bit */
	   for (i=0; i<2048; i++)
		  {
		  if (lCharAddr[i] == 0) /* non-visible */
			 {
			 mem_map1[MEM_FLAGS + i] = 0;
			 mem_map1[MEM_FLAGS + 0x800 + i] = 0;
			 }
		  }
    }
    if (iROMSet == 2)
    {
    	/*--- Load the DigDug2 ROMs into memory for CPU 1 ---*/
    	    if (EMULoadRoms(DIGDUG2ROMS1, pszROM, NULL, NULL, mem_map1, TRUE))
    		{
    			iError = SG_FILENOTFOUND;
    			goto cleanup;
    		}
    	/*--- Load the DigDug2 ROMs into memory for CPU 2 ---*/
    	    if (EMULoadRoms(DIGDUG2ROMS2, pszROM, NULL, NULL, mem_map2, TRUE))
    		{
    			iError = SG_FILENOTFOUND;
    			goto cleanup;
    		}
    	/*--- Load the Character/Sprite ROMs into memory ---*/
    	    if (EMULoadRoms(DIGDUG2ROMS3, pszROM, NULL, NULL, mem_map3, FALSE))
    		{
    			iError = SG_FILENOTFOUND;
    			goto cleanup;
    		}
    	    memcpy(pSoundPROM, &mem_map3[0x9000], 0x100); /* Copy sound waveforms */
    	    PacPrepSounds(3);
    	    /* Convert the ROM color tables */
    	       for (i=0; i<256; i++)
    	         pCharPROM[i] = (31 - ((mem_map3[0x9100 +(i^3)] & 0x0f) + 0x10)) + 0x10;
    	    /* Since we can't use all 256 palette colors, copy the last 32 entries (e0-ff) onto 60-7f */
    	       for (i=0; i<256; i++)
    	         pSpritePROM[i] = (31 - (mem_map3[0x9200 + i] & 0xf)) + 0x10;
    	    DigDug2ConvertChars();
    	    /*--- Setup the hardware emulation handlers for CPU #1 ---*/
    	    EMUSetupHandlers(mem_map1, emuh1, mhDigDug2_1);
    	 /*--- Setup the hardware emulation handlers for CPU #2 ---*/
    	    EMUSetupHandlers(mem_map2, emuh2, mhMappy2);
    	/* Free up the non-visible video addresses to speed things up a bit */
    	   for (i=0; i<2048; i++)
    		  {
    		  if (lCharAddr[i] == 0) /* non-visible */
    			 {
    			 mem_map1[MEM_FLAGS + i] = 0;
    			 mem_map1[MEM_FLAGS + 0x800 + i] = 0;
    			 }
    		  }
    }
    /* Create the custom palette - it needs 32 colors, but the first 16 are unusable in an ident pal */
        pRGB = (RGBQUAD *)EMUAlloc(sizeof(RGBQUAD) * 256);
        if (iROMSet == 0)
        {
        for (i=0; i<31; i++)
           {
           unsigned char r,g,b;
           r = cSPPal[31-i] & 7;
           g = (cSPPal[31-i] >> 3) & 7;
           b = (cSPPal[31-i] >> 5) & 6;
           pRGB[i+10].rgbRed = cSPColorConvert[r];
           pRGB[i+10].rgbGreen = cSPColorConvert[g];
           pRGB[i+10].rgbBlue = cSPColorConvert[b];
           }
        for (i=0; i<16; i++) // palette 3c/3d/3e/3f for sprite bonus scores
           {
           unsigned char r,g,b;
           r = cSPPal[pSpritePROM[i+240]] & 7;
           g = (cSPPal[pSpritePROM[i+240]] >> 3) & 7;
           b = (cSPPal[pSpritePROM[i+240]] >> 5) & 6;
           pRGB[i+0x4c].rgbRed = cSPColorConvert[r];
           pRGB[i+0x4c].rgbGreen = cSPColorConvert[g];
           pRGB[i+0x4c].rgbBlue = cSPColorConvert[b];
           }
        for (i=0; i<164; i++)
           {
           unsigned char r,g,b;
           r = cSPPal[pSpritePROM[i]] & 7;
           g = (cSPPal[pSpritePROM[i]] >> 3) & 7;
           b = (cSPPal[pSpritePROM[i]] >> 5) & 6;
           pRGB[i+92].rgbRed = cSPColorConvert[r];
           pRGB[i+92].rgbGreen = cSPColorConvert[g];
           pRGB[i+92].rgbBlue = cSPColorConvert[b];
           }
        for (i=192; i<208; i++) // special palette area for animated giant pacman (coffee breaks 2-4)
           { // LIB0002
           unsigned char r,g,b;
           r = cSPPal[pSpritePROM[i]] & 7;
           g = (cSPPal[pSpritePROM[i]] >> 3) & 7;
           b = (cSPPal[pSpritePROM[i]] >> 5) & 6;
           pRGB[i+28].rgbRed = cSPColorConvert[r];
           pRGB[i+28].rgbGreen = cSPColorConvert[g];
           pRGB[i+28].rgbBlue = cSPColorConvert[b];
           }
	    /* Convert the ROM color into the correct format */
        for (i=0; i<256; i++)
          pSpritePROM[i] = (0x1f - (pSpritePROM[i] & 0x0f)) + 0x10;
        }
        if (iROMSet == 1)
        {
            for (i=0; i<32; i++) /* Convert the palette ROM entries into RGB values */
               { /* Use bottom 32 for sprites */
               unsigned char r,g,b;
               r = cMappyPal[31-i] & 7;
               g = (cMappyPal[31-i] >> 3) & 7;
               b = (cMappyPal[31-i] >> 5) & 6;
               pRGB[i+16].rgbRed = cSPColorConvert[r];
               pRGB[i+16].rgbGreen = cSPColorConvert[g];
               pRGB[i+16].rgbBlue = cSPColorConvert[b];
               }
            for (i=0; i<128; i++) /* Convert the char palette ROM entries into RGB values */
               {
               unsigned char r,g,b;
               r = cMappyPal[31-(pCharPROM[i]-16)] & 7;
               g = (cMappyPal[31-(pCharPROM[i]-16)] >> 3) & 7;
               b = (cMappyPal[31-(pCharPROM[i]-16)] >> 5) & 6;
               pRGB[i+48].rgbRed = cSPColorConvert[r];
               pRGB[i+48].rgbGreen = cSPColorConvert[g];
               pRGB[i+48].rgbBlue = cSPColorConvert[b];
               }
            for (i=0; i<36; i++) /* Convert the most used sprite colors for faster access */
               {
               unsigned char r,g,b;
               r = cMappyPal[pSpritePROM[i]] & 7;
               g = (cMappyPal[pSpritePROM[i]] >> 3) & 7;
               b = (cMappyPal[pSpritePROM[i]] >> 5) & 6;
               pRGB[i+176].rgbRed = cSPColorConvert[r];
               pRGB[i+176].rgbGreen = cSPColorConvert[g];
               pRGB[i+176].rgbBlue = cSPColorConvert[b];
               }
        }
        if (iROMSet == 2)
        {
            for (i=0; i<32; i++) /* Convert the palette ROM entries into RGB values */
               {
               unsigned char r,g,b;
               r = cDigDug2Pal[31-i] & 7;
               g = (cDigDug2Pal[31-i] >> 3) & 7;
               b = (cDigDug2Pal[31-i] >> 5) & 6;
               pRGB[i+16].rgbRed = cSPColorConvert[r];
               pRGB[i+16].rgbGreen = cSPColorConvert[g];
               pRGB[i+16].rgbBlue = cSPColorConvert[b];
               }
            for (i=0; i<208; i++) /* Create a palette entry for all used char color possibilities */
               {
               unsigned char r,g,b;
               r = cDigDug2Pal[31-(pCharPROM[i]-16)] & 7;
               g = (cDigDug2Pal[31-(pCharPROM[i]-16)] >> 3) & 7;
               b = (cDigDug2Pal[31-(pCharPROM[i]-16)] >> 5) & 6;
               pRGB[i+48].rgbRed = cSPColorConvert[r];
               pRGB[i+48].rgbGreen = cSPColorConvert[g];
               pRGB[i+48].rgbBlue = cSPColorConvert[b];
               }

        }
        EMUCreatePalette(pRGB, 254);
        EMUFree(pRGB);

	if (pBlob->iAudioSampleRate >= 40000)
	   iAudioShift = 16;
	else if (pBlob->iAudioSampleRate >= 20000)
	   iAudioShift = 15;
	else
	   iAudioShift = 14;

   // Define memory areas for load/save states and networking
   pBlob->mem_areas[0].pPrimaryArea = (unsigned char *)&regs1;
   pBlob->mem_areas[0].iAreaLength = sizeof(regs1);
   pBlob->mem_areas[1].pPrimaryArea = (unsigned char *)&regs2;
   pBlob->mem_areas[1].iAreaLength = sizeof(regs2);
   pBlob->mem_areas[2].pPrimaryArea = (unsigned char *)&superpacstruct;
   pBlob->mem_areas[2].iAreaLength = sizeof(superpacstruct);
   pBlob->mem_areas[3].pPrimaryArea = &mem_map1[0x0000];
   pBlob->mem_areas[3].iAreaLength = 0x4400;
   pBlob->mem_areas[4].pPrimaryArea = &mem_map2[0x0000];
   pBlob->mem_areas[4].iAreaLength = 0x400;
   pBlob->mem_areas[5].iAreaLength = 0; // end of list

/* All set to start, tell the parent window to resize to what we need */
   memset(&regs1,0,sizeof(REGS6809));
   memset(&regs2,0,sizeof(REGS6809));
   regs1.mem_map = mem_map1;
   regs1.pEMUH = emuh1;
   regs2.mem_map = mem_map2;
   regs2.pEMUH = emuh2;
   SuperPac_Reset();

   if (iGameLoad >= 0)
   {
     if (!SGLoadGame(pBlob->szGameName, pBlob, iGameLoad))
     {
    	SuperPacPostLoad();
     }
   }


#ifdef INFINITE_LIVES
   mem_map1[0xe820] = 0xd;
   mem_map1[0xe041] = 0x21; // BRN
   mem_map1[0xe04c] = 0x21;
   mem_map1[0xe133] = 0x21;
#endif

   cleanup:
   	   return iError;
} /* SuperPac_Init() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPVideoWrite(unsigned short, unsigned char)                *
 *                                                                          *
 *  PURPOSE    : Write to the 1K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void SPVideoWrite(int usAddr, unsigned char ucByte)
{

   mem_map1[MEM_ROMRAM + usAddr] = ucByte;
   cDirtyChar[usAddr & 0x3ff] = 1; /* Mark this char as changed */

} /* SPVideoWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPColorWrite(unsigned short, unsigned char)                *
 *                                                                          *
 *  PURPOSE    : Write to the 1K shared memory area.                        *
 *                                                                          *
 ****************************************************************************/
void SPColorWrite(int usAddr, unsigned char ucByte)
{

     mem_map1[MEM_ROMRAM + usAddr] = ucByte;
     cDirtyChar[usAddr & 0x3ff] = 1; /* Mark this color as changed */

} /* SPColorWrite() */

unsigned char readinputport(int iPort)
{
unsigned char c = 0;
static int iImpulse;

 if (ulKeys & RKEY_BUTT1_P1 && !(ulOldKeys & RKEY_BUTT1_P1))
    iImpulse = 1;
 else
    iImpulse = 0;

 switch (iPort)
    {
    case 0:
       if (iSuperPacGame == 0) /* SuperPacman */
          {
          c |= SuperPacOptions[0].iChoice; /* Dipswitch difficulty = bits 0-3 */
          c |= SuperPacOptions[1].iChoice << 4; /* coins per play = bits 4-5 */
          c |= SuperPacOptions[2].iChoice << 6; /* Demo sound = bit 6 */
          c |= SuperPacOptions[3].iChoice << 7; /* Freeze = bit 7 */
          }
//       if (iSuperPacGame == 1) /* PacNPal */
//          {
//          c |= PacNPalOptions[0].iChoice; /* Right coin credits */
//          c |= PacNPalOptions[1].iChoice << 2; /* Rank */
//          }
       break;
    case 1:
       if (iSuperPacGame == 0) /* SuperPacman */
          {
          c |= 0; /* Left coin options = bits 0-2 */
          c |= SuperPacOptions[4].iChoice << 3; /* Bonus life = bits 3-5 */
          c |= SuperPacOptions[5].iChoice << 6; /* Lives = bits 6-7 */
          }
//       if (iSuperPacGame == 1) /* PacNPal options */
//          {
//          c |= PacNPalOptions[2].iChoice; /* Credits bits 0-2 */
//          c |= PacNPalOptions[3].iChoice << 3; /* High score bonus bits 3-5*/
//          c |= PacNPalOptions[4].iChoice << 6; /* Lives bits 6-7 */
//          }
       break;
    case 2:
       if (ulKeys & RKEY_UP_P1) /* Up */
          c |= 1;
       if (ulKeys & RKEY_RIGHT_P1) /* Right */
          c |= 2;
       if (ulKeys & RKEY_DOWN_P1) /* Down */
          c |= 4;
       if (ulKeys & RKEY_LEFT_P1) /* Left */
          c |= 8;
//       if (ulKeys & RKEY_BUTT1_P1 && !(ulOldKeys & RKEY_BUTT1_P1)) /* Button 1 */
       if (iImpulse)
          {
          iImpulse--;
          c |= 16;
          }
       if (ulOldKeys & RKEY_BUTT1_P1) /* Button 1 - previous value */
          c |= 32;
       break;
    case 3:
       if (ulKeys & RKEY_COIN1) /* Coin 1 */
          c |= 1;
       if (ulKeys & RKEY_P1_START) /* Start 1 */
          c |= 0x10;
       if (ulKeys & RKEY_P2_START) /* Start 2 */
          c |= 0x20;
//       if (ulKeys & RKEY_LEFT_P1) /* Left */
//          c |= 8;
//       c |= 0; /* orientation = bit 6 */
       c |= SuperPacOptions[6].iChoice << 7; /* Service Mode - bit 7 */
       break;
    default:
       c = 0;
       break;
    }
   return c;
}
void superpac_update_credits (void)
{
        int val = readinputport (3) & 0x0f, temp;
        if (val & 1)
        {
                if (!coin1) credits++, coin1++;
        }
        else coin1 = 0;

        if (val & 2)
        {
                if (!coin2) credits++, coin2++;
        }
        else coin2 = 0;

        temp = readinputport (1) & 7;
        val = readinputport (3) >> 4;
        if (val & 1)
        {
                if (!start1 && credits >= credden[temp]) credits -= credden[temp], start1++;
        }
        else start1 = 0;

        if (val & 2)
        {
                if (!start2 && credits >= 2 * credden[temp]) credits -= 2 * credden[temp], start2++;
        }
        else start2 = 0;
}
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPIO1Read(unsigned short)                                  *
 *                                                                          *
 *  PURPOSE    : Read from the 1K shared memory area.                       *
 *                                                                          *
 ****************************************************************************/
unsigned char SPIO1Read(int usAddr)
{
        int offset, val, temp;

    offset = usAddr & 0xf;
        superpac_update_credits ();
        switch (mem_map1[MEM_ROMRAM + 0x4808])
        {
                /* mode 1 & 3 are used by Pac & Pal, and returns actual important values */
                case 1:
                case 3:
                        switch (offset)
                        {
                                case 0:
                                        val = readinputport (3) & 0x0f;
                                        break;

                                case 1:
                                        val = readinputport (2) & 0x0f;
                                        break;

                                case 2:
                                        val = 0;
                                        break;

                                case 3:
                                        val = (readinputport (3) >> 4) & 3;
                                        val |= val << 2;

                                        /* I don't know the exact mix, but the low bit is used both for
                                           the fire button and for player 1 start; I'm just ORing for now */
                                        val |= readinputport (2) >> 4;
                                        break;

                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                        val = 0xf;
                                        break;

                                default:
                                        val = mem_map1[MEM_ROMRAM + usAddr];
                                        break;
                        }
                        return val;

                /* mode 4 is the standard, and returns actual important values */
                case 4:
                        switch (offset)
                        {
                                case 0:
//                                      superpac_update_credits ();
                                        temp = readinputport (1) & 7;
                                        val = (credits * crednum[temp] / credden[temp]) / 10;
                                        break;

                                case 1:
//                                      superpac_update_credits ();
                                        temp = readinputport (1) & 7;
                                        val = (credits * crednum[temp] / credden[temp]) % 10;
                                        break;

                                case 4:
                                        val = readinputport (2) & 0x0f;
                                        break;

                                case 5:
                                        val = readinputport (2) >> 4;
                                        break;

                                case 6:
                                case 7:
                                        val = 0xf;
                                        break;

                                default:
                                        val = mem_map1[MEM_ROMRAM + usAddr];
                                        break;
                        }
                        return val;

                /* mode 8 is the test mode: always return 0 for these locations */
                case 8:
                        credits = 0;
                        if (offset >= 9 && offset <= 15)
                                return 0;
                        break;
        }
        return mem_map1[MEM_ROMRAM + usAddr];

} /* SPIO1Read() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPIO2Read(unsigned short)                                  *
 *                                                                          *
 *  PURPOSE    : Read from the 1K shared memory area.                       *
 *                                                                          *
 ****************************************************************************/
unsigned char SPIO2Read(int usAddr)
{
        int val, offset;

    offset = usAddr & 0xf;
        switch (mem_map1[MEM_ROMRAM + 0x4818])
        {
                /* mode 3 is the standard for Pac & Pal, and returns actual important values */
                case 3:
                        switch (offset)
                        {
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                        val = 0;
                                        break;

                                case 4:
                                        val = readinputport (0) & 0xf;
                                        break;

                                case 5:
                                        val = readinputport (1) >> 4;
                                        break;

                                case 6:
                                        val = readinputport (1) & 0xf;
                                        break;

                                case 7:
                                        val = (readinputport (3) >> 4) & 0x0c;
                                        break;

                                default:
                                        val = mem_map1[MEM_ROMRAM + usAddr];
                                        break;
                        }
                        return val;

                /* mode 9 is the standard, and returns actual important values */
                case 9:{
                        switch (offset)
                        {
                                case 0:
                                        val = readinputport (1) & 0x0f;
                                        break;

                                case 1:
                                        val = readinputport (1) >> 4;
                                        break;

                                case 2:
                                        val = 0;
                                        break;

                                case 3:
                                        val = readinputport (0) & 0x0f;
                                        break;

                                case 4:
                                        val = readinputport (0) >> 4;
                                        break;

                                case 5:
                                        val = 0;
                                        break;

                                case 6:
                                        val = (readinputport (3) >> 4) & 0x0c;
                                        break;

                                case 7:
                                        val = 0;
                                        break;

                                default:
                                        val = mem_map1[MEM_ROMRAM + usAddr];
                                        break;
                        }
                        return val;}

                /* mode 8 is the test mode: always return 0 for these locations */
                case 8:
                        credits = 0;
                        if (offset >= 9 && offset <= 15)
                                return 0;
                        break;
        }
        return mem_map1[MEM_ROMRAM + usAddr];

} /* SPIO2Read() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPWriteNULL(unsigned short, unsigned char)                 *
 *                                                                          *
 *  PURPOSE    : Write to empty space.                                      *
 *                                                                          *
 ****************************************************************************/
void SPWriteNULL(int usAddr, unsigned char ucByte)
{
//unsigned char c;
//c = 0;
} /* SPWriteNULL() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPReadNULL(unsigned short)                                 *
 *                                                                          *
 *  PURPOSE    : Placeholder routine for memory read.                       *
 *                                                                          *
 ****************************************************************************/
unsigned char SPReadNULL(int usAddr)
{
   return 0;
} /* SPReadNULL() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SPIRQWrite(unsigned short, unsigned char)                  *
 *                                                                          *
 *  PURPOSE    : A write to 5003 enables, 5002 disables.                    *
 *                                                                          *
 ****************************************************************************/
void SPIRQWrite(int usAddr, unsigned char ucByte)
{

   switch(usAddr)
      {
      case 0x5000: /* IRQ enable for CPU 1 ??? */
      case 0x5001:
    	  superpacstruct.cIRQEnable1 = usAddr & 1;
         break;
      case 0x5002: /* IRQ enable for CPU 1 */
      case 0x5003:
    	  superpacstruct.cIRQEnable1 = usAddr & 1;
         break;
//      case 0x5004: /* ?? */
//      case 0x5005:
//         superpacstruct.cIRQEnable2 = usAddr & 1;
//         break;
      case 0x5006: /* IRQ enable for CPU 1 */
      case 0x5007:
    	  superpacstruct.cIRQEnable1 = usAddr & 1;
         break;
      case 0x5008: /* Sound enable */
      case 0x5009:
         break;
      case 0x500a: /* CPU #2 enable? */
      case 0x500b:
    	  superpacstruct.cCPU2Enable = usAddr & 1;
         break;
//      case 0x500c: /* CPU #2 enable? ??? */
//      case 0x500d:
//         cIRQEnable2 = usAddr & 1;
//         break;
      case 0x500e:
      case 0x500f:
    	  superpacstruct.cCPU2Enable = usAddr & 1; /* ??? */
         break;
      }

} /* SPIRQWrite() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacInit(void)                                              *
 *                                                                          *
 *  PURPOSE    : Emulate Super PacMan arcade hardware.                      *
 *                                                                          *
 ****************************************************************************/
void PacInit(void)
{
int i, mx, my, x, y;

//   pSounds = NULL; /* No samples to play */
   memset(cDirtyChar,0,2048); /* clean up dirty char map flags */
   pacstruct.cPacIRQVal = pacstruct.cPacIRQEnable = pacstruct.cPacSoundEnable = 0;
   memset(cVolume, 0, sizeof(cVolume));
   memset(iFreq, 0, sizeof(iFreq));
/* Create a lookup table for character positions from addresses */
   for (i=0; i<1024; i++)
      {
      my = i & 0x1f;
      mx = i >> 5;
      if (mx <= 1)
         {
         x = 29 - my;
         y = mx + 34;
         }
      else if (mx >= 30)
         {
         x = 29 - my;
         y = mx - 30;
         }
      else
         {
         x = 29 - mx;
         y = my + 2;
         }
/* Use the second part of charx to mark chars which need a repaint after being clobbered by a sprite */
      if (x >= 0 && x <28 && y >= 0 && y < 36)
         iCharX[2048 + y*28+x] = i; /* Translate the x,y back into an address */
      x <<= 3;
      y <<= 3;
      iCharX[i] = x;
      iCharY[i] = y;
      if (x >=0 && x <223 && y>=0 && y<287)
         lCharAddr[i] = (unsigned long)&pCoinOpBitmap[y*iCoinOpPitch+x]; /* Convert game's video address into screen address */
      else
         lCharAddr[i] = 0; /* Non-visible areas */
      }
//   iDirtySections = 18;
//   iDirtyHeight = 16; // 18*16 = 288

} /* PacInit() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacShowHiscore(unsigned short, unsigned short, int)        *
 *                                                                          *
 *  PURPOSE    : Copy the hiscore from memory to the display since the      *
 *               PacMan code was too stupid to do it by itself.             *
 *                                                                          *
 ****************************************************************************/
void PacShowHiscore(unsigned short usRAM, unsigned short usScreen, int iLen)
{
unsigned char c, *p, pszTemp[16];
BOOL bLZ; // leading zeros
int i;

   p = &mem_map[MEM_ROMRAM + usRAM];
   /* Convert from packed BCD to binary */
   for (i=0; i<iLen; i++)
      {
      pszTemp[i*2] = p[iLen-1-i] >> 4;
      pszTemp[i*2+1] = p[iLen-1-i] & 0xf;
      }
   bLZ = TRUE;
   for (i=0; i<8; i++)
      {
      if (pszTemp[i] != 0)
         bLZ = FALSE;
      if (!bLZ)
         c = pszTemp[i];
      else
         c = 0x40;
      if (iPacGame == GAME_JRPAC)
         JRPacVideoWrite((unsigned short)(usScreen-i),c);
      else
         PacVideoWrite((unsigned short)(usScreen-i),c);
      }

} /* PacShowHiscore() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PengoDrawSprites(unsigned char *)                          *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
void PengoDrawSprites(unsigned char *cColorPROM, int iSpriteMEM1, int iSpriteMEM2)
{
int i, j;
unsigned char *p, ucSprite, ucColor;
int x, y;
BOOL bFlipx, bFlipy;

	/* Draw the sprites. Note that it is important to draw them exactly in this */
	/* order, to have the correct priorities. */
	/* sprites #0 and #7 are not used */

   for (i=6; i>0; i--)
      {
      ucColor = mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i+1] & 0x1f;
      if (ucColor) /* Only draw it if it changed and not the black sprite */
         {
         ucSprite = 64*pacstruct.iGfxBank + (mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i] >> 2);
         bFlipx = mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i] & 2;
         bFlipy = mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i] & 1;
         x = 239 - mem_map[MEM_ROMRAM + iSpriteMEM2 + 2*i];
         y = 272 - mem_map[MEM_ROMRAM + iSpriteMEM2 + 2*i+1];
         if (pacstruct.iGfxBank)
            {
            cTransparent = 16;
            EMUDrawSprite2(x, y, ucSprite, ucColor*4, bFlipx, bFlipy, &mem_map3[32768], cPengoCharPROM+(128*pacstruct.iGfxBank));
            }
         else
            {
            cTransparent = 0;
            EMUDrawGraphicTransparent(x, y, ucSprite, 48+ucColor*4, bFlipx, bFlipy, &mem_map3[32768], pCoinOpBitmap, iCoinOpPitch, 16, 16);
            }
         j = -65 + 32 * (29 - (x / 8)) + (y / 8)-1; /* character offset */
         if (j > 0)
            {
            p = &cDirtyChar[j];
            p[0] = 1;
            p[1] = 1;
            p[2] = 1;
            p[32] = 1;
            p[33] = 1;
            p[34] = 1;
            p[64] = 1;
            p[65] = 1;
            p[66] = 1;
	        }
// DEBUG
//         lDirtyRect |= 1 << (y / 9); /* Mark this area as needing a repaint */
//         lDirtyRect |= 1 << ((y+15) / 9); /* Span the entire size of sprite */
         }
      } /* for */

} /* PengoDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacDrawSprites(unsigned char *)                            *
 *                                                                          *
 *  PURPOSE    : Draw all of the active sprites.                            *
 *                                                                          *
 ****************************************************************************/
void PacDrawSprites(unsigned char *cColorPROM, int iSpriteMEM1, int iSpriteMEM2)
{
int i;
unsigned char ucSprite, ucColor;
int *p, x, y, mx, my, cx, cy;
BOOL bFlipx, bFlipy;

	/* Draw the sprites. Note that it is important to draw them exactly in this */
	/* order, to have the correct priorities. */
	/* sprites #0 and #7 are not used */

   for (i=6; i>0; i--)
      {
      ucColor = mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i+1] & 0x1f;
      if (ucColor) /* Only draw it if it changed and not the black sprite */
         {
         ucSprite = mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i] >> 2;
         bFlipx = mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i] & 2;
         bFlipy = mem_map[MEM_ROMRAM + iSpriteMEM1 + 2*i] & 1;
         if (i <= 2) /* First two sprites are offset 1 pel to left */
            x = 238 - mem_map[MEM_ROMRAM + iSpriteMEM2 + 2*i]; // LIB0001
         else
            x = 239 - mem_map[MEM_ROMRAM + iSpriteMEM2 + 2*i];
         y = 272 - mem_map[MEM_ROMRAM + iSpriteMEM2 + 2*i+1];
         ucColor = 16 + ucColor*4;
         if (ucColor == 0x74) /* Eyes */
            ucSprite += 64; /* Use alternate sprite data with 3's turned into zero's */
         EMUDrawGraphicTransparent(x, y, ucSprite, ucColor, bFlipx, bFlipy, &mem_map3[16384], pCoinOpBitmap, iCoinOpPitch, 16, 16);
         mx = x>>3; /* Get the x,y in terms of character coordinates */
         my = y>>3;
         cx = cy = 2; /* 16x16 sprite = 2x2 char block */
         if (x & 7) /* If touching next char, need to redraw it */
            cx++;
         if (y & 7) /* Same goes for vertical */
            cy++;
         p = &iCharX[2048+(28*my)+mx]; /* Our special coordinate conversion table */
         for (y=0; y<cy; y++)
            {
            for (x=0; x<cx; x++)
               {
               cDirtyChar[p[x]] = 1; /* Mark the char as needing a repaint */
               }
            p += 28; /* Next line */
            }
//         lDirtyRect |= 1 << (y>>4); /* Mark this area as needing a repaint */
//         lDirtyRect |= 1 << ((y+15)>>4); /* Span the entire size of sprite */
         }
      } /* for */

} /* PacDrawSprites() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PengoScreenUpdate(void)                                    *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void PengoScreenUpdate(void)
{
register int i;
unsigned char ucChar;
int iColor;

   for (i=0; i<1023; i++)
      {
      if (cDirtyChar[i])
         {
         cDirtyChar[i] = 0;
         ucChar = mem_map[0x8000 + i]; /* Get the character value */
//         lDirtyRect |= 1<<(iCharY[i]>>4); /* Mark this area as needing a repaint */
         if (pacstruct.iGfxBank)
            {
            iColor = (4 * (mem_map[0x8400 + i] & 0x1f)); /* Get the character color */
            EMUDrawChar(i, cPengoCharPROM+(256*pacstruct.iGfxBank), iCoinOpPitch, ucChar + 256*pacstruct.iGfxBank, iColor, lCharAddr, mem_map3); /* Update this character/color */
            }
         else
            {
            iColor = 32 + (4 * (mem_map[0x8400 + i] & 0x1f)); /* Get the character color */
            EMUDrawCharFast(i, iCoinOpPitch, ucChar, iColor, lCharAddr, mem_map3); /* Update this character/color */
            }
         }
      }
/* Draw sprites on top of the characters */
   PengoDrawSprites(cPengoCharPROM, 0x8ff0, 0x9020); /* Draw all of the sprites on top of the characters */

} /* PengoScreenUpdate() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PacScreenUpdate(unsigned char *)                           *
 *                                                                          *
 *  PURPOSE    : Refresh all of the characters/colors that changed.         *
 *                                                                          *
 ****************************************************************************/
void PacScreenUpdate(unsigned char *cColorPROM)
{
register int i;
register unsigned char ucChar, ucColor;

   for (i=0; i<1023; i++)
      {
      if (cDirtyChar[i]) /* Char changed */
         {
         cDirtyChar[i] = 0;
         ucChar = mem_map[MEM_ROMRAM + 0x4000 + i]; /* Get the character value */
         ucColor = 4 * (mem_map[MEM_ROMRAM + 0x4400 + i] & 0x1f); /* Get the character color */
         EMUDrawCharFast(i, iCoinOpPitch, ucChar, ucColor, lCharAddr, mem_map3); /* Update this character/color */
//         lDirtyRect |= 1<<(iCharY[i]>>4);
         }
      }
//   memset(cDirtyChar,0,1024); /* Clear for next time through */
/* Draw sprites on top of the characters */
   PacDrawSprites(cColorPROM, 0x4ff0, 0x5060); /* Draw all of the sprites on top of the characters */

} /* PacScreenUpdate() */

void Pac_Terminate(GAME_BLOB *pBlob)
{
	/* Save the hi-score table */
	if (bHiLoaded)
        SGSaveHighScore(pBlob->szGameName, &mem_map[0x4e88], 4);

    EMUFree(pColorConvert);
    pColorConvert = NULL;
    EMUFree(pCoinOpBitmap);
    pCoinOpBitmap = NULL;
    EMUFree(emuh1);
    emuh1 = NULL;
    EMUFree(pWaveforms);
    pWaveforms = NULL;
    EMUFree(mem_map);
    mem_map = NULL;
    EMUFree(mem_map3);
    mem_map3 = NULL;
    EMUFree(lCharAddr);
    lCharAddr = NULL;
    EMUFree(iCharX);
    iCharX = NULL;
    EMUFree(iCharY);
    iCharY = NULL;
    EMUFree(cDirtyChar);
    cDirtyChar = NULL;

} /* Pac_Terminate() */

void Pac_Reset(void)
{

   ARESETZ80(&regs, 0xff);
   pacstruct.ucIRQ = 0;

} /* Pac_Reset() */

void PacPostLoad(void)
{
 	 memset(cDirtyChar,1,2048); // force a complete repaint
 	 PacSoundRefresh(0x5040);
 	 if (iFrame < 0x210)
 	    iFrame = 0x210; // don't let it skip the self-test
} /* PacPostLoad() */

int Pac_Init(GAME_BLOB *pBlob, char *pszROM, int iGameLoad)
{
int i;
//int iNumHandlers1;
RGBQUAD *pRGB;
int iError = SG_NO_ERROR;

    if (pszROM == NULL) // reset request
    {
    	Pac_Reset();
    	return iError;
    }
    bHiLoaded = FALSE;
    pCoinOpBitmap = NULL;
    emuh1 = NULL;
    mem_map = mem_map3 = NULL;
    pWaveforms = NULL;
    lCharAddr = NULL;
    iCharX = iCharY = NULL;
    cDirtyChar = NULL;
//    pSounds = NULL; /* No samples to play */
    cTransparent = 0; /* Transparency color - used to be 0, but we added 16 for identity palette */

    cDirtyChar = (unsigned char *)EMUAlloc(4096);
    iCharX = (int *)EMUAlloc(4096*sizeof(int));
    iCharY = (int *)EMUAlloc(4096*sizeof(int));
    lCharAddr = (long unsigned int *)EMUAlloc(4096 * sizeof(long));
    pColorConvert = (unsigned short *)EMUAlloc(256 * sizeof(short));
    pCoinOpBitmap = (unsigned char *)EMUAlloc((224+32) * (288+32));
    iCoinOpPitch = (224+32);
    if (pCoinOpBitmap == NULL || pColorConvert == NULL)
    {
 	   iError = SG_OUTOFMEMORY;
 	   goto cleanup;
    }
    PacInit();
    iSpriteLimitX = 224;
    iSpriteLimitY = 288;
    if (iROMSet == 0 || iROMSet == 2)
       iPacGame = GAME_PAC;
    else if (iROMSet == 1)
       iPacGame = GAME_MSPAC;

    emuh1 = (EMUHANDLERS *)EMUAlloc(sizeof(EMUHANDLERS)*20); /* Allow up to 20 hardware emulation handlers */
    pWaveforms = (signed char *)EMUAlloc(4096);
    mem_map = (unsigned char *)EMUAlloc(0x20000); /* Allocate 192K for 2 banks and flag map */
    mem_map3 = (unsigned char *)EMUAlloc(0x10000);
    if (iROMSet == 0) // Pac-Man
    {
		if (EMULoadRoms(PACROMS1, pszROM, NULL, NULL, mem_map, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
		/*--- Load the Character ROMs into memory ---*/
		if (EMULoadRoms(PACROMS2, pszROM, NULL, NULL, mem_map3, FALSE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
    }
    if (iROMSet == 1) // Ms. Pac-Man
    {
		if (EMULoadRoms(MSPACROMS1, pszROM, NULL, NULL, mem_map, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
		/*--- Load the Character ROMs into memory ---*/
		if (EMULoadRoms(MSPACROMS2, pszROM, NULL, NULL, mem_map3, FALSE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
    }
    if (iROMSet == 2) // Pengo
    {
		if (EMULoadRoms(PENGOROMS1, pszROM, NULL, NULL, mem_map, TRUE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
		/*--- Load the Character ROMs into memory ---*/
		if (EMULoadRoms(PENGOROMS2, pszROM, NULL, NULL, mem_map3, FALSE))
		{
			iError = SG_FILENOTFOUND;
			goto cleanup;
		}
    }

    if (iROMSet == 2) // Pengo
   	   memcpy(pSoundPROM, &mem_map3[0x4000], 0x100); /* Copy Sound waveforms */
    else
       memcpy(pSoundPROM, &mem_map3[0x2000], 0x100); /* Copy Sound waveforms */
    if (iROMSet == 2) // Pengo
    {
    unsigned char *pTemp, *pTemp2;
	   pTemp = (unsigned char *)EMUAlloc(16384);
	   pTemp2 = (unsigned char *)EMUAlloc(0x10000); /* Room for all 512 chars and 128 sprites */
	   memcpy(pTemp, mem_map3, 16384); /* Keep a copy to decode second bank */
	   PacConvertChars(); /* Decode first char/sprite bank */
	   memcpy(pTemp2, mem_map3, 16384); /* Copy first set of chars */
	   memcpy(&pTemp2[32768], &mem_map3[16384], 16384); /* Copy first set of sprites */
	   memcpy(mem_map3, &pTemp[8192], 8192); /* Copy second bank for conversion */
	   PacConvertChars(); /* Convert second bank of chars */
	   memcpy(&pTemp2[16384], mem_map3, 16384); /* Copy second bank of chars */
	   memcpy(&pTemp2[49152], &mem_map3[16384],16384); /* Copy second bank of sprites */
	   EMUFree(pTemp);
	   EMUFree(mem_map3);
	   mem_map3 = pTemp2;
    }
    else
    {
       PacConvertChars();
    }
    if (iROMSet == 0 || iROMSet == 2)
	   PacPrepSounds(2); /* Prepare pre-calculated waveform data */
    else if (iROMSet == 1) // Ms Pac
       PacPrepSounds(1);
    if (iROMSet == 2) // Pengo
    {
        for (i=0; i<256; i++)
           cPengoCharPROM[i] |= 0x10; /* Fix palette lookup info for char/sprite bank 0 */
        for (i=256; i<512; i++)
           cPengoCharPROM[i] |= 0x20; /* Fix palette lookup info char bank 1*/
    }
	/* Convert the palette ROMs into a more usable form */
	pRGB = (RGBQUAD *)EMUAlloc(sizeof(RGBQUAD) * 256);
	if (iROMSet == 2) // Pengo
	{
	    for (i=0; i<32; i++) /* Convert the palette ROM entries into RGB values */
	       {
	       unsigned char r,g,b;
	       r = cPengoPal[i] & 7; /* Do the color indirection here to save time when drawing */
	       g = (cPengoPal[i] >> 3) & 7;
	       b = (cPengoPal[i] >> 5) & 6;
	       pRGB[i+16].rgbRed = cPacColorConvert[r];
	       pRGB[i+16].rgbGreen = cPacColorConvert[g];
	       pRGB[i+16].rgbBlue = cPacColorConvert[b];
	       }
	/* Create the colors used by char/sprite bank 0 */
	    for (i=0; i<128; i++)
	       {
	       unsigned char r,g,b;
	       r = cPengoPal[cPengoCharPROM[i] & 0x0f] & 7; /* Do the color indirection here to save time when drawing */
	       g = (cPengoPal[cPengoCharPROM[i] & 0x0f] >> 3) & 7;
	       b = (cPengoPal[cPengoCharPROM[i] & 0x0f] >> 5) & 6;
	       pRGB[i+48].rgbRed = cPacColorConvert[r];
	       pRGB[i+48].rgbGreen = cPacColorConvert[g];
	       pRGB[i+48].rgbBlue = cPacColorConvert[b];
	       }
	}
	else
	{
		for (i=0; i<128; i++) /* Convert the palette ROM entries into RGB values */
		   {
		   unsigned char r,g,b;
		   r = cPacPal[cPacCharPROM[i]] & 7; /* Do the color indirection here to save time when drawing */
		   g = (cPacPal[cPacCharPROM[i]] >> 3) & 7;
		   b = (cPacPal[cPacCharPROM[i]] >> 5) & 6;
		   pRGB[i+16].rgbRed = cPacColorConvert[r];
		   pRGB[i+16].rgbGreen = cPacColorConvert[g];
		   pRGB[i+16].rgbBlue = cPacColorConvert[b];
		   }
	}
    EMUCreatePalette(pRGB, 160);
    EMUFree(pRGB);

	/*--- Setup the hardware emulation handlers ---*/
//    iNumHandlers1 = 0;
    if (iROMSet == 2)
       EMUSetupHandlers(mem_map, emuh1, mhPengo);
    else
       EMUSetupHandlers(mem_map, emuh1, mhPac);

    /* Speed things up by removing the handlers from non-visible video addresses */
       for (i=0; i<1024; i++)
          {
          if (lCharAddr[i] == 0) /* Non-visible character */
             mem_map[MEM_FLAGS + 0x4000+i] = mem_map[MEM_FLAGS+0x4400+i] = 0; /* Remove handler */
          }
     /* Mark this as ROM, not I/O since the IN/OUT handlers always call proc #2 */
     memset(&mem_map[MEM_FLAGS], 0xbf, 256);
     Pac_Reset();
     if (pBlob->iAudioSampleRate >= 40000)
        iAudioShift = 14;
     else if (pBlob->iAudioSampleRate >= 20000)
        iAudioShift = 13;
     else
    	iAudioShift = 12;

     // Define memory areas for load/save states and networking
     pBlob->mem_areas[0].pPrimaryArea = (unsigned char *)&regs;
     pBlob->mem_areas[0].iAreaLength = sizeof(regs);
     pBlob->mem_areas[1].pPrimaryArea = (unsigned char *)&pacstruct;
     pBlob->mem_areas[1].iAreaLength = sizeof(pacstruct);
     if (iROMSet == 2) // Pengo
        pBlob->mem_areas[2].pPrimaryArea = &mem_map[0x8000];
     else
        pBlob->mem_areas[2].pPrimaryArea = &mem_map[0x4000];
     pBlob->mem_areas[2].iAreaLength = 0x1100;
     pBlob->mem_areas[3].iAreaLength = 0; // end of list

     if (iGameLoad >= 0)
     {
  	     if (!SGLoadGame(pBlob->szGameName, pBlob, iGameLoad))
  	     {
  	    	 PacPostLoad();
  	     }
     }

   cleanup:
   	   return iError;

} /* Pac_Init() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : Pac_Play(GAME_BLOB *pBlob, BOOL, BOOL, ULONG)              *
 *                                                                          *
 *  PURPOSE    : Emulate the Pac-Man games.                                 *
 *                                                                          *
 ****************************************************************************/
void Pac_Play(GAME_BLOB *pBlob, BOOL bAudio, BOOL bVideo, uint32_t ulSysKeys)
{
int iCPUTicks;

    if (pBlob->bRewound) // game was just rewound, need to do a complete refresh
    {
    	pBlob->bRewound = FALSE;
    	memset(cDirtyChar, 1, 2048); // force a repaint
    }
	if (!bHiLoaded)
	{
	   if (iROMSet == 2) // Pengo
	   {
		  if (iFrame == 1) /* We can load the highscore now, no self test */
			 {
			 SGLoadHighScore(pBlob->szGameName, &mem_map[0x8840], 30);
			 mem_map[0x880c] = mem_map[0x8858];
				mem_map[0x880d] = mem_map[0x8859];
			 bHiLoaded = TRUE;
			 }
	   }
	   else
	   {
	      if (iFrame == 0x210) /* We can load the highscore now, self test has finished */
	      {
             if (SGLoadHighScore(pBlob->szGameName, &mem_map[0x4e88], 4))
		        memset(&mem_map[0x4e88], 0, 4); // no highscore, set to 0's
	         PacShowHiscore(0x4e88, 0x43f4, 4);
	         bHiLoaded = TRUE;
	      }
	   }
	}
	if (pacstruct.cPacIRQEnable)
		pacstruct.ucIRQ |= INT_IRQ; /* Cause a vectored IRQ */
	regs.ucIRQVal = pacstruct.cPacIRQVal;
	iOldTicks = iCPUTicks = 3072000/60; /* 3.072 Mhz */
	AEXECZ80(mem_map, &regs, emuh1, &iCPUTicks, &pacstruct.ucIRQ);
	if (bAudio)
	{
	   if (iROMSet == 2) // Pengo
		  PengoSoundRefresh();
	   else
	      PacSoundRefresh(0x5040);
	   PacSoundUpdate(pBlob->pAudioBuf, pBlob->iSampleCount); /* update any remaining sound information */
	}
	if (bVideo)
	{
	   if (iROMSet == 2) // Pengo
		  PengoScreenUpdate();
	   else
	      PacScreenUpdate(cPacCharPROM); /* Draw all of the characters/colors that changed */
	   EMUScreenUpdate(224, 288);
	}
} /* Pac_Play() */
